/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...
// #define DEBUGGPU
// #define WidthLimit
#define Misha

// #define KMatrix_Lambda
#define BW_Lambda
#define KMatrix_Pc
// #define BW_Pc
#include "RooTDalitz/RooDalitzAmplitude.h"
#include "Math/CholeskyDecomp.h"
#include "Math/SMatrix.h"
#include "Riostream.h"
#include "RooAbsCategory.h"
#include "RooAbsPdf.h"
#include "RooAbsReal.h"
#include "RooAddition.h"
#include "RooArgProxy.h"
#include "RooArgSet.h"
#include "RooBinnedGenContext.h"
#include "RooCachedReal.h"
#include "RooCategory.h"
#include "RooChi2Var.h"
#include "RooCmdConfig.h"
#include "RooConstraintSum.h"
#include "RooCurve.h"
#include "RooCustomizer.h"
#include "RooDataSet.h"
#include "RooFit.h"
#include "RooFitResult.h"
#include "RooGenContext.h"
#include "RooGlobalFunc.h"
#include "RooInt.h"
#include "RooMinimizer.h"
#include "RooMinuit.h"
#include "RooMsgService.h"
#include "RooNLLVar.h"
#include "RooNameReg.h"
#include "RooNumCdf.h"
#include "RooNumGenConfig.h"
#include "RooNumIntConfig.h"
#include "RooParamBinning.h"
#include "RooPlot.h"
#include "RooProjectedPdf.h"
#include "RooRandom.h"
#include "RooRealIntegral.h"
#include "RooRealProxy.h"
#include "RooRealVar.h"
#include "RooTDalitz/Resonances.h"
#include "RooTDalitz/RooSUMVar.h"
#include "RooXYChi2Var.h"
#include "TClass.h"
#include "TFile.h"
#include "TH1.h"
#include "TH2.h"
#include "TIterator.h"
#include "TList.h"
#include "TMath.h"
#include "TMatrixD.h"
#include "TMatrixDSym.h"
#include "TObjString.h"
#include "TPaveText.h"
#include "TTree.h"
#include <algorithm>
#include <math.h>
#include <regex>
#include <string>
#include <time.h>
// #include "nvToolsExt.h"

typedef ROOT::Math::SMatrix<float, NKMC> SMatrixNN;

#define PAW

// For integration
// TComplex AA[2][2][2][MYRN][MYRN][6][6];
// TComplex AAZ[2][2][2][MYZN][MYZN][12][12];
// TComplex ABZ[2][2][2][MYZN][MYRN][12][6];
// TComplex amp[MYRN][2][2][2][6];
// TComplex ampZ[MYZN][2][2][2][12];
// Float_t sumW;

// ClassImp(RooDalitzAmplitude)
// int nset = 6; //used for _paraList store m0, g0, S2, LR, type, defed for each resoance
float NN = 10000.;
// const float _mres0 = -0.114064 ; //wmz debug
// const float _mres1 =  0.0799014;
// const float _mres2 = -0.00855841;
// CG (1,1,L,S,0,1) S=1,3,5,7,9,11, L= S-1, S+1
Double_t C2[6][2] = {1.0000000000000000e+00,
                     -5.7735026918962584e-01,
                     -5.7735026918962573e-01,
                     4.4721359549995765e-01,
                     4.4721359549995754e-01,
                     -3.7796447300922748e-01,
                     -3.7796447300922759e-01,
                     3.3333333333333659e-01,
                     3.3333333333332898e-01,
                     -3.0151134457775197e-01,
                     -3.0151134457772666e-01,
                     2.7735009811269257e-01};

// ClassImp(RooDalitzAmplitude)

Int_t Hel1Two[] = {1, 1, -1, -1, 3, -3}; // helicity of L* x 2
Int_t Hel2[] = {1, 0, 0, -1, 1, -1};     // helicity of Jpsi in L* chain
// Float_t _FFR(3.0);
// Float_t _FFB(3.0);
RooDalitzAmplitude::RooDalitzAmplitude(const char *name,
                                       const char *title,
                                       RooArgList &values,
                                       TList *resList,
                                       TList *resListZ,
                                       TList *resListX,
                                       RooArgList *ratioList,
                                       RooAbsReal &FFR_var,
                                       RooAbsReal &FFB_var,
                                       const TString mcdata,
                                       RooDataSet &data,
                                       RooAbsReal &widthUpperLimit_var,
                                       RooAbsReal &widthLowerLimit_var,
                                       RooAbsReal &CalFWHM_nbin_var,
                                       RooAbsReal &CalFWHM_range_var,
                                       bool fortoystudy)
    : RooAbsPdf(name, title), _values("values", "values", this), _resList(resList),
      _resListZ(resListZ), _resListX(resListX),
      resParams("resParams", "Parameters for resonaces", this), CG1(1, 2), CG3(3, 2), CG5(5, 2),
      CG7(7, 2), CG9(9, 2), CG21(2, 1), CG41(4, 1), CG03(0, 3), CG23(2, 3), CG43(4, 3), CG63(6, 3),
      CG02(0, 2), CG22(2, 2), CG42(4, 2), _FFR("_FFR", "_FFR", this, FFR_var),
      _FFB("_FFB", "_FFB", this, FFB_var),
      _widthUpperLimit("_widthUpperLimit", "_widthUpperLimit", this, widthUpperLimit_var),
      _widthLowerLimit("_widthLowerLimit", "_widthLowerLimit", this, widthLowerLimit_var),
      _CalFWHM_nbin("_CalFWHM_nbin", "_CalFWHM_nbin", this, CalFWHM_nbin_var),
      _CalFWHM_range("_CalFWHM_range", "_CalFWHM_range", this, CalFWHM_range_var)
//          _widthUpperLimit(widthUpperLimit),
//          _widthLowerLimit(widthLowerLimit),
//          _CalFWHM_nbin(CalFWHM_nbin),
//          _CalFWHM_range(CalFWHM_range)
//_FFR(FFR_var->getVal()),
//_FFB(FFB_var->getVal())
// MCDATA(mcdata)
{
    // Check if conflicting preprocessor logics are defined

#ifdef RESPLUS
#ifdef RESMINUS
    assert(false); // Exit if we define resolution + and - together
#endif
#endif

#ifdef SigmacPlusDzero
#ifdef SigmacPlusPlusDMinus
    assert(false); // Exit if we define two sigma_c D masses config together
#endif
#endif

#ifdef Lst_LBPlusOne
#ifndef Pc_LBPlusOne
    assert(false); // L_lowest + 1 must be defined together
#endif
#endif

#ifdef Pc_LBPlusOne
#ifndef Lst_LBPlusOne
    assert(false); // L_lowest + 1 must be defined together
#endif
#endif

#ifdef GPU
    std::cout << "GPU defined " << std::endl;
#endif
    m_lb = 5.61951;
    m_pi = 0.13957039;
    m_p = 0.938272046;
    m_jpsi = 3.096916;
    m_chic1 = 3.51067;
    TIterator *coefIter1 = values.createIterator();
    RooAbsArg *coef;

    while ((coef = (RooAbsArg *)coefIter1->Next())) {
        if (!dynamic_cast<RooAbsReal *>(coef)) {
            assert(0);
        }
        _values.add(*coef);
    }

    int nrSP(0);
    TIterator *coefIter = _resList->MakeIterator();
    while (RooArgList *Ires = (RooArgList *)coefIter->Next()) {
        // for (int i=0; i<nres; i++) {
        // RooDalitzResonance *res = (RooDalitzResonance*)_resList->At( ires );

        //     RooArgList *ires = (RooArgList*)_resList->At( i );
        RooArgList ires = (*Ires);
        int iressize = ires.getSize();

        if ((int)((RooAbsReal &)ires[iressize - 3]).getVal() == MODELINDEPENDENT)
            nrSP++;
        for (int i = 0; i < ires.getSize() - 3; ++i)
            resParams.add(ires[i]);
    }

    TIterator *coefIterZ = _resListZ->MakeIterator();
    while (RooArgList *Ires = (RooArgList *)coefIterZ->Next()) {
        // for (int i=0; i<nres; i++) {
        // RooDalitzResonance *res = (RooDalitzResonance*)_resList->At( ires );

        //     RooArgList *ires = (RooArgList*)_resList->At( i );
        RooArgList ires = (*Ires);
        int iressize = ires.getSize();

        if ((int)((RooAbsReal &)ires[iressize - 3]).getVal() == MODELINDEPENDENT)
            nrSP++;
        for (int i = 0; i < ires.getSize() - 3; ++i)
            resParams.add(ires[i]);
    }

    TIterator *coefIterX = _resListX->MakeIterator();
    while (RooArgList *Ires = (RooArgList *)coefIterX->Next()) {
        // for (int i=0; i<nres; i++) {
        // RooDalitzResonance *res = (RooDalitzResonance*)_resList->At( ires );

        //     RooArgList *ires = (RooArgList*)_resList->At( i );
        RooArgList ires = (*Ires);
        int iressize = ires.getSize();

        for (int i = 0; i < ires.getSize() - 3; ++i)
            resParams.add(ires[i]);
    }

    for (auto iter = ratioList->begin(); iter < ratioList->end(); iter++) {
        RooRealVar *variable = dynamic_cast<RooRealVar *>(*iter);
        resParams.add(*variable);
    }

    std::cout << "# of resonance as Spline " << nrSP << std::endl;
    NR = _resList->GetSize();
    NZ = _resListZ->GetSize();
    NX = _resListX->GetSize();
    int nres = NR + NZ + NX;
    std::cout << "Number of Resonances " << nres << std::endl;
    std::cout << "NR = " << NR << std::endl;
    std::cout << "NZ = " << NZ << std::endl;
    std::cout << "NX = " << NX << std::endl;

    // These constexpr values are used in CUDA code
    // CUDA amplitude calculator will not work if assert fails
    assert(NR == Constant::number_of_Lz);
    assert(NZ == Constant::number_of_Pc);
    assert(NX == Constant::number_of_Zcs);

    int ncached = 20;
    _resParCache = new Float_t[ncached];
    for (int i = 0; i < ncached; i++)
        _resParCache[i] = 0;
    // #ifdef WidthLimit
    _mypnalty = 0.0;
    _kmchanged = false;
    //        std::cout << "Done _resParCache" << std::endl;
    // #endif
    double costheta, costheta1, costheta2, phi1, phi2;
    double mppi, sw, mjpsip, mjpsipi;
    double phiZ;
    double phiMu;
    double phiPsi;
    double alphaMu;
    double costhetaB;
    double costhetaPsi;
    double costhetaZ;
    double costhetap;

    double X_cosTheta_Lb;
    double X_phiX;
    double X_cosTheta_X;
    double X_phiJpsi;
    double X_cosTheta_Jpsi;
    double X_phiMu;
    double X_cosTheta_p;
    double X_alpha_Mu;
    if (MYXN == 0) {
        mjpsipi = 4.4;
        X_cosTheta_Lb = 0.;
        X_phiX = 0.;
        X_cosTheta_X = 0.;
        X_phiJpsi = 0.;
        X_cosTheta_Jpsi = 0.;
        X_phiMu = 0.;
        X_cosTheta_p = 0.;
        X_alpha_Mu = 0.;
    }
    // fill data
    // for cache of data
    PDLZ = std::make_shared<std::vector<Jpsihh_dlz *>>();

    // read mc
    // TChain
    char cname[20];
    char swname[20];
    sprintf(cname, "h1");
    if (fortoystudy) {
        sprintf(cname, "tree");
    }
    sprintf(swname, "sw");

    // sw.resize(_Nda, 0);
    sumW_data = 0;
    _Nda = 0;
    _Nda_SMR1 = 0;
    _Nda_SMR_finebinning = 0;
    RooArgSet *row;
    int smcnum = data.numEntries();

    for (int i = 0; i < smcnum; ++i) {
        row = (RooArgSet *)data.get(i);
        // Try
        Jpsihh_dlz *xdlz = new Jpsihh_dlz();
        //    Jpsihh_dlz& xdlz = *Ixdlz;
        // Jpsihh_dlz xdlz;// = *Ixdlz;

        // row->Print("V");
        mppi = ((RooAbsReal *)row->find("mppi"))->getVal();
        // if(!kine_limits(mppi)) { std::cout << "why " << std::endl;}

        costheta = ((RooAbsReal *)row->find("cosTheta_Lb"))->getVal();
        costheta1 = ((RooAbsReal *)row->find("cosTheta_L"))->getVal();
        costheta2 = ((RooAbsReal *)row->find("cosTheta_Jpsi"))->getVal();
        phi1 = ((RooAbsReal *)row->find("phipi"))->getVal();
        phi2 = ((RooAbsReal *)row->find("phiMu"))->getVal();
        costhetaB = ((RooAbsReal *)row->find("Z_cosTheta_Lb"))->getVal();
        costhetaZ = ((RooAbsReal *)row->find("Z_cosTheta_Z"))->getVal();
        costhetaPsi = ((RooAbsReal *)row->find("Z_cosTheta_Jpsi"))->getVal();
        phiZ = ((RooAbsReal *)row->find("Z_phiZ"))->getVal();
        phiPsi = ((RooAbsReal *)row->find("Z_phiJpsi"))->getVal();
        phiMu = ((RooAbsReal *)row->find("Z_phiMu"))->getVal();
        costhetap = ((RooAbsReal *)row->find("cosTheta_p"))->getVal();
        alphaMu = ((RooAbsReal *)row->find("alpha_Mu"))->getVal();
        mjpsip = ((RooAbsReal *)row->find("mjpsip"))->getVal();
        if (MYXN != 0) {
            mjpsipi = ((RooAbsReal *)row->find("mjpsipi"))->getVal();
            X_cosTheta_Lb = ((RooAbsReal *)row->find("X_cosTheta_Lb"))->getVal();
            X_phiX = ((RooAbsReal *)row->find("X_phiX"))->getVal();
            X_cosTheta_X = ((RooAbsReal *)row->find("X_cosTheta_X"))->getVal();
            X_phiJpsi = ((RooAbsReal *)row->find("X_phiJpsi"))->getVal();
            X_cosTheta_Jpsi = ((RooAbsReal *)row->find("X_cosTheta_Jpsi"))->getVal();
            X_phiMu = ((RooAbsReal *)row->find("X_phiMu"))->getVal();
            X_cosTheta_p = ((RooAbsReal *)row->find("X_cosTheta_p"))->getVal();
            X_alpha_Mu = ((RooAbsReal *)row->find("X_alpha_Mu"))->getVal();
        }
        _sw.push_back(data.weight());
        // sw = data.weight();
        // printf("sw: %f", sw);
        //         //wmzwmz test
        //     phi1 = phi1 + TMath::Pi();
        //     if(phi1>TMath::Pi()) phi1 = phi1-2*TMath::Pi();
        //     costheta1 = -costheta1;
        sumW_data += data.weight();

        filldlz((*xdlz),
                mppi,
                costheta,
                costheta1,
                costheta2,
                phi1,
                phi2,
                costhetaB,
                costhetaZ,
                costhetaPsi,
                phiZ,
                phiPsi,
                phiMu,
                costhetap,
                alphaMu,
                mjpsip,
                X_cosTheta_Lb,
                X_cosTheta_X,
                X_cosTheta_Jpsi,
                X_phiX,
                X_phiJpsi,
                X_phiMu,
                X_cosTheta_p,
                X_alpha_Mu,
                mjpsipi);
        //    if ((xdlz->mjpsip > 4.2 && xdlz->mjpsip < 4.43) || (xdlz->mjpsip > 4.47 &&
        //    xdlz->mjpsip < 4.6))
        if (xdlz->mjpsip > 4.2 && xdlz->mjpsip < 4.6) {
            if (xdlz->mjpsip < 4.43 || xdlz->mjpsip > 4.47) {
                _Nda_SMR1++;
            } else {
                _Nda_SMR_finebinning++;
            }
        }

        PDLZ->push_back(xdlz);
        _Nda++;
    }
    int mcflat(0);
    if (mcdata.Contains("MCFlatAcc")) {
        sprintf(cname, "MyTuple");
        sprintf(swname, "nsig_sw");
        mcflat = 1;
    }
    if (mcdata.Contains("Toy")) {
        sprintf(cname, "MyTuple");
        sprintf(swname, "nsig_sw");
    }

    TChain *smcdata = new TChain(cname);
    if (mcdata != "") {
        smcdata->Add(mcdata);
    }

    smcdata->SetBranchAddress("mppi", &mppi);
    smcdata->SetBranchAddress("mjpsip", &mjpsip);
    smcdata->SetBranchAddress("cosTheta_Lb", &costheta);
    smcdata->SetBranchAddress("cosTheta_L", &costheta1);
    smcdata->SetBranchAddress("cosTheta_Jpsi", &costheta2);
    //
    smcdata->SetBranchAddress("phipi", &phi1);
    smcdata->SetBranchAddress("phiMu", &phi2);
    smcdata->SetBranchAddress("Z_cosTheta_Lb", &costhetaB);
    smcdata->SetBranchAddress("Z_cosTheta_Z", &costhetaZ);
    smcdata->SetBranchAddress("Z_cosTheta_Jpsi", &costhetaPsi);
    smcdata->SetBranchAddress("Z_phiZ", &phiZ);
    smcdata->SetBranchAddress("Z_phiJpsi", &phiPsi);
    smcdata->SetBranchAddress("Z_phiMu", &phiMu);
    smcdata->SetBranchAddress("cosTheta_p", &costhetap);
    smcdata->SetBranchAddress("alpha_Mu", &alphaMu);
    if (MYXN != 0) {
        smcdata->SetBranchAddress("mjpsipi", &mjpsipi);
        smcdata->SetBranchAddress("X_cosTheta_Lb", &X_cosTheta_Lb);
        smcdata->SetBranchAddress("X_cosTheta_X", &X_cosTheta_X);
        smcdata->SetBranchAddress("X_cosTheta_Jpsi", &X_cosTheta_Jpsi);
        smcdata->SetBranchAddress("X_phiX", &X_phiX);
        smcdata->SetBranchAddress("X_phiJpsi", &X_phiJpsi);
        smcdata->SetBranchAddress("X_phiMu", &X_phiMu);
        smcdata->SetBranchAddress("X_cosTheta_p", &X_cosTheta_p);
        smcdata->SetBranchAddress("X_alpha_Mu", &X_alpha_Mu);
    }
    smcdata->SetBranchAddress(swname, &sw);

    smcnum = smcdata->GetEntries();
    if (mcflat == 1)
        smcnum = 1000000;
    //  if(mcflat==1) smcnum = 100000; //wmz debug
    sumW = 0.0;
    _Nmc = 0;

    // for cache of MC

    for (int imc = 0; imc < smcnum; imc++) {
        smcdata->GetEntry(imc);
        // mppi>2GeV
        if (!kine_limits(mppi))
            continue;
        if (!kine_limitsZ(mjpsip))
            continue;
        if (!kine_limitsX(mjpsipi))
            continue;
        Jpsihh_dlz *xdlz = new Jpsihh_dlz();

        //        //wmzwmz test
        //    phi1 = phi1 + TMath::Pi();
        //    if(phi1>TMath::Pi()) phi1 = phi1-2*TMath::Pi();
        //    costheta1 = -costheta1;

        filldlz((*xdlz),
                mppi,
                costheta,
                costheta1,
                costheta2,
                phi1,
                phi2,
                costhetaB,
                costhetaZ,
                costhetaPsi,
                phiZ,
                phiPsi,
                phiMu,
                costhetap,
                alphaMu,
                mjpsip,
                X_cosTheta_Lb,
                X_cosTheta_X,
                X_cosTheta_Jpsi,
                X_phiX,
                X_phiJpsi,
                X_phiMu,
                X_cosTheta_p,
                X_alpha_Mu,
                mjpsipi,
                sw);
        sumW += sw;
        //    float fx(0);
        PDLZ->push_back(xdlz);
        _Nmc++;
    }

    _fx.resize(_Nmc + _Nda, 0);
    std::cout << "INT MC size " << std::endl;

    delete coefIter;
    delete coefIterZ;
    delete coefIterX;
    delete coefIter1;

    std::cout << "MC+Data size " << PDLZ->size() << " " << PDLZ->capacity() << std::endl;
    smcdata->Delete();
    _paraList.clear();
    _paraList.resize((NR + NZ + NX) * nset);
    std::cout << "_paraList size " << _paraList.size() << std::endl;
    setup_paraList();

    cuda_configure_Pc_KMatrix(_paraList.data());
    cuda_configure_ampcount(_paraList.data(), _paraList.size());
    cuda_configure_smear();
    //  _paraSpline.clear();
    //  _paraSpline.resize(nrSP*NUMSP*2);
    analyticalIntegral(6);
    //  IntegralMethod1();
}

RooDalitzAmplitude::RooDalitzAmplitude(const RooDalitzAmplitude &other, const char *name)
    : RooAbsPdf(other, name), _values("values", this, other._values), _resList(other._resList),
      _resListZ(other._resListZ), _resListX(other._resListX),
      resParams("resParams", this, other.resParams), _Nmc(other._Nmc), _Nda(other._Nda),
      _Nda_SMR1(other._Nda_SMR1), _Nda_SMR_finebinning(other._Nda_SMR_finebinning), CG1(other.CG1),
      CG3(other.CG3), CG5(other.CG5), CG7(other.CG7), CG9(other.CG9), CG21(other.CG21),
      CG41(other.CG41), CG03(other.CG03), CG23(other.CG23), CG43(other.CG43), CG63(other.CG63),
      CG02(other.CG02), CG22(other.CG22), CG42(other.CG42), AA(other.AA), AAZ(other.AAZ),
      ABZ(other.ABZ), amp(other.amp), ampZ(other.ampZ), ampX(other.ampX),
      _FFR("_FFR", this, other._FFR), _FFB("_FFB", this, other._FFB),
      _widthUpperLimit(other._widthUpperLimit), _widthLowerLimit(other._widthLowerLimit),
      _CalFWHM_nbin(other._CalFWHM_nbin), _CalFWHM_range(other._CalFWHM_range), PDLZ(other.PDLZ),
      _fx(other._fx), _sw(other._sw), _paraList(other._paraList), _vamp(other._vamp),
      _paraSpline(other._paraSpline), _galpha(other._galpha), _fscat(other._fscat),
      _bprod(other._bprod), _selfscatter(other._selfscatter), _sa3(other._sa3), _sp3(other._sp3),
      _mynll(other._mynll), _mypnalty(other._mypnalty), _kmchanged(other._kmchanged), NR(other.NR),
      NZ(other.NZ), NX(other.NX), sumW(other.sumW), sumW_data(other.sumW_data), m_lb(other.m_lb),
      m_pi(other.m_pi), m_p(other.m_p), m_jpsi(other.m_jpsi), m_chic1(other.m_chic1) {
    int n = PDLZ->size();
    std::cout << "new PDLZ size " << n << std::endl;
    //  pdlz = other.pdlz;
    //  PDLZ = other.PDLZ;
    //   for(int i=0; i<NR+NZ; ++i) _paraList[i*nset+5] = false;
    // TChain
    // smcdata = new TChain("mctree");
    // smcdata->Add(MCDATA);
    //   std::cout << "_galpha size " <<  _galpha[0].size() << " " << _galpha[1].size() <<
    //   std::endl;
    _resParCache = other._resParCache;
#ifdef GPU
    //  nvtxRangePush("one time data transfer");
    std::cout << "Begin GPU part "
              << "  " << DEVICE_NUM << std::endl;
    d_float_pp.resize(DEVICE_NUM);
    d_float_pp1.resize(DEVICE_NUM);
    d_float_pp2.resize(DEVICE_NUM);
    d_float_pp3.resize(DEVICE_NUM);
    d_float_pp4.resize(DEVICE_NUM);

    d_float_sw.resize(DEVICE_NUM);
    int i_End = other.PDLZ->size();
    // int array_num = sizeof(cu_Jpsihh_dlz) / sizeof(float);
    int array_num = 111; // mppi, mjpsip, w, L* chain ARe, AIm, DL
    int array_num1 = 96; // Pc chain AZRe, AZIm
    int array_num2 = 96; // Pc chain DZ
    int array_num3 = 97; // mjpsipi, Zcs chain AXRe, AXIm
    int array_num4 = 96; // Zcs chain DX
    if (MYXN == 0) {
        array_num3 = 0;
        array_num4 = 0;
    }
    // array_num = (int(array_num / 8) + 1) * 8; //to force to be 32(=8*sizeof(float)) * N
    std::cout << "size of ... " << array_num << " , " << array_num1 << " ,  " << array_num2
              << " ,  " << array_num3 << " ,  " << array_num4 << std::endl;

    // int array_size = array_num * i_End;
    h_float_pp.resize(DEVICE_NUM);
    h_float_pp1.resize(DEVICE_NUM);
    h_float_pp2.resize(DEVICE_NUM);
    h_float_pp3.resize(DEVICE_NUM);
    h_float_pp4.resize(DEVICE_NUM);
    // h_float_pp = new float[array_size];

    // the entry region of each GPU
    int Ns[DEVICE_NUM + 1];
    Ns[0] = 0;
    for (int i = 1; i < DEVICE_NUM; i++) {
        Ns[i] = Ns[i - 1] + i_End / DEVICE_NUM;
    }
    Ns[DEVICE_NUM] = i_End;

    for (int i = 0; i < DEVICE_NUM; i++) {
        float *temp_pp;
        float *temp_pp1;
        float *temp_pp2;
        float *temp_pp3;
        float *temp_pp4;
        int N_size = Ns[i + 1] - Ns[i];
        N_size = (N_size / 32 + 1) * 32; // coalesced access
        h_float_pp[i] = new float[array_num * N_size];
        h_float_pp1[i] = new float[array_num1 * N_size];
        h_float_pp2[i] = new float[array_num2 * N_size];
        h_float_pp3[i] = new float[array_num3 * N_size];
        h_float_pp4[i] = new float[array_num4 * N_size];
        int it_h_float_pp = 0;

        for (int it = Ns[i]; it < Ns[i + 1]; it++) {
            auto pp = (*PDLZ)[it];
            // float *k = (float *)(*PDLZ)[i];
            // for (int j = 0; j < array_num; j++)
            //     h_float_pp[i * array_num + j] = (float)k[j];
            h_float_pp[i][it_h_float_pp] = pp->mppi;
            h_float_pp[i][it_h_float_pp + 1 * N_size] = pp->mjpsip;
            h_float_pp[i][it_h_float_pp + 2 * N_size] = pp->w;

            for (int ii = 0; ii < 2; ++ii) {  // delmu
                for (int j = 0; j < 2; ++j) { // hel0
                    for (int m = 0; m < 6; ++m) {
                        h_float_pp[i][it_h_float_pp + (3 + (ii * 6 * 2 + j * 6 + m) * 2) * N_size] =
                            pp->ARe[ii][j][m];
                        h_float_pp[i][it_h_float_pp + (3 + (ii * 6 * 2 + j * 6 + m) * 2 + 1) *
                                                          N_size] = pp->AIm[ii][j][m];
                    }
                }
            }
            // now the init index is 51
            for (int ii = 0; ii < 5; ++ii) {
                for (int k = 0; k < 2; ++k) {
                    for (int m = 0; m < 6; ++m) {

                        h_float_pp[i][it_h_float_pp + (51 + ii * 6 * 2 + k * 6 + m) * N_size] =
                            pp->DL[ii][k][m];
                    }
                }
            }
            it_h_float_pp++;
        }
        it_h_float_pp = 0;
        for (int it = Ns[i]; it < Ns[i + 1]; it++) {
            auto pp = (*PDLZ)[it];
            for (int ii = 0; ii < 2; ++ii) {  // delmu
                for (int j = 0; j < 2; ++j) { // hel0
                    for (int m = 0; m < 12; ++m) {
                        h_float_pp1[i][it_h_float_pp + ((ii * 12 * 2 + j * 12 + m) * 2) * N_size] =
                            pp->AZRe[ii][j][m];
                        h_float_pp1[i][it_h_float_pp + ((ii * 12 * 2 + j * 12 + m) * 2 + 1) *
                                                           N_size] = pp->AZIm[ii][j][m];
                    }
                }
            }
            it_h_float_pp++;
        }
        it_h_float_pp = 0;
        for (int it = Ns[i]; it < Ns[i + 1]; it++) {
            auto pp = (*PDLZ)[it];
            for (int ii = 0; ii < 4; ++ii) {
                for (int k = 0; k < 2; ++k) {
                    for (int m = 0; m < 12; ++m) {

                        h_float_pp2[i][it_h_float_pp + (ii * 12 * 2 + k * 12 + m) * N_size] =
                            pp->DZ[ii][k][m];
                    }
                }
            }
            it_h_float_pp++;
        }
        if (MYXN != 0) {
            it_h_float_pp = 0;
            for (int it = Ns[i]; it < Ns[i + 1]; it++) {
                auto pp = (*PDLZ)[it];
                h_float_pp3[i][it_h_float_pp] = pp->mjpsipi;
                for (int ii = 0; ii < 2; ++ii) {
                    for (int j = 0; j < 2; ++j) {
                        for (int m = 0; m < 12; ++m) {
                            h_float_pp3[i][it_h_float_pp + (1 + (ii * 12 * 2 + j * 12 + m) * 2) *
                                                               N_size] = pp->AXRe[ii][j][m];
                            h_float_pp3[i][it_h_float_pp +
                                           (1 + (ii * 12 * 2 + j * 12 + m) * 2 + 1) * N_size] =
                                pp->AXIm[ii][j][m];
                        }
                    }
                }
                it_h_float_pp++;
            }
            it_h_float_pp = 0;
            for (int it = Ns[i]; it < Ns[i + 1]; it++) {
                auto pp = (*PDLZ)[it];
                for (int ii = 0; ii < 4; ++ii) {
                    for (int k = 0; k < 2; ++k) {
                        for (int m = 0; m < 12; ++m) {

                            h_float_pp4[i][it_h_float_pp + (ii * 12 * 2 + k * 12 + m) * N_size] =
                                pp->DX[ii][k][m];
                        }
                    }
                }
                it_h_float_pp++;
            }
        }
        // cu_malloc_h_pp_Bp(h_float_pp[i], temp_pp, PDLZ->size(), i);
        cu_malloc_h_pp(h_float_pp[i], temp_pp, array_num * N_size * sizeof(float), i);
        d_float_pp[i] = temp_pp;
        cu_malloc_h_pp(h_float_pp1[i], temp_pp1, array_num1 * N_size * sizeof(float), i);
        d_float_pp1[i] = temp_pp1;
        cu_malloc_h_pp(h_float_pp2[i], temp_pp2, array_num2 * N_size * sizeof(float), i);
        d_float_pp2[i] = temp_pp2;
        cu_malloc_h_pp(h_float_pp3[i], temp_pp3, array_num3 * N_size * sizeof(float), i);
        d_float_pp3[i] = temp_pp3;
        cu_malloc_h_pp(h_float_pp4[i], temp_pp4, array_num4 * N_size * sizeof(float), i);
        d_float_pp4[i] = temp_pp4;
    }
    for (int i = 0; i < DEVICE_NUM; i++) {
        free(h_float_pp[i]);
        free(h_float_pp1[i]);
        free(h_float_pp2[i]);
        free(h_float_pp3[i]);
        free(h_float_pp4[i]);
    }

    // begin of chenchen
    float *h_float_sw[DEVICE_NUM];
    // int Ns[DEVICE_NUM+1];
    for (int i = 0; i < DEVICE_NUM; i++) {
        float *temp_sw;

        // int N_size = min(Ns[i+1]-Ns[i], _Nda-Ns[i]);
        int N_size = Ns[i + 1] - Ns[i];
        N_size = (N_size / 32 + 1) * 32;
        h_float_sw[i] = new float[N_size];

        int it_h_float_sw = 0;
        for (int it = Ns[i]; it < Ns[i + 1]; it++) {
            if (!(it < _Nda))
                continue;
            h_float_sw[i][it_h_float_sw] = _sw[it];
            it_h_float_sw++;
        }

        cu_malloc_h_pp(h_float_sw[i], temp_sw, N_size * sizeof(float), i);
        d_float_sw[i] = temp_sw;
    }

    for (int i = 0; i < DEVICE_NUM; i++) {
        free(h_float_sw[i]);
    }
    // end of chenchen

    /*
    for (int i = 0; i < i_End; i++)
    {
      float *k = (float *)(*PDLZ)[i];
      for (int j = 0; j < array_num; j++)
        h_float_pp[i * array_num + j] = (float)k[j];
    }
    for (int i = 0; i < DEVICE_NUM; i++)
    {
      float *temp_pp;
      cu_malloc_h_pp(h_float_pp, temp_pp, PDLZ->size(), i);
      d_float_pp[i] = temp_pp;
    }
    free(h_float_pp);*/
//  nvtxRangePop();
#endif
}

Bool_t RooDalitzAmplitude::kine_limits(float mpp) const {
    if (mpp < m_pi + m_p)
        return false;
    if (mpp > m_lb - m_jpsi)
        return false;
    return true;
}

Bool_t RooDalitzAmplitude::kine_limitsZ(float mjpsip) const {
    if ((mjpsip < m_jpsi + m_p) || (m_lb < mjpsip + m_pi))
        return false;
    return true;
}

Bool_t RooDalitzAmplitude::kine_limitsX(float mjpsipi) const {
    if ((mjpsipi < m_jpsi + m_pi) || (m_lb < mjpsipi + m_p))
        return false;
    return true;
}

/*
Double_t RooDalitzAmplitude::evaluate() const
{
  int index = (int)((RooAbsReal &)_values[_values.getSize() - 1]).getVal();
  float inttt(-1);
  //call integration first, otherwise it's called after evaluate of first event//Important
  if (_norm)
    inttt = _norm->getVal();
  //add protection????
  //  if(index==10) std::cout << "Test 10 " << _fx[index] << std::endl;
  return _fx[index]; //+_Nmc];
}
*/

Double_t RooDalitzAmplitude::evaluate() const {
    double inttt(0.);
    // call integration first, otherwise it's called after evaluate of first event//Important
    if (_norm)
        inttt = _norm->getVal();
        // printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!nll: %f\n", _mynll -
        // 1000000);
#ifdef CPU
    int index = (int)((RooAbsReal &)_values[_values.getSize() - 1]).getVal();
    _mynll = _fx[index];
//    _mynll = _fx[index] * (1. - _beta) + _beta * (inttt / SumBkg) * _fbg[index];
#endif
#ifdef WidthLimit
    std::cout.precision(12);
    //        std::cout << "wmz debug mynll before mypnalty = " << _mynll << std::endl;
    _mynll += _mypnalty;
//        std::cout << "wmz debug mynll after mypnalty = " << _mynll << std::endl;
#endif
    return _mynll;
}

void RooDalitzAmplitude::CalAmp2s() const {
// Only available with GPU
#ifdef GPU
#ifdef DEBUGGPU
    clock_t start, end;
    start = clock();
#endif

    float *h_paraList;
    double *h_amp2s;
    cu_init_data(h_paraList, h_amp2s, _Nda);
    host_store_amp2s(d_float_pp,
                     d_float_pp1,
                     d_float_pp2,
                     d_float_pp3,
                     d_float_pp4,
                     h_paraList,
                     _paraList.size(),
                     _vamp.size(),
                     _paraSpline.size(),
                     h_amp2s,
                     _Nda,
                     0,
                     NR,
                     NZ,
                     NX,
                     _FFR,
                     _FFB);

    free(h_paraList);
    _perEventAmp2.resize(_Nda, 0.);
    for (size_t i = 0; i < _Nda; i++) {
        _perEventAmp2[i] = h_amp2s[i];
    }
    free(h_amp2s);
#ifdef DEBUGGPU
    end = clock();
    std::cout << "gpu part  time :" << (double)(end - start) / CLOCKS_PER_SEC << "S" << std::endl;
#endif
#endif
}

void RooDalitzAmplitude::storeLineshape(const TString path) const {
    CalCoupling();

    float *h_paraList;
    double *h_amp2s;

    std::vector<TString> resonance_names;
    std::vector<size_t> Lz_indices;
    for (size_t i = 0; i < NR; i++) {
        int type = _paraList[i * nset + TYPE];
        if (type == REVISEDKMATRIX) {
            resonance_names.push_back(_resList->At(i)->GetName());
            Lz_indices.push_back(i);
        }
    }
    int nLz = Lz_indices.size();

    int n_points = 4096;
    std::vector<float> h_mppi(n_points);
    for (size_t i = 0; i < n_points; i++) {
        h_mppi[i] = (m_pi + m_p + i * (m_lb - m_jpsi - m_pi - m_p) / n_points);
    }

    std::vector<float> h_KM_real(n_points * nLz);
    std::vector<float> h_KM_imag(n_points * nLz);
    std::vector<float> h_BW_real(n_points * nLz);
    std::vector<float> h_BW_imag(n_points * nLz);

    // TODO: configure indices
    cu_init_data(h_paraList, h_amp2s, _Nda);

    host_store_lineshapeLsKM(h_mppi.data(),
                             h_KM_real.data(),
                             h_KM_imag.data(),
                             h_BW_real.data(),
                             h_BW_imag.data(),
                             n_points,
                             NR,
                             nLz,
                             _FFR,
                             h_paraList,
                             _paraList.size(),
                             _vamp.size(),
                             _paraSpline.size());

    TFile file(path, "RECREATE");
    TTree tree("lineshape", "");

    float mppi;
    std::map<TString, float> branch_values;
    tree.Branch("mppi", &mppi, "mppi/F");
    for (size_t i = 0; i < nLz; i++) {
        TString name = resonance_names[i];

        TString KM_re_name = name + "_KM_real";
        branch_values[KM_re_name] = 0.;
        tree.Branch(KM_re_name, &branch_values[KM_re_name], KM_re_name + "/F");

        TString KM_im_name = name + "_KM_imag";
        branch_values[KM_im_name] = 0.;
        tree.Branch(KM_im_name, &branch_values[KM_im_name], KM_im_name + "/F");

        TString BW_re_name = name + "_BW_real";
        branch_values[BW_re_name] = 0.;
        tree.Branch(BW_re_name, &branch_values[BW_re_name], BW_re_name + "/F");

        TString BW_im_name = name + "_BW_imag";
        branch_values[BW_im_name] = 0.;
        tree.Branch(BW_im_name, &branch_values[BW_im_name], BW_im_name + "/F");
    }

    for (size_t i = 0; i < n_points; i++) {
        mppi = h_mppi[i];
        for (size_t iLz = 0; iLz < nLz; iLz++) {
            TString name = resonance_names[iLz];
            size_t index = iLz * n_points + i;

            branch_values[name + "_KM_real"] = h_KM_real[index];
            branch_values[name + "_KM_imag"] = h_KM_imag[index];
            branch_values[name + "_BW_real"] = h_BW_real[index];
            branch_values[name + "_BW_imag"] = h_BW_imag[index];
        }
        tree.Fill();
    }

    tree.Write();
    file.Write();
    file.Close();

    free(h_paraList);
    free(h_amp2s);
}

void RooDalitzAmplitude::storeAmp2s(const TString path) const {
    CalCoupling();
    CalAmp2s();
    writeAmp2sToFile(path);
}

void RooDalitzAmplitude::writeAmp2sToFile(const TString path) const {
    double amp2s = 0.;
    auto *outFile = TFile::Open(path, "RECREATE");
    auto *outTree = new TTree("tree", "Per event amp2s");
    // Use amp2 to be consistent with RooDalitzAmplitude::storeResonanceWeights
    outTree->Branch("amp2", &amp2s, "amp2/D");

    for (size_t i = 0; i < _perEventAmp2.size(); i++) {
        amp2s = _perEventAmp2[i];
        outTree->Fill();
    }
    outTree->Write();
    outFile->Close();
    delete outFile;
}

void RooDalitzAmplitude::storeResonanceWeights(const TString dataPath, const TString mcPath) const {

    auto getUniqueJP = [this](unsigned int offset, unsigned int Nresonances) {
        std::vector<int> list_S2;
        std::vector<int> list_Parity;
        for (unsigned int i = 0; i < Nresonances; i++) {
            unsigned int ir = i + offset;
            int S2(this->_paraList[ir * nset + SPIN]);
            int Parity(this->_paraList[ir * nset + PARITY]);

            bool unique = true;
            for (size_t j = 0; j < list_S2.size(); j++) {
                if (list_S2[j] == S2 && list_Parity[j] == Parity) {
                    unique = false;
                    break;
                }
            }

            if (unique) {
                list_S2.push_back(S2);
                list_Parity.push_back(Parity);
            }
        }

        return std::move(std::make_pair(list_S2, list_Parity));
    };

    // Get list of unique JP assignments to each type of resonance
    const auto Lz_S2Parity = getUniqueJP(0, NR);
    const auto &Lz_S2 = Lz_S2Parity.first;
    const auto &Lz_Parity = Lz_S2Parity.second;

    const auto Pc_S2Parity = getUniqueJP(NR, NZ);
    const auto &Pc_S2 = Pc_S2Parity.first;
    const auto &Pc_Parity = Pc_S2Parity.second;

    const auto Zcs_S2Parity = getUniqueJP(NR + NZ, NX);
    const auto &Zcs_S2 = Zcs_S2Parity.first;
    const auto &Zcs_Parity = Zcs_S2Parity.second;

    // Empty indices for turning off all resonances of single type
    std::vector<int> empty_indices;

    // Get all indices for each resonance type
    std::vector<int> all_Lz_indices(NR);
    std::vector<int> all_Pc_indices(NZ);
    std::vector<int> all_Zcs_indices(NX);
    std::iota(all_Lz_indices.begin(), all_Lz_indices.end(), 0);
    std::iota(all_Pc_indices.begin(), all_Pc_indices.end(), 0);
    std::iota(all_Zcs_indices.begin(), all_Zcs_indices.end(), 0);

    // Fill maps of branch name : indices to use
    struct resonance_indices {
        std::vector<int> Lz;
        std::vector<int> Pc;
        std::vector<int> Zcs;
    };

    std::map<TString, resonance_indices> indices_map;
    indices_map["amp2"] = {all_Lz_indices, all_Pc_indices, all_Zcs_indices};
    indices_map["allLz"] = {all_Lz_indices, empty_indices, empty_indices};
    indices_map["allPc"] = {empty_indices, all_Pc_indices, empty_indices};
    indices_map["allZcs"] = {empty_indices, empty_indices, all_Zcs_indices};

    // Define indices for resonances grouped by JP
    for (int j = 0; j < Lz_S2.size(); j++) {
        int group_S2 = Lz_S2[j];
        int group_Parity = Lz_Parity[j];

        std::vector<int> Lz_indices;
        for (int i = 0; i < NR; i++) {
            int ir = i;
            int S2(_paraList[ir * nset + SPIN]);
            int Parity(_paraList[ir * nset + PARITY]);
            if (S2 == group_S2 && Parity == group_Parity) {
                Lz_indices.push_back(i);
            }
        }
        TString parity_string = group_Parity > 0 ? "p" : "m";
        TString branchname = "LZ_JP_" + TString::Itoa(group_S2, 10) + parity_string;

        indices_map[branchname] = {Lz_indices, empty_indices, empty_indices};
    }

    // For Lambda* with J > 3/2
    std::vector<int> Lz_highJ_indices;
    for (int i = 0; i < NR; i++) {
        int ir = i;
        int S2(_paraList[ir * nset + SPIN]);
        if (S2 > 3) {
            Lz_highJ_indices.push_back(i);
        }
        indices_map["LZ_high_J"] = {Lz_highJ_indices, empty_indices, empty_indices};
    }

    for (int j = 0; j < Pc_S2.size(); j++) {
        int group_S2 = Pc_S2[j];
        int group_Parity = Pc_Parity[j];

        std::vector<int> Pc_indices;
        for (int i = 0; i < NZ; i++) {
            int ir = i + NR;
            int S2(_paraList[ir * nset + SPIN]);
            int Parity(_paraList[ir * nset + PARITY]);
            if (S2 == group_S2 && Parity == group_Parity) {
                Pc_indices.push_back(i);
            }
        }
        TString parity_string = group_Parity > 0 ? "p" : "m";
        TString branchname = "Pc_JP_" + TString::Itoa(group_S2, 10) + parity_string;
        TString Lz_interference_branchname = "allLz_" + branchname;

        indices_map[branchname] = {empty_indices, Pc_indices, empty_indices};
        indices_map[Lz_interference_branchname] = {all_Lz_indices, Pc_indices, empty_indices};
    }

    for (int j = 0; j < Zcs_S2.size(); j++) {
        int group_S2 = Zcs_S2[j];
        int group_Parity = Zcs_Parity[j];

        std::vector<int> Zcs_indices;
        for (int i = 0; i < NX; i++) {
            int ir = i + NR + NZ;
            int S2(_paraList[ir * nset + SPIN]);
            int Parity(_paraList[ir * nset + PARITY]);
            if (S2 == group_S2 && Parity == group_Parity) {
                Zcs_indices.push_back(i);
            }
        }
        TString parity_string = group_Parity > 0 ? "p" : "m";
        TString branchname = "Zcs_JP_" + TString::Itoa(group_S2, 10) + parity_string;

        indices_map[branchname] = {empty_indices, empty_indices, Zcs_indices};
    }

    const std::regex Ls_pattern("L_([0-9]+)");
    const std::regex Pc_pattern("L_(Z[0-9]*)");
    const std::regex Zcs_pattern("L_(X[a-zA-Z0-9]*)");

    // Lz components
    for (int i = 0; i < NR; i++) {
        const auto ir = i;
        const int type(_paraList[ir * nset + TYPE]);
        if (type != BREITWIGNER && type != KMATRIX && type != REVISEDKMATRIX)
            continue;

        const auto mass = _paraList[ir * nset + MASS];
        if (mass < 0)
            continue;

        const auto *_thisResList = dynamic_cast<RooArgList *>(_resList->At(i));
        std::cmatch match;
        std::regex_match(_thisResList->GetName(), match, Ls_pattern);

        std::vector<int> Ls_indices = {i};
        TString branchname = "Ls_" + TString(match[1].first);

        indices_map[branchname] = {Ls_indices, empty_indices, empty_indices};
    }

    // Non-resonant pK components
    for (int i = 0; i < NR; i++) {
        const auto ir = i;
        const int type(_paraList[ir * nset + TYPE]);
        if (type != NONRESONANT)
            continue;

        std::vector<int> Ls_indices = {i};
        const auto *_thisResList = dynamic_cast<RooArgList *>(_resList->At(i));
        TString branchname = _thisResList->GetName();

        indices_map[branchname] = {Ls_indices, empty_indices, empty_indices};
    }

    // Pc components
    std::map<TString, TString> Pc_names = {{"Z", "Pc_4457"},
                                           {"Z4", "Pc_4312"},
                                           {"Z5", "Pc_4440"},
                                           {"Z2", "Pc_4500"},
                                           {"Z6", "Pc_4385"}};

    for (int i = 0; i < NZ; i++) {
        auto ir = i + NR;
        const int type(_paraList[ir * nset + TYPE]);
        if (type != BREITWIGNER && type != KMATRIX && type != REVISEDKMATRIX)
            continue;

        const auto mass = _paraList[ir * nset + MASS];
        if (mass < 0)
            continue;

        const auto *_thisResList = dynamic_cast<RooArgList *>(_resListZ->At(i));
        std::cmatch match;
        std::regex_match(_thisResList->GetName(), match, Pc_pattern);

        TString Pc_key = match[1].first;
        std::vector<int> Pc_indices = {i};
        TString branchname = (Pc_names.find(Pc_key) != Pc_names.end())
                                 ? Pc_names[Pc_key]
                                 : "Pc_" + TString(match[1].first);

        indices_map[branchname] = {empty_indices, Pc_indices, empty_indices};
    }

    // Non-resonant Jpsip components
    for (int i = 0; i < NZ; i++) {
        auto ir = i + NR;
        const int type(_paraList[ir * nset + TYPE]);
        if (type != NONRESONANT)
            continue;

        std::vector<int> Pc_indices = {i};
        const auto *_thisResList = dynamic_cast<RooArgList *>(_resListZ->At(i));
        TString branchname = _thisResList->GetName();

        indices_map[branchname] = {empty_indices, Pc_indices, empty_indices};
    }

    // Resonant Zcs components
    for (int i = 0; i < NX; i++) {
        auto ir = i + NR + NZ;
        const int type(_paraList[ir * nset + TYPE]);
        if (type != BREITWIGNER && type != KMATRIX && type != REVISEDKMATRIX)
            continue;

        const auto mass = _paraList[ir * nset + MASS];
        if (mass < 0)
            continue;

        const auto *_thisResList = dynamic_cast<RooArgList *>(_resListX->At(i));
        std::cmatch match;
        std::regex_match(_thisResList->GetName(), match, Zcs_pattern);

        std::vector<int> Zcs_indices = {i};
        TString branchname = "Zcs_" + TString(match[1].first);

        indices_map[branchname] = {empty_indices, empty_indices, Zcs_indices};
    }

    // Calculate the per-event weights for data and MC
    size_t nData = _Nda;
    size_t nMC = _Nmc;

    std::map<TString, double> branch_values;
    double weight;
    std::map<TString, std::vector<double>> data_amp2;
    std::map<TString, std::vector<double>> MC_amp2_weight;

    for (auto &entry : indices_map) {
        const auto &branchname = entry.first;
        const auto &indices = entry.second;

        SetupCoupling(indices.Lz, indices.Pc, indices.Zcs);
        IntegralMethod2(true);

        data_amp2[branchname] =
            std::vector<double>(_perEventAmp2.begin(), _perEventAmp2.begin() + nData);
        MC_amp2_weight[branchname] =
            std::vector<double>(_perEventAmp2.begin() + nData, _perEventAmp2.begin() + nData + nMC);

        branch_values[branchname] = 0.; // initialize map for writing TTree
    }

    // Fill data per-event amp2
    auto *dataFile = TFile::Open(dataPath, "RECREATE");
    dataFile->cd();
    auto *dataTree = new TTree("tree", "Per event amp2 per resonance group of data");
    dataTree->Branch("weight", &weight, "weight/D");

    for (auto &entry : branch_values) {
        dataTree->Branch(entry.first, &(entry.second), entry.first + "/D");
    }
    for (int i = 0; i < nData; i++) {
        for (const auto &entry : data_amp2) {
            const TString &branchname = entry.first;
            const std::vector<double> &values = entry.second;
            branch_values[branchname] = values[i];
        }
        weight = _sw[i];
        dataTree->Fill();
    }
    dataTree->Write();
    dataFile->Close();

    // Fill MC per-event amp2 * weight
    auto *mcFile = TFile::Open(mcPath, "RECREATE");
    mcFile->cd();
    auto *mcTree = new TTree("tree", "Per event amp2weight per resonance group of MC");
    mcTree->Branch("weight", &weight, "weight/D");

    for (auto &entry : branch_values) {
        // Rename amp2 to amp2_weight since weight is multiplied to per-event amp2 for MC
        TString branchname = (entry.first == "amp2") ? "amp2_weight" : entry.first;
        mcTree->Branch(branchname, &(entry.second), branchname + "/D");
    }
    for (int i = 0; i < nMC; i++) {
        for (const auto &entry : MC_amp2_weight) {
            const TString &branchname = entry.first;
            const std::vector<double> &values = entry.second;
            branch_values[branchname] = values[i];
        }
        weight = PDLZ->at(nData + i)->w;
        mcTree->Fill();
    }
    mcTree->Write();
    mcFile->Close();
}

void RooDalitzAmplitude::genToy(const TString mcdata,
                                const char *name,
                                bool verbose,
                                bool smear,
                                bool allvar,
                                bool fortoystudy) const {

    CalCoupling();
    char cname[20];
    char swname[20];
    sprintf(cname, "h1");
    if (fortoystudy) {
        sprintf(cname, "tree");
    }
    sprintf(swname, "sw");
    int mcflat(0);
    if (mcdata.Contains("MCFlatAcc")) {
        sprintf(cname, "MyTuple");
        sprintf(swname, "nsig_sw");
        mcflat = 1;
    }
    if (mcdata.Contains("Toy")) {
        sprintf(cname, "MyTuple");
        sprintf(swname, "nsig_sw");
    }

    TChain *smcdata = new TChain(cname);
    smcdata->Add(mcdata);

    double costheta, costheta1, costheta2, phi1, phi2;
    double mppi, sw, mjpsip, mass;
    double phiZ;
    double phiMu;
    double phiPsi;
    double alphaMu;
    double costhetaB;
    double costhetaPsi;
    double costhetaZ;
    double costhetap;
    double mjpsipi;
    double eff;

    double X_cosTheta_Lb;
    double X_phiX;
    double X_cosTheta_X;
    double X_phiJpsi;
    double X_cosTheta_Jpsi;
    double X_phiMu;
    double X_cosTheta_p;
    double X_alpha_Mu;

    if (MYXN == 0) {
        mjpsipi = 4.4;
        X_cosTheta_Lb = 0.;
        X_phiX = 0.;
        X_cosTheta_X = 0.;
        X_phiJpsi = 0.;
        X_cosTheta_Jpsi = 0.;
        X_phiMu = 0.;
        X_cosTheta_p = 0.;
        X_alpha_Mu = 0.;
    }

    smcdata->SetBranchAddress("mass", &mass);
    if (fortoystudy)
        smcdata->SetBranchAddress("eff", &eff);
    smcdata->SetBranchAddress("mppi", &mppi);
    smcdata->SetBranchAddress("mjpsip", &mjpsip);
    smcdata->SetBranchAddress("cosTheta_Lb", &costheta);
    smcdata->SetBranchAddress("cosTheta_L", &costheta1);
    smcdata->SetBranchAddress("cosTheta_Jpsi", &costheta2);
    smcdata->SetBranchAddress("phipi", &phi1);
    smcdata->SetBranchAddress("phiMu", &phi2);

    smcdata->SetBranchAddress("Z_cosTheta_Lb", &costhetaB);
    smcdata->SetBranchAddress("Z_cosTheta_Z", &costhetaZ);
    smcdata->SetBranchAddress("Z_cosTheta_Jpsi", &costhetaPsi);
    smcdata->SetBranchAddress("Z_phiZ", &phiZ);
    smcdata->SetBranchAddress("Z_phiJpsi", &phiPsi);
    smcdata->SetBranchAddress("Z_phiMu", &phiMu);
    smcdata->SetBranchAddress("cosTheta_p", &costhetap);
    smcdata->SetBranchAddress("alpha_Mu", &alphaMu);
    smcdata->SetBranchAddress(swname, &sw);

    if (MYXN != 0) {
        smcdata->SetBranchAddress("mjpsipi", &mjpsipi);
        smcdata->SetBranchAddress("X_cosTheta_Lb", &X_cosTheta_Lb);
        smcdata->SetBranchAddress("X_cosTheta_X", &X_cosTheta_X);
        smcdata->SetBranchAddress("X_cosTheta_Jpsi", &X_cosTheta_Jpsi);
        smcdata->SetBranchAddress("X_phiX", &X_phiX);
        smcdata->SetBranchAddress("X_phiJpsi", &X_phiJpsi);
        smcdata->SetBranchAddress("X_phiMu", &X_phiMu);
        smcdata->SetBranchAddress("X_cosTheta_p", &X_cosTheta_p);
        smcdata->SetBranchAddress("X_alpha_Mu", &X_alpha_Mu);
    }

    int smcnum = smcdata->GetEntries();
    //  if(mcflat==1) smcnum = 100000; //wmz debug
    if (mcflat == 1)
        smcnum = 1000000;

    TFile *file = new TFile(TString::Format("toy/%s.root", name).Data(), "recreate");
    TTree *tree = new TTree("tree", "toy");

    double w;
    double wl[Constant::number_of_Lz + 1];
    double wz[Constant::number_of_Pc + 1];
    double wx[Constant::number_of_Zcs + 1];

    if (fortoystudy)
        tree->Branch("eff", &eff, "eff/D");
    tree->Branch("sw_old", &sw, "sw_old/D");
    tree->Branch("mass", &mass, "mass/D");
    tree->Branch("mppi", &mppi, "mppi/D");
    tree->Branch("mjpsip", &mjpsip, "mjpsip/D");
    if (MYXN != 0) {
        tree->Branch("mjpsipi", &mjpsipi, "mjpsipi/D");
        tree->Branch("X_cosTheta_X", &X_cosTheta_X, "X_cosTheta_X/D");
    }
    tree->Branch("cosTheta_L", &costheta1, "cosTheta_L/D");
    tree->Branch("Z_cosTheta_Z", &costhetaZ, "Z_cosTheta_Z/D");
    if (allvar) {
        tree->Branch("sw_old", &sw, "sw_old/D");
        tree->Branch("cosTheta_Lb", &costheta, "cosTheta_Lb/D");
        tree->Branch("cosTheta_Jpsi", &costheta2, "cosTheta_Jpsi/D");
        tree->Branch("phipi", &phi1, "phipi/D");
        tree->Branch("phiMu", &phi2, "phiMu/D");
        tree->Branch("Z_cosTheta_Lb", &costhetaB, "Z_cosTheta_Lb/D");
        tree->Branch("Z_cosTheta_Jpsi", &costhetaPsi, "Z_cosTheta_Jpsi/D");
        tree->Branch("Z_phiZ", &phiZ, "Z_phiZ/D");
        tree->Branch("Z_phiJpsi", &phiPsi, "Z_phiJpsi/D");
        tree->Branch("Z_phiMu", &phiMu, "Z_phiMu/D");
        tree->Branch("cosTheta_p", &costhetap, "cosTheta_p/D");
        tree->Branch("alpha_Mu", &alphaMu, "alpha_Mu/D");
        if (MYXN != 0) {
            tree->Branch("X_cosTheta_Lb", &X_cosTheta_Lb, "X_cosTheta_Lb/D");
            tree->Branch("X_cosTheta_Jpsi", &X_cosTheta_Jpsi, "X_cosTheta_Jpsi/D");
            tree->Branch("X_phiX", &X_phiX, "X_phiX/D");
            tree->Branch("X_phiMu", &X_phiMu, "X_phiMu/D");
            tree->Branch("X_phiJpsi", &X_phiJpsi, "X_phiJpsi/D");
            tree->Branch("X_alpha_Mu", &X_alpha_Mu, "X_alpha_Mu/D");
            tree->Branch("X_cosTheta_p", &X_cosTheta_p, "X_cosTheta_p/D");
        }
    }
    tree->Branch("w", &w, "w/D");
    tree->Branch("wL", &wl[0], "wL/D");
    tree->Branch("wZ", &wz[0], "wZ/D");
    tree->Branch("wX", &wx[0], "wX/D");
    TString lwvname[] = {"S01", "P01", "P03", "D03", "D05", "F05", "F07", "G07", "G09", "H09"};
    TString Zwvname[] = {"S01", "P01", "S03", "P03", "P05", "D05"};
    int nlwv[] = {1, 2, 4, 5, 7, 8, 10, 11, 13, 14};
    int nZwv[] = {2, 3, 6, 7, 11, 12};
    TString Lstname[] = {"1405",
                         "1520",
                         "1600",
                         "1670",
                         "1690",
                         "1800",
                         "1810",
                         "1820",
                         "1830",
                         "1890",
                         "2100",
                         "2110",
                         "2350",
                         "2585",
                         "1710",
                         "2000",
                         "2020",
                         "2050"};
    int nLst[] = {1405,
                  1520,
                  1600,
                  1670,
                  1690,
                  1800,
                  1810,
                  1820,
                  1830,
                  1890,
                  2100,
                  2110,
                  2350,
                  2585,
                  1710,
                  2000,
                  2020,
                  2050};
    double wlwv[20];
    double wZwv[20];
    double wLst[40];
    for (int ii = 0; ii < NZ; ++ii) {
        if (!(TString((_resListZ->At(ii))->GetName())).Contains("SC"))
            tree->Branch(TString("w") + TString((_resListZ->At(ii))->GetName()),
                         &wz[ii + 1],
                         TString("w") + TString((_resListZ->At(ii))->GetName()) + TString("/D"));
    }
    for (int ii = 0; ii < NX; ++ii)
        tree->Branch(TString("w") + TString((_resListX->At(ii))->GetName()),
                     &wx[ii + 1],
                     TString("w") + TString((_resListX->At(ii))->GetName()) + TString("/D"));
    for (int ii = 0; ii < 6; ++ii)
        tree->Branch(TString("wPWZ") + Zwvname[ii],
                     &wZwv[ii],
                     TString("wPWZ") + Zwvname[ii] + TString("/D"));
    if (verbose) {

        for (int ii = 0; ii < 10; ++ii)
            tree->Branch(TString("wPW") + lwvname[ii],
                         &wlwv[ii],
                         TString("wPW") + lwvname[ii] + TString("/D"));
        //  for(int ii=0; ii<NR; ++ii)
        //      tree->Branch(TString("wLst")+Lstname[ii], &wLst[ii],
        //      TString("wLst")+Lstname[ii]+TString("/D"));

        //    for(int ii=0; ii<NR; ++ii)
        //      tree->Branch(TString("w")+TString((_resList->At(ii))->GetName()), &wl[ii+1],
        //      TString("w")+TString((_resList->At(ii))->GetName())+TString("/D"));
    }

    //  float inte(0.);
    int i(0);
    //  smcnum=100000;
    clock_t start, end;
    start = clock();

    for (int imc = 0; imc < smcnum; imc++) {
        smcdata->GetEntry(imc);
        if (imc % 10000 == 0) {
            std::cout << imc << "/" << smcnum << std::endl;
        }

        if (!kine_limits(mppi))
            continue;
        if (!kine_limitsZ(mjpsip))
            continue;
        if (!kine_limitsX(mjpsipi))
            continue;
        //    Jpsihh_dlz *xdlz = new Jpsihh_dlz();

        Jpsihh_dlz &p = *(*PDLZ)[i + _Nda];

        //    filldlz(p, mppi, costheta, costheta1, costheta2, phi1, phi2, phi);
        float val;
        if (smear) {
            //      if (mjpsip > 4.2 && mjpsip < 4.6)
            //      {
            // //        val = GetAmp2sSMR(p);
            //                                 if ( mjpsip < 4.43 || mjpsip > 4.47 )
            //                                 {
            //                                         val = GetAmp2sSMR(p);
            //                                 }
            //                                 else
            //                                 {
            //                                         val = GetAmp2sSMR(p, NULL, false, true);
            //                                 }
            //       }
            if ((mjpsip > 4.4 && mjpsip < 4.48) || (mjpsip > 4.27 && mjpsip < 4.34)) {
                val = GetAmp2sSMR_badbinning(p);
            } else {
                val = GetAmp2s(p);
            }
        } else {
            val = GetAmp2s(p);
        }

        double sweight = (double)p.w;
        w = val * sweight;
        //    w = val;
        // calculcate each wi
        wl[0] = GetAmp2sForInt(p, -1, 1) * sweight;
        if (mjpsip > 4.2 && mjpsip < 4.6) {
            if (smear) {
                if (mppi > 1.9 && mjpsip > 4.43 && mjpsip < 4.47) {
                    wz[0] = GetAmp2sForInt_SMR(p, -1, 2, NULL, false, true) * sweight;
                } else
                    wz[0] = GetAmp2sForInt_SMR(p, -1, 2) * sweight;
            } else {
                wz[0] = GetAmp2sForInt(p, -1, 2) * sweight;
            }
        } else {
            wz[0] = GetAmp2sForInt(p, -1, 2) * sweight;
        }
        wx[0] = GetAmp2sForInt(p, -1, 10) * sweight;

        for (int ii = 0; ii < NZ; ++ii) {
            if (!(TString((_resListZ->At(ii))->GetName())).Contains("SC"))
                if (mjpsip > 4.2 && mjpsip < 4.6) {
                    if (smear) {
                        if (mppi > 1.9 && mjpsip > 4.43 && mjpsip < 4.47)
                            wz[ii + 1] =
                                GetAmp2sForInt_SMR(p, ii + NR, 0, NULL, false, true) * sweight;
                        else
                            wz[ii + 1] = GetAmp2sForInt_SMR(p, ii + NR) * sweight;
                    } else {
                        wz[ii + 1] = GetAmp2sForInt(p, ii + NR) * sweight;
                    }
                } else {
                    wz[ii + 1] = GetAmp2sForInt(p, ii + NR) * sweight;
                }
        }
        for (int ii = 0; ii < NX; ++ii)
            wx[ii + 1] = GetAmp2sForInt(p, ii + NR + NZ) * sweight;
        for (int ii = 0; ii < 6; ++ii)
            if (mjpsip > 4.2 && mjpsip < 4.6) {
                if (smear) {
                    if (mppi > 1.9 && mjpsip > 4.43 && mjpsip < 4.47)
                        wZwv[ii] = GetAmp2sForInt_SMR(p, nZwv[ii], 5, NULL, false, true) * sweight;
                    else
                        wZwv[ii] = GetAmp2sForInt_SMR(p, nZwv[ii], 5) * sweight;
                } else {
                    wZwv[ii] = GetAmp2sForInt(p, nZwv[ii], 5) * sweight;
                }
            } else {
                wZwv[ii] = GetAmp2sForInt(p, nZwv[ii], 5) * sweight;
            }
        if (verbose) {
            for (int ii = 0; ii < 10; ++ii)
                wlwv[ii] = GetAmp2sForInt(p, nlwv[ii], 3) * sweight;
            //    for(int ii=0; ii<18; ++ii)
            //      wLst[ii] = GetAmp2sForInt(p,nLst[ii],4) * sweight;
            //    for(int ii=0; ii<NR; ++ii)
            //      wl[ii+1] = GetAmp2sForInt(p,ii) * sweight;
        }
        tree->Fill();
        i++;
    }
    end = clock();
    std::cout << "toy generation time :" << (double)(end - start) / CLOCKS_PER_SEC << "S"
              << std::endl;

    tree->Write();
    file->Close();
    smcdata->Delete();
}

void RooDalitzAmplitude::genToyNoACC(const char *name) const {
    //  char filename[100];
    //  sprintf("toy%s.root",name);

    /*  TFile *file = new TFile(TString::Format("toynoacc%s.root",name).Data(),"recreate");
    TTree *tree = new TTree("tree","toy");
    float costheta, costheta1,costheta2,phi1,phi2,phi;
    float mppi,sw,w;
    float mjpsip;
    tree->Branch("mppi", &mppi, "mppi/D");
  //  tree->Branch("mjpsip", &mjpsip, "mjpsip/D");
    tree->Branch("costheta", &costheta, "costheta/D");
    tree->Branch("costheta1", &costheta1, "costheta1/D");
    tree->Branch("costheta2", &costheta2, "costheta2/D");
  //  tree->Branch("phi", &phi, "phi/D");
    tree->Branch("phi1", &phi1, "phi1/D");
    tree->Branch("phi2", &phi2, "phi2/D");
    tree->Branch("w", &w, "w/D");



    float vrnd[6];
    float mmin = m_pi+m_p;
    float mmax = m_lb-m_jpsi;

    for(int i=0; i<1e6; ++i) {
      if(i%100000==0) std::cout <<"Generate .... " << i << std::endl;
      RooRandom::uniform(6, vrnd);
      //   if(!kine_limits(mppi)) return 0.0;
      costheta = (1.+1.)*vrnd[0]-1.;
      costheta1 = (1.+1.)*vrnd[1]-1.;
      costheta2 = (1.+1.)*vrnd[2]-1.;
      phi1 = ((1.+1.)*vrnd[3]-1.)*TMath::Pi();
      phi2 = ((1.+1.)*vrnd[4]-1.)*TMath::Pi();
  //    phi =  ((1.+1.)*vrnd[5]-1.)*TMath::Pi();
      mppi = (mmax-mmin)*vrnd[5]+mmin;
      Jpsihh_dlz *xdlz = new Jpsihh_dlz();

      filldlz(*xdlz, mppi, costheta, costheta1, costheta2, phi1, phi2);
      w =  GetAmp2s(*xdlz)*getp(m_lb, m_jpsi, mppi)*getp(mppi, m_p, m_pi);
      tree->Fill();
      delete xdlz;
    }

    tree->Write();
    file->Close();
  */
    // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE
    //   return 1.0 ;
}

Int_t RooDalitzAmplitude::getAnalyticalIntegral(RooArgSet &allVars,
                                                RooArgSet &analVars,
                                                const char * /*rangeName*/) const {
    // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED,
    // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS
    // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
    // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs
    // EXPRESSION MULTIPLE TIMES

    // if (matchArgs(allVars,analVars,x)) return 1 ;
    std::cout << "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
    std::cout << "Requested integration over these variables: " << std::endl;
    allVars.Print("V");
    std::cout << "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl
              << std::endl;
    /*
        RooArgSet List;
        List.add();
        List.add();
        List.add();
        List.add();
        List.add();
        List.add();
        List.add();
     */
    if (matchArgs(allVars, analVars, _values))
        return 7;
    return 0;
}

void RooDalitzAmplitude::spline(double mpp, float &r_ampl, float &i_ampl) const {
    r_ampl = 0;
    i_ampl = 0;
    double asp = _sa3.Eval(mpp);
    double psp = _sp3.Eval(mpp);
    //  std::cout << "Spline called2" << mpp << " " << asp << " " << psp  << std::endl;
    r_ampl = (float)asp; // asp*cos(psp);
    i_ampl = (float)psp; // asp*sin(psp);
    return;
}

void RooDalitzAmplitude::MakeSpline(RooArgList ires) const {
    double x[NUMSP];
    double re[NUMSP], im[NUMSP];
    //  double a[NUMSP], ph[NUMSP];
    int nsp = NUMSP; // ires.getSize()/3-1;
    int noffset = 12;
    for (int i = 0; i < nsp; ++i) {
        x[i] = ((RooAbsReal &)ires[noffset + (i) * 3 + 2]).getVal();
        re[i] = ((RooAbsReal &)ires[noffset + (i) * 3]).getVal();
        im[i] = ((RooAbsReal &)ires[noffset + (i) * 3 + 1]).getVal();
        // if(i==0) std::cout << "Spline x0 " << x[i] << std::endl;
    }
    double xmin(m_pi + m_p - 0.002), xmax(m_lb - m_jpsi + 0.002);
    _sa3 = TSpline3("_sa3", x, re, nsp, "", xmin, xmax);
    _sp3 = TSpline3("_sp3", x, im, nsp, "", xmin, xmax);
}

void RooDalitzAmplitude::MakeSplineZ(RooArgList ires) const {
    double x[NUMSPZ];
    double re[NUMSPZ], im[NUMSPZ];
    int nsp = NUMSPZ; // ires.getSize()/3-1;
    int noffset = 8;
    for (int i = 0; i < nsp; ++i) {
        x[i] = ((RooAbsReal &)ires[noffset + (i) * 3 + 2]).getVal();
        re[i] = ((RooAbsReal &)ires[noffset + (i) * 3]).getVal();
        im[i] = ((RooAbsReal &)ires[noffset + (i) * 3 + 1]).getVal();
        //    if(i==0) std::cout << "Spline x0 " << x[i] << std::endl;
    }
    double xmin(m_jpsi + m_p - 0.002), xmax(4.6); // xmax(m_lb-m_pi+0.002);
    _sa3 = TSpline3("_sa3", x, re, nsp, "", xmin, xmax);
    _sp3 = TSpline3("_sp3", x, im, nsp, "", xmin, xmax);
}

// implemented from TSpline3
void RooDalitzAmplitude::ModelIndependentWave3(float *fPoly,
                                               float x,
                                               float &Rea,
                                               float &Ima) const {
    float sumre(0.0);
    float sumim(0.0);
    Rea = 0;
    Ima = 0;
    // ms  input mass i.e. m(J/psi p) in this case
    // Rea,Ima  real and imaginary parts of the amplitude

    // get binning and number of interpolation points

    const int fNp = NUMSP;

    if (fNp <= 0)
        return;

    float fXmin = m_p + m_pi - 0.002; // 1.513;//1.43;//((RooAbsReal&)res24[3]).getVal();
    float fXmax =
        m_lb - m_jpsi + 0.002; // 2.185;//4.416;//5.03;//2.53;//((RooAbsReal&)res24[4]).getVal();

    if (x < fXmin)
        return;
    if (x > fXmax)
        return;

    // The above is the spline interpolation of the magnitude (called sumamp), real and imaginary
    // parts.

    // spline3 from root
    int klow = 0, khig = fNp - 1;
    //
    // If out of boundaries, extrapolate
    // It may be badly wrong
    if (x <= fXmin)
        klow = 0;
    else if (x >= fXmax)
        klow = khig;
    else {
        int khalf;
        //
        // Non equidistant knots, binary search
        while (khig - klow > 1)
            if (x > fPoly[khalf = (klow + khig) / 2])
                klow = khalf;
            else
                khig = khalf;
        //
    }
    // this is the number to be used klow;
    //  Evaluate now
    float dx = x - fPoly[klow];
    int ist = 4 * klow + fNp;
    sumre = (fPoly[ist] + dx * (fPoly[ist + 1] + dx * (fPoly[ist + 2] + dx * fPoly[ist + 3])));
    ist = ist + 4 * fNp;
    sumim = (fPoly[ist] + dx * (fPoly[ist + 1] + dx * (fPoly[ist + 2] + dx * fPoly[ist + 3])));
    Rea = sumre;
    Ima = sumim;
    return;
}

// implemented from TSpline3 for Z
void RooDalitzAmplitude::ModelIndependentWave(float *fPoly, float x, float &Rea, float &Ima) const {
    float sumre(0.0);
    float sumim(0.0);
    Rea = 0;
    Ima = 0;
    // ms  input mass i.e. m(J/psi p) in this case
    // Rea,Ima  real and imaginary parts of the amplitude

    // get binning and number of interpolation points

    const int fNp = NUMSPZ;

    if (fNp <= 0)
        return;

    float fXmin = m_jpsi + m_p - 0.002; // 1.513;//1.43;//((RooAbsReal&)res24[3]).getVal();
    float fXmax =
        4.6; // m_lb-m_pi+0.002;//2.185;//4.416;//5.03;//2.53;//((RooAbsReal&)res24[4]).getVal();

    if (x < fXmin)
        return;
    if (x > fXmax)
        return;

    // The above is the spline interpolation of the magnitude (called sumamp), real and imaginary
    // parts.

    // spline3 from root
    int klow = 0, khig = fNp - 1;
    //
    // If out of boundaries, extrapolate
    // It may be badly wrong
    if (x <= fXmin)
        klow = 0;
    else if (x >= fXmax)
        klow = khig;
    else {
        int khalf;
        //
        // Non equidistant knots, binary search
        while (khig - klow > 1)
            if (x > fPoly[khalf = (klow + khig) / 2])
                klow = khalf;
            else
                khig = khalf;
        //
    }
    // this is the number to be used klow;
    //  Evaluate now
    float dx = x - fPoly[klow];
    int ist = 4 * klow + fNp;
    sumre = (fPoly[ist] + dx * (fPoly[ist + 1] + dx * (fPoly[ist + 2] + dx * fPoly[ist + 3])));
    ist = ist + 4 * fNp;
    sumim = (fPoly[ist] + dx * (fPoly[ist + 1] + dx * (fPoly[ist + 2] + dx * fPoly[ist + 3])));
    Rea = sumre;
    Ima = sumim;
    //  std::cout << "MIZ " << sqrt(Rea*Rea+Ima*Ima) << std::endl;
    return;
}

Double_t RooDalitzAmplitude::IntegralMethod2(bool storePerEventAmp2) const {
    //  nvtxRangePush("integral");

    int iEnd = _Nmc + _Nda; // smcdata->GetEntries();
    //  std::cout << "MC inte size " << iEnd << std::endl;
    double inte(0.);
    //  sumW = 0.;
    //  iEnd = 100;
    float wmz_data_inte = 0; // wmzwmz test
#ifdef CPU
    for (int i = 0; i < iEnd; i++) {
        // mppi>2GeV
        // if(mppi<2.0) continue;
        Jpsihh_dlz &p = *(*PDLZ)[i];
        double sweight = (double)p.w;
        float mjpsip = p.mjpsip;
        double val;
        // if(0){
        if (mjpsip > 4.2 && mjpsip < 4.6 && i < _Nda) {
            // changed for testing
            if (mjpsip < 4.43 || mjpsip > 4.47) {
                val = GetAmp2sSMR(p);
            } else {
                val = GetAmp2sSMR(p, NULL, false, true);
            }
            //                        std::cout << "wmz debug GetAmp2sSMR CPU [" << mjpsip << "," <<
            //                        p.mppi << "]  " << val << std::endl;
        } else {
            val = GetAmp2s(p);
            //                        std::cout << "wmz debug GetAmp2s CPU [" << mjpsip << "," <<
            //                        p.mppi << "]  " << val << std::endl;
        }
        // float val =  GetAmp2s(p);
        _fx[i] = val;
        //    std::cout << "mppi, pdf " << p.mppi << " " << val << std::endl;
        if (i >= _Nda)
            inte += val * sweight;
        else
            wmz_data_inte += val;
    }
#endif
    // gpu part//
#ifdef GPU
#ifdef DEBUGGPU
    clock_t start, end;
    start = clock();
#endif
    float *h_paraList;
    //  float *h_vamp;
    //  float *h_paraSpline;
    double *h_fx;
    cu_init_data(h_paraList, h_fx, iEnd);
    //  nvtxRangePush("host_store_fx");
    inte = host_store_fx(d_float_pp,
                         d_float_pp1,
                         d_float_pp2,
                         d_float_pp3,
                         d_float_pp4,
                         d_float_sw,
                         h_paraList,
                         _paraList.size(),
                         _vamp.size(),
                         _paraSpline.size(),
                         h_fx,
                         iEnd,
                         0,
                         _Nda,
                         _Nda_SMR1 - 1,
                         _Nda_SMR_finebinning,
                         NR,
                         NZ,
                         NX,
                         _mynll,
                         sumW,
                         sumW_data,
                         _FFR,
                         _FFB,
                         _smear_binning_scheme);
//  nvtxRangePop();
//  inte = 9356911.6972790919;
#if 0
  for (int i = 0; i < _Nda; i++)
  {
    //mppi>2GeV
    //if(mppi<2.0) continue;
    _fx[i] = h_fx[i];
//    wmz_data_inte += _fx[i]; //wmzwmz test
//                std::cout << "wmz debug _fx["<<i<<"] = " << _fx[i] << "; wmz_data_inte = " << wmz_data_inte << std::endl;
                 //    if(i==10) std::cout << "PDF " << h_fx[i] << " " << _vamp[0] << std::endl;
                 //    if(i%10000==0) std::cout << "PDF " << i << " " << h_fx[i] << " " << (*PDLZ)[i]->DL[0][0][1] << std::endl;
                 //    if(i<_Nmc) inte += _fx[i];//*((*PDLZ)[i]->w);
  }
#endif
    // free memory
    free(h_paraList);
    //  free(h_vamp);
    //  free(h_paraSpline);
    if (storePerEventAmp2) {
        _perEventAmp2.resize(iEnd, 0.);
        for (size_t i = 0; i < iEnd; i++) {
            _perEventAmp2[i] = h_fx[i];
        }
    }
    free(h_fx);
#ifdef DEBUGGPU
    end = clock();
    std::cout << "gpu part  time :" << (double)(end - start) / CLOCKS_PER_SEC << "S" << std::endl;
#endif
    return 1;
    //  std::cout << "Done GPU" << std::endl;
#endif

#ifdef CPU
    inte = inte / sumW;
    return inte;
#endif
}

Double_t RooDalitzAmplitude::IntegralMethod1() const {

    int smcnum = _Nmc;
    std::cout << "MC inte size " << smcnum << std::endl;
    double inte(0.);
    //  sumW = 0.;
    //  smcnum = 100;
    std::vector<Amp_dlz> vAmp; //[NR][2][2][2][6]
    for (int i = 0; i < smcnum; i++) {
        // mppi>2GeV
        // if(mppi<2.0) continue;

        Jpsihh_dlz &p = *(*PDLZ)[i + _Nda];
        double sweight = (double)p.w;
        Amp_dlz tnew;
        tnew.w = sweight;
        //    float val =  GetAmp2sSMR(p, &tnew, true);
        double val = GetAmp2s(p, &tnew, true);
        inte += val * sweight;
        vAmp.push_back(tnew);
    }
    inte = inte / sumW;
    //  std::cout.precision(10);
    std::cout << "Integration1, " << inte << std::endl;

    // sum over MC
    TComplex tctmp;
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                for (int ir1 = 0; ir1 < NR; ++ir1) {
                    for (int ir2 = 0; ir2 < NR; ++ir2) {
                        for (int m1 = 0; m1 < 6; ++m1) {
                            for (int m2 = 0; m2 < 6; ++m2) {
                                AA[i][j][k][ir1][ir2][m1][m2] = TComplex(0., 0.);
                            }
                        }
                    }
                }
            }
        }
    }

    /*
    std::vector<Amp_dlz> vAmp;//[NR][2][2][2][6]

    for(int imc=0; imc<smcnum; imc++) {
      Jpsihh_dlz &p = *(*PDLZ)[imc+_Nda];
      float sweight = p.w;
      TComplex tp;
      TComplex tpz;
      Amp_dlz tnew;
      tnew.w = sweight;
      for(int i=0;i<2; ++i) {
        for(int j=0; j<2; ++j) {
    for(int k=0; k<2; ++k) {
      for(int ir1=0; ir1<NR; ++ir1) {
        for(int m1=0; m1<6; ++m1) {
          tp = CalAmp(ir1,i,j,k,m1,p);//TComplex(p.ARe[ir1][i][j][k][m1],-p.AIm[ir1][i][j][k][m1]);
          tnew.ARe[ir1][i][j][k][m1] = tp.Re();
          tnew.AIm[ir1][i][j][k][m1] = tp.Im();

        }
      }
    }
        }
      }
     for(int i=0;i<2; ++i) {
       for(int j=0; j<2; ++j) {
         for(int k=0; k<2; ++k) {
     for(int ir1=0; ir1<NZ; ++ir1) {
       for(int m1=0; m1<12; ++m1) {
         tpz = (CalAmpZ(ir1,i,j,k,m1,p));
          tnew.AZRe[ir1][i][j][k][m1] = tpz.Re();
          tnew.AZIm[ir1][i][j][k][m1] = tpz.Im();
             }
           }
         }
       }
      }
      vAmp.push_back(tnew);
    }
    */
    for (int imc = 0; imc < smcnum; imc++) {
        Amp_dlz p = vAmp[imc];
        double sweight = (double)p.w;
        // if(mppi<2.0) continue;

        for (int i = 0; i < 2; ++i) {
            for (int j = 0; j < 2; ++j) {
                for (int k = 0; k < 2; ++k) {
                    for (int ir1 = 0; ir1 < NR; ++ir1) {
                        for (int m1 = 0; m1 < 6; ++m1) {
                            TComplex tp1 = TComplex((double)p.ARe[ir1][i][j][k][m1],
                                                    -(double)p.AIm[ir1][i][j][k][m1]);
                            for (int ir2 = 0; ir2 < NR; ++ir2) {
                                for (int m2 = 0; m2 < 6; ++m2) {
                                    TComplex tp2 = TComplex((double)p.ARe[ir2][i][j][k][m2],
                                                            (double)p.AIm[ir2][i][j][k][m2]);
                                    tctmp = tp1 * tp2;
                                    AA[i][j][k][ir1][ir2][m1][m2] += tctmp * sweight;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // sum over MC for Z
    //   TComplex tctmp;
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                for (int ir1 = 0; ir1 < NZ; ++ir1) {
                    for (int ir2 = 0; ir2 < NZ; ++ir2) {
                        for (int m1 = 0; m1 < 12; ++m1) {
                            for (int m2 = 0; m2 < 12; ++m2) {
                                AAZ[i][j][k][ir1][ir2][m1][m2] = TComplex(0., 0.);
                            }
                        }
                    }
                }
            }
        }
    }
    //  std::cout << "Step 1 " << std::endl;
    for (int imc = 0; imc < smcnum; imc++) {
        Amp_dlz p = vAmp[imc];
        double sweight = (double)p.w;
        // mppi>2GeV
        // if(mppi<2.0) continue;

        for (int i = 0; i < 2; ++i) {
            for (int j = 0; j < 2; ++j) {
                for (int k = 0; k < 2; ++k) {
                    for (int ir1 = 0; ir1 < NZ; ++ir1) {
                        for (int m1 = 0; m1 < 12; ++m1) {
                            TComplex tp1 = TComplex((double)p.AZRe[ir1][i][j][k][m1],
                                                    -(double)p.AZIm[ir1][i][j][k][m1]);
                            for (int ir2 = 0; ir2 < NZ; ++ir2) {
                                for (int m2 = 0; m2 < 12; ++m2) {
                                    TComplex tp2 = TComplex((double)p.AZRe[ir2][i][j][k][m2],
                                                            (double)p.AZIm[ir2][i][j][k][m2]);
                                    tctmp = tp1 * tp2;
                                    AAZ[i][j][k][ir1][ir2][m1][m2] += tctmp * sweight;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                for (int ir1 = 0; ir1 < NZ; ++ir1) {
                    for (int ir2 = 0; ir2 < NR; ++ir2) {
                        for (int m1 = 0; m1 < 12; ++m1) {
                            for (int m2 = 0; m2 < 6; ++m2) {
                                ABZ[i][j][k][ir1][ir2][m1][m2] = TComplex(0., 0.);
                            }
                        }
                    }
                }
            }
        }
    }
    //  std::cout << "Step 1 " << std::endl;
    for (int imc = 0; imc < smcnum; imc++) {
        Amp_dlz p = vAmp[imc];
        double sweight = (double)p.w;
        // mppi>2GeV
        // if(mppi<2.0) continue;

        for (int i = 0; i < 2; ++i) {
            for (int j = 0; j < 2; ++j) {
                for (int k = 0; k < 2; ++k) {
                    for (int ir1 = 0; ir1 < NZ; ++ir1) {
                        for (int m1 = 0; m1 < 12; ++m1) {
                            TComplex tp1 = TComplex((double)p.AZRe[ir1][i][j][k][m1],
                                                    -(double)p.AZIm[ir1][i][j][k][m1]);
                            for (int ir2 = 0; ir2 < NR; ++ir2) {
                                for (int m2 = 0; m2 < 6; ++m2) {
                                    TComplex tp2 = TComplex((double)p.ARe[ir2][i][j][k][m2],
                                                            (double)p.AIm[ir2][i][j][k][m2]);
                                    tctmp = tp1 * tp2;
                                    ABZ[i][j][k][ir1][ir2][m1][m2] += tctmp * sweight;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    std::cout << "Done 3" << std::endl;

#if 0
//delete pdlz
 if(pdlz) {
   std::vector<Jpsihh_dlz* >::iterator it;
   for(it = pdlz->begin(); it != pdlz->end(); ++it) {
     delete *it;
     //pdlz->erase(it);
   }
  pdlz->clear();
  std::cout << "cleared pdlz in integration" << std::endl;
 }
#endif
    // float inte = 1.0;
    return inte;
}

Double_t RooDalitzAmplitude::analyticalIntegral(Int_t code, const char *rangeName) const {

    // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
    // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
    // BOUNDARIES FOR EACH OBSERVABLE x

    // assert(code==1) ;
    // return (x.max(rangeName)-x.min(rangeName)) ;
    // default is 7; !=7 do not calcualte integral(), but update other parameters
    switch (code) {
    case 7:
        break;
    case 6:
        break;
    default:
        assert(0);
    }
    //  return 1.0;

    //  float costheta, costheta1,costheta2,phi1,phi2,phi;
    // float mppi,sw;
    // std::cout << "zhanglm Integral " << std::endl;
    // if parameters are updated, recache it.
    Double_t Inte = 1.00;
    //  nvtxRangePush("CalCoupling");
    CalCoupling();
    //  nvtxRangePop();

    // update cached resparam
#if 0 // not needed
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    float m0 = 0;
    float g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();

  /*  if((fabs(_resParCache[2*ir+0]-m0)>1e-20)
       || (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      //      ResetDef(ir);
//      _paraList[ir*nset+5] = 0;
    } else {
//      _paraList[ir*nset+5] = 1;
    }

    if(code==7) {
      _resParCache[2*ir+0] = m0;
      _resParCache[2*ir+1] = g0;
    }*/
    ir++;
  }

  delete coefIter;
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    float m0 = 0;
    float g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();

    if((fabs(_resParCache[2*ir+0]-m0)>1e-20)
       || (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      //      ResetDef(ir);
//      _paraList[ir*nset+5] = 0;
    } else {
//      _paraList[ir*nset+5] = 1;
    }
    if(code==7) {
      _resParCache[2*ir+0] = m0;
      _resParCache[2*ir+1] = g0;
    }
    ir++;
  }
  delete coefIterZ;
#endif

    if (code == 7)
        Inte = IntegralMethod2();
#if 0
  if(!_isPP) {
    if(checkchange())   {
      Inte = IntegralMethod1();
    } else {
      TComplex a1,a2;
      for(int i=0;i<=1; ++i) {//del
  for(int j=0; j<=1; ++j) { //hel0
    for(int k=0; k<=1; ++k) { //hel3 proton
      // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
      for(int ir1=0; ir1<NR;++ir1) {
        for(int m1=0; m1<6; ++m1) {
    a1 = TComplex::Conjugate(amp[ir1][k][m1]);
    if((a1.Rho2())<1e-10) continue;
    for(int ir2=0; ir2<NR;++ir2) {
      for(int m2=0; m2<6; ++m2) {
        a2 = amp[ir2][k][m2];
        Inte += (a1*a2* AA[i][j][k][ir1][ir2][m1][m2]).Re() ;
        //      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);

      }
    }
        }
      }
    }
  }
      }
      //  nres = NZ;

      for(int i=0;i<=1; ++i) {//del
  for(int j=0; j<=1; ++j) { //hel0
    for(int k=0; k<=1; ++k) { //hel3 proton
      // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
      for(int ir1=0; ir1<NZ;++ir1) {
        for(int m1=0; m1<12; ++m1) {
    a1 = TComplex::Conjugate(ampZ[ir1][k][m1]);
    if((a1.Rho2())<1e-10) continue;
    for(int ir2=0; ir2<NZ;++ir2) {
      for(int m2=0; m2<12; ++m2) {
        a2 = ampZ[ir2][k][m2];
        Inte += (a1*a2* AAZ[i][j][k][ir1][ir2][m1][m2]).Re() ;
        //      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);

      }
    }
                for(int ir2=0; ir2<NR;++ir2) {
                  for(int m2=0; m2<6; ++m2) {
                    a2 = amp[ir2][k][m2];
                    Inte += 2.*(a1*a2* ABZ[i][j][k][ir1][ir2][m1][m2]).Re() ;
                    //      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);

                  }
                }
        }
      }
    }
  }
      }

      //std::cout <<"sumW " << sumW <<std::endl;
      Inte = Inte/sumW;

    }
  }
  else {Inte = 1.0;  }
#endif
    //  std::cout.precision(10);
    //  std::cout << "Integration2, " << Inte << std::endl;

    return Inte;
}

#if 0
bool RooDalitzAmplitude::checkchange() const
{
  //update cached resparam
  int ir(NR);
  TIterator *coefIterZ = _resListZ->MakeIterator();
  while (RooArgList *Ires = (RooArgList *)coefIterZ->Next())
  {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    float m0 = 0;
    float g0 = 0;
    m0 = ((RooAbsReal &)ires[iressize - 5]).getVal();
    g0 = ((RooAbsReal &)ires[iressize - 4]).getVal();

    if ((fabs(_resParCache[2 * ir + 0] - m0) > 1e-20) || (fabs(_resParCache[2 * ir + 1] - g0) > 1e-20))
    {
      delete coefIterZ;
      return true;
    }
    ir++;
  }
  delete coefIterZ;

  ir = 0;
  TIterator *coefIter = _resList->MakeIterator();
  while (RooArgList *Ires = (RooArgList *)coefIter->Next())
  {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    float m0 = 0;
    float g0 = 0;
    m0 = ((RooAbsReal &)ires[iressize - 5]).getVal();
    g0 = ((RooAbsReal &)ires[iressize - 4]).getVal();

    if ((fabs(_resParCache[2 * ir + 0] - m0) > 1e-20) || (fabs(_resParCache[2 * ir + 1] - g0) > 1e-20))
    {
      delete coefIter;
      return true;
    }

    ir++;
  }

  delete coefIter;
  return false;
}
#endif

Int_t RooDalitzAmplitude::getGenerator(const RooArgSet &directVars,
                                       RooArgSet &generateVars,
                                       Bool_t /*staticInitOK*/) const {
    // LIST HERE OVER WHICH VARIABLES INTERNAL GENERATION IS SUPPORTED,
    // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS
    // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
    // YOU CAN ALSO IMPLEMENT MORE THAN ONE GENERATOR CONFIGURATION BY REPEATING THE matchArgs
    // EXPRESSION MULTIPLE TIMES. IF THE FLAG staticInitOK IS TRUE THEN IT IS SAFE TO PRECALCULATE
    // INTERMEDIATE QUANTITIES IN initGenerator(), IF IT IS NOT SET THEN YOU SHOULD NOT ADVERTISE
    // ANY GENERATOR METHOD THAT RELIES ON PRECALCULATIONS IN initGenerator()

    // if (matchArgs(directVars,generateVars,x)) return 1 ;
    return 0;
}

void RooDalitzAmplitude::generateEvent(Int_t code) {
    // GENERATE SET OF OBSERVABLES DEFINED BY RETURN CODE ASSIGNED BY getGenerator()
    // RETURN THE GENERATED VALUES BY ASSIGNING THEM TO THE PROXY DATA MEMBERS THAT
    // REPRESENT THE CHOSEN OBSERVABLES

    // assert(code==1) ;
    // x = 0 ;
    return;
}

inline Double_t dfunhalf(Double_t beta, Int_t am, Int_t an) {
    // d1/2_{1/2,1/2}=d1/2_{-1/2,-1/2}=cos(theta/2);
    // d1/2_{1/2,-1/2}=-sin(theta/2)=-d1/2{-1/2,1/2};
    // std::cout << " am an " << am << " " << an << std::endl;
    if ((am == 1 && an == 1) || (am == -1 && an == -1))
        return TMath::Cos(0.5 * beta);
    if (am == 1 && an == -1)
        return -TMath::Sin(0.5 * beta);
    if (am == -1 && an == 1)
        return TMath::Sin(0.5 * beta);
    std::cout << "dfunhalf why " << am << " " << an << std::endl;
    return 0.0;
}

inline Double_t dfunone(Double_t beta, Int_t am, Int_t an) {
    if ((am == 1 && an == 1) || (am == -1 && an == -1))
        return (TMath::Cos(beta) + 1.0) / 2.;
    if ((am == 1 && an == -1) || (am == -1 && an == 1))
        return (-TMath::Cos(beta) + 1.0) / 2.;
    if (am == 0 && an == 1)
        return TMath::Sin(beta) * 7.07106781186547461715e-01;
    if (am == 0 && an == -1)
        return -TMath::Sin(beta) * 7.07106781186547461715e-01;
    if (am == 0 && an == 0)
        return TMath::Cos(beta);
    std::cout << "dfunone why " << am << " " << an << std::endl;
    return 0.0;
}

inline Double_t dfun(Double_t beta, Double_t aj, Double_t am, Double_t an) {
    // beta in rad;
    //  Calculates the beta-term
    //                          d j mn (beta)
    //  in the matrix element of the finite rotation operator
    //  (Wigner's D-function), according to formula 4.3.1(3) in
    //  D.A. Varshalovich, A.N. Moskalev, and V.K. Khersonskii,
    //  Quantum Theory of Angular Momentum, World Scientific,
    //  Singapore 1988.
    //  CERNLIB DDJMNB function translated from Fortran to C++ by Rene Brun

    Double_t pi = 3.141592653589793116;
    Double_t pi2 = 6.283185307179586232;
    //   Float_t beta = beta_rad;
    const Double_t f = 0.5; // 8.72664625997164788e-3;
    const Double_t fcl[51] = {0,
                              0,
                              6.93147180559945309e-1,
                              1.79175946922805500e00,
                              3.17805383034794562e00,
                              4.78749174278204599e00,
                              6.57925121201010100e00,
                              8.52516136106541430e00,
                              1.06046029027452502e01,
                              1.28018274800814696e01,
                              1.51044125730755153e01,
                              1.75023078458738858e01,
                              1.99872144956618861e01,
                              2.25521638531234229e01,
                              2.51912211827386815e01,
                              2.78992713838408916e01,
                              3.06718601060806728e01,
                              3.35050734501368889e01,
                              3.63954452080330536e01,
                              3.93398841871994940e01,
                              4.23356164607534850e01,
                              4.53801388984769080e01,
                              4.84711813518352239e01,
                              5.16066755677643736e01,
                              5.47847293981123192e01,
                              5.80036052229805199e01,
                              6.12617017610020020e01,
                              6.45575386270063311e01,
                              6.78897431371815350e01,
                              7.12570389671680090e01,
                              7.46582363488301644e01,
                              7.80922235533153106e01,
                              8.15579594561150372e01,
                              8.50544670175815174e01,
                              8.85808275421976788e01,
                              9.21361756036870925e01,
                              9.57196945421432025e01,
                              9.93306124547874269e01,
                              1.02968198614513813e02,
                              1.06631760260643459e02,
                              1.10320639714757395e02,
                              1.14034211781461703e02,
                              1.17771881399745072e02,
                              1.21533081515438634e02,
                              1.25317271149356895e02,
                              1.29123933639127215e02,
                              1.32952575035616310e02,
                              1.36802722637326368e02,
                              1.40673923648234259e02,
                              1.44565743946344886e02,
                              1.48477766951773032e02};

    Int_t jpm = TMath::Nint(aj + am);
    Int_t jpn = TMath::Nint(aj + an);
    Int_t jmm = TMath::Nint(aj - am);

    Int_t jmn = TMath::Nint(aj - an);
    Int_t mpn = TMath::Nint(am + an);

    Double_t r = 0;
    if (jpm < 0 || jpn < 0 || jmm < 0 || jmn < 0

        || aj < 0 || aj > 25 || beta < 0 || beta > pi2) {
        printf("WignerD: Illegal argument(s) aj=%g, am=%g, an=%g, beta=%g\n", aj, am, an, beta);
    } else if (fabs(beta) < 1e-10) {
        if (jpm == jpn)
            r = 1;
    } else if (fabs(beta - pi) < 1e-10) {
        if (jpm == jmn) {
            r = 1;
            if (TMath::Abs(jpm) % 2 == 1)
                r = -1;
        }
    } else if (fabs(beta - pi2) < 1e-10) {
        if (jpm == jpn) {
            r = 1;
            if (TMath::Abs(mpn) % 2 == 1)
                r = -1;
        }
    } else {
        Double_t b = f * beta;
        Double_t s = TMath::Log(TMath::Sin(b));
        Double_t c = TMath::Log(TMath::Abs(TMath::Cos(b)));
        Double_t rt = 0.5 * (fcl[jpm] + fcl[jmm] + fcl[jpn] + fcl[jmn]);
        Int_t k0 = TMath::Max(0, mpn);
        Int_t kq = k0 + jpm;
        if (beta > pi)
            kq += mpn;
        Double_t q = 1;
        if (kq % 2 == 1)
            q = -1;
        kq = k0 + k0;
        Double_t cx = kq - mpn;
        Double_t sx = jpm + jpn - kq;
        for (Int_t k = k0; k <= TMath::Min(jpm, jpn); k++) {
            r += q * TMath::Exp(rt - fcl[k] - fcl[jpm - k] - fcl[jpn - k] - fcl[k - mpn] + cx * c +
                                sx * s);
            cx += 2;
            sx -= 2;
            q = -q;
        }
    }
    return r;
}

// parital angluar depdent part for /\* (indepdent of L* )
TComplex RooDalitzAmplitude::MEangPart(float hel0,
                                       int delhelmu,
                                       float hel1,
                                       int hel2,
                                       float phi1,
                                       float phi2,
                                       float theta,
                                       float theta2) const {
    // float phi1 = dlz.phi1;
    // float phi2 = dlz.phi2;

    // float theta = dlz.theta;
    // float theta1 = dlz.theta1; //L*
    // float theta2 = dlz.theta2; //psi

    float partphi = hel1 * phi1 + hel2 * phi2;
    //  float partphi = hel1*phi1+hel2*(phi2+TMath::Pi());

    return TComplex(1, partphi, 1) *
           (double)dfunhalf(theta, (int)(hel0 * 2.), (int)((hel1 - hel2) * 2.)) *
           (double)dfunone(theta2, hel2, delhelmu);
}

// parital angluar depdent part for Z
TComplex RooDalitzAmplitude::MEangZPart(float helB,
                                        int delhelmu,
                                        float helZ,
                                        int helpsi,
                                        float phiZ,
                                        float phiMu,
                                        float phiPsi,
                                        float alphaMu,
                                        float thetaB,
                                        float thetaPsi) const {
    // if(JZ<fabs((float)helpsi-help)) return 0.0;
    /*float phiZ = dlz.phiZ;
    float phiMu = dlz.phiMu;
    float phiPsi = dlz.phiPsi;
    float alphaMu = dlz.alphaMu;
    float thetaB = dlz.thetaB;
    float thetaPsi = dlz.thetaPsi;
    float thetaZ = dlz.thetaZ;
    float thetap = dlz.thetap;
    */
    float partphi = helB * phiZ + helpsi * phiMu + helZ * phiPsi + delhelmu * alphaMu;
    return TComplex(1, partphi, 1) * (double)dfunone(thetaPsi, helpsi, delhelmu) *
           (double)dfunhalf(thetaB, (int)(helB * 2.), (int)(helZ * 2.));
    // dfunhalf(thetap,(int)(help*2.),(int)(hel3*2.)) *//hel3 = hel_p in /\*
    //  dfun(thetaZ,JZ,helZ,(float)helpsi-help);

    // return TComplex(1,partphi,1)*dfunhalf(theta,(int)(hel0*2.),(int)((hel1-hel2)*2.))
    // *dfun(theta1,J,hel1,hel3)*dfunone(theta2,hel2,delhelmu);

    //  std::cout << dfun(theta1,J,hel1,hel3)  <<std::endl;
    // return meang;
}

TComplex RooDalitzAmplitude::MEangXPart(float helB,
                                        int delhelmu,
                                        float helZ,
                                        int helpsi,
                                        float help,
                                        float xphiX_X,
                                        float xphiMu_X,
                                        float xphiPsi_X,
                                        float xalphaMu_X,
                                        float thetaB_X,
                                        float thetaPsi_X) const {
    // double partphi = helB*phiZ+helpsi*phiMu+helZ*phiPsi+delhelmu*alphaMu+help*alphaP;
    double partphi =
        helB * xphiX_X + helpsi * xphiMu_X + (helZ - help) * xphiPsi_X + delhelmu * xalphaMu_X;
    return TComplex(1, partphi, 1) * dfunone(thetaPsi_X, helpsi, delhelmu) *
           dfunhalf(thetaB_X, (int)(helB * 2.), (int)((helZ - help) * 2.));
}

template <bool FORCE_ALL>
void RooDalitzAmplitude::ConfigureCouplings(const std::vector<int> Lz_indices,
                                            const std::vector<int> Pc_indices,
                                            const std::vector<int> Zcs_indices) const {

    auto GetValue = [](RooArgList *resonance, int index) {
        RooAbsReal *variable = static_cast<RooAbsReal *>(resonance->at(index));
        return variable->getVal();
    };

    _vamp.clear();
    _paraSpline.clear();
    for (int ik = 0; ik < 4; ++ik) {
        _galpha[ik].clear();
        _fscat[ik].clear();
        if (LINEAR_KMNR)
            _bprod[ik].clear();
        if (SELF_SCATTERING)
            _selfscatter[ik].clear();
    }

    // Lz resonances part
    int ir = 0;
    for (auto iter = _resList->begin(); iter != _resList->end(); ++iter) {
        RooArgList *resonance = static_cast<RooArgList *>(*iter);
        int resonance_size = resonance->getSize();
        int index = ir;

        // Set the values of m0 and g0
        float m0 = static_cast<float>(GetValue(resonance, resonance_size - 5));
        float g0 = static_cast<float>(GetValue(resonance, resonance_size - 4));
        _paraList[index * nset + MASS] = m0;
        _paraList[index * nset + WIDTH] = g0;

        // Get spin parity
        int parity = static_cast<int>(_paraList[index * nset + PARITY]);
        int S2 = static_cast<int>(_paraList[index * nset + SPIN]);
        float S = _paraList[index * nset + SPIN] / 2;

        bool include_resonance =
            FORCE_ALL || std::any_of(Lz_indices.begin(),
                                     Lz_indices.end(),
                                     [&ir](const int Lz_index) { return ir == Lz_index; });

        for (int k = 0; k <= 1; ++k) { // proton helicity [-1/2, 1/2]
            const bool negative_helicity = (k == 0);
            double paritypart = (negative_helicity) ? pow(-1., (int)(S - 1.5)) * parity : 1.;
            for (int m = 0; m < 6; ++m) {
                const bool spin_1half = (S2 == 1);
                if (spin_1half && m >= 4)
                    continue;
                float hel2 = Hel2[m];
#ifdef PAW
                TComplex ampCoff = PartWaveCoff(*resonance, S2, Hel1Two[m], hel2 * 2) * paritypart;
#else
                TComplex ampCoff = HelicityCoff(resonance, m) * paritypart;
#endif
                // Misha's factor for psi
#ifdef Misha
                ampCoff = ampCoff * pow(-1, (1 - hel2));
#endif
                ampCoff = ampCoff * TComplex(GetValue(resonance, resonance_size - 7),
                                             GetValue(resonance, resonance_size - 6));
                amp[ir][k][m] = ampCoff;
                float Re = include_resonance ? ampCoff.Re() : 0.;
                float Im = include_resonance ? ampCoff.Im() : 0.;
                _vamp.push_back(Re);
                _vamp.push_back(Im);
            }
        }
        // Spline lineshape for pK
        if (_paraList[index * nset + TYPE] == MODELINDEPENDENT) {
            MakeSpline(*resonance);
            double x[NUMSP], y[NUMSP], b[NUMSP], c[NUMSP], d[NUMSP];
            double x1[NUMSP], y1[NUMSP], b1[NUMSP], c1[NUMSP], d1[NUMSP];
            for (int isp = 0; isp < NUMSP; ++isp) {
                // 6??
                _sa3.GetCoeff(isp, x[isp], y[isp], b[isp], c[isp], d[isp]);
                _sp3.GetCoeff(isp, x1[isp], y1[isp], b1[isp], c1[isp], d1[isp]);
            }
            // added x[NUMSP], 4*NUMSP for Re Spline, 4*NUMSP for Im Spline
            for (int isp = 0; isp < NUMSP; ++isp) {
                _paraSpline.push_back(x[isp]);
            }
            for (int isp = 0; isp < NUMSP; ++isp) {
                _paraSpline.push_back(y[isp]);
                _paraSpline.push_back(b[isp]);
                _paraSpline.push_back(c[isp]);
                _paraSpline.push_back(d[isp]);
            }
            for (int isp = 0; isp < NUMSP; ++isp) {
                _paraSpline.push_back(y1[isp]);
                _paraSpline.push_back(b1[isp]);
                _paraSpline.push_back(c1[isp]);
                _paraSpline.push_back(d1[isp]);
            }
        }
        ir++;
    }

    // Pc resonances part
    int irZ = 0;
    int icache = 0;
#ifdef WidthLimit
    _kmchanged = false;
#endif
    for (auto iter = _resListZ->begin(); iter != _resListZ->end(); ++iter) {
        RooArgList *resonance = static_cast<RooArgList *>(*iter);
        int resonance_size = resonance->getSize();
        int index = NR + irZ;

        // Set the values of m0 and g0
        float m0 = static_cast<float>(GetValue(resonance, resonance_size - 5));
        float g0 = static_cast<float>(GetValue(resonance, resonance_size - 4));
        _paraList[index * nset + MASS] = m0;
        _paraList[index * nset + WIDTH] = g0;

        // Get spin parity
        int S2 = static_cast<int>(_paraList[index * nset + SPIN]);
        float S = _paraList[index * nset + SPIN] / 2;

        bool include_resonance =
            FORCE_ALL || std::any_of(Pc_indices.begin(),
                                     Pc_indices.end(),
                                     [&irZ](const int Pc_index) { return irZ == Pc_index; });

        for (int k = 0; k <= 1; ++k) { // hel3 proton
            int m(0);
            for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                for (int ihz = 0; ihz <= 1; ++ihz) {
                    float helZ = (ihz == 0) ? -0.5 : 0.5;
                    for (int ihp = 0; ihp <= 1; ++ihp) {
                        float help = (ihp == 0) ? -0.5 : 0.5; // helicity of proton in Pc chain
                        if (fabs((float)helpsi - help) > S) {
                            ampZ[irZ][k][m] = 0;
                            m++;
                            continue;
                        }

                        TComplex ampCoff = PartWaveCoffZ(
                            *resonance, S2, (int)(helZ * 2.), (int)(helpsi * 2.), (int)(help * 2.));
#ifdef Misha
                        ampCoff = ampCoff * pow(-1, (1 - ihp));
#endif
                        ampZ[irZ][k][m] = ampCoff;
                        float Re = (include_resonance) ? ampCoff.Re() : 0.;
                        float Im = (include_resonance) ? ampCoff.Im() : 0.;
                        _vamp.push_back(Re);
                        _vamp.push_back(Im);
                        m++;
                    }
                }
            }
        }
        // Spline Lineshape for Jpsi-p
        if (_paraList[index * nset + TYPE] == MODELINDEPENDENT) {
            MakeSplineZ(*resonance);
            double x[NUMSPZ], y[NUMSPZ], b[NUMSPZ], c[NUMSPZ], d[NUMSPZ];
            double x1[NUMSPZ], y1[NUMSPZ], b1[NUMSPZ], c1[NUMSPZ], d1[NUMSPZ];
            for (int isp = 0; isp < NUMSPZ; ++isp) {
                _sa3.GetCoeff(isp, x[isp], y[isp], b[isp], c[isp], d[isp]);
                _sp3.GetCoeff(isp, x1[isp], y1[isp], b1[isp], c1[isp], d1[isp]);
            }
            for (int isp = 0; isp < NUMSPZ; ++isp) {
                _paraSpline.push_back(x[isp]);
            }
            for (int isp = 0; isp < NUMSPZ; ++isp) {
                _paraSpline.push_back(y[isp]);
                _paraSpline.push_back(b[isp]);
                _paraSpline.push_back(c[isp]);
                _paraSpline.push_back(d[isp]);
            }
            for (int isp = 0; isp < NUMSPZ; ++isp) {
                _paraSpline.push_back(y1[isp]);
                _paraSpline.push_back(b1[isp]);
                _paraSpline.push_back(c1[isp]);
                _paraSpline.push_back(d1[isp]);
            }
        }
        // K-matrix Lineshape for Jpsi-p
        if (_paraList[index * nset + TYPE] == KMATRIX) {
            int ik = 0;
            if ((int)(_paraList[index * nset + SPIN]) == 3)
                ik = 1;
            if ((int)(_paraList[index * nset + PARITY]) > 0)
                ik += 2;
            if (_paraList[index * nset + MASS] > 0) {
                float dtmp = _paraList[index * nset + MASS];
#ifdef WidthLimit
                if (ik == 1) {
                    if (fabs(_resParCache[icache] - dtmp) > 1e-20)
                        _kmchanged = 1;
                    _resParCache[icache] = dtmp;
                    icache++;
                }
#endif
                for (int ib = 8; ib < 12; ++ib) {
                    dtmp = static_cast<float>(GetValue(resonance, ib));
                    _galpha[ik].push_back(dtmp);
#ifdef WidthLimit
                    if (ik == 1) {
                        if (fabs(_resParCache[icache] - dtmp) > 1e-20)
                            _kmchanged = 1;
                        _resParCache[icache] = dtmp;
                        icache++;
                    }
#endif
                }
            } else {
                float dtmp = static_cast<float>(GetValue(resonance, 8));
                _fscat[ik].push_back(dtmp);
                if (LINEAR_KMNR) {
                    float btmp = static_cast<float>(GetValue(resonance, 9));
                    _bprod[ik].push_back(btmp);
                }
                if (SELF_SCATTERING) {
                    const unsigned scattering_index = (LINEAR_KMNR) ? 10 : 9;
                    float fsctmp = static_cast<float>(GetValue(resonance, scattering_index));
                    _selfscatter[ik].push_back(fsctmp);
                }
#ifdef WidthLimit
                if (ik == 1) {
                    if (fabs(_resParCache[icache] - dtmp) > 1e-20)
                        _kmchanged = 1;
                    _resParCache[icache] = dtmp;
                    icache++;
                }
#endif
            }
        }
        irZ++;
    }
    // The Pc resonances have filled the temporary storage for K-matrix
    // Manipulate the non-resonant scattering terms and non-linear P-vector terms
    for (int ik = 0; ik < 4; ++ik) {
        _fscat[ik].resize(NKMC * NKMC);
        if (_fscat[ik].size() > 0) {
            for (int i = 1; i < NKMC; ++i) {
                _fscat[ik][NKMC * i] = _fscat[ik][i];
                // Self scattering or diagonal terms
                // Only applicable for negative parity
                const bool negative_parity = ik <= 1;
                if (SELF_SCATTERING && negative_parity)
                    _fscat[ik][(NKMC + 1) * i] = _selfscatter[ik][i];
            }
        }
        if (LINEAR_KMNR)
            _bprod[ik].resize(NKMC);
    }
    // Penalty term when the width of Pc is too narrow
#ifdef WidthLimit
    if (_kmchanged) {
        float fwhm = (_resParCache[0] > 4.400 && _resParCache[0] < 4.475)
                         ? CalFWHM(1000. * _resParCache[0], _CalFWHM_nbin, _CalFWHM_range)
                         : CalFWHM(4457., _CalFWHM_nbin, _CalFWHM_range);
        _mypnalty = (fwhm > _widthLowerLimit)
                        ? 0.0
                        : 100. * (_widthLowerLimit - fwhm) * (_widthLowerLimit - fwhm);
        _mypnalty += (fwhm < _widthUpperLimit)
                         ? 0.0
                         : 100. * (_widthUpperLimit - fwhm) * (_widthUpperLimit - fwhm);
        std::cout.precision(12);
        std::cout << "Half-width: " << fwhm << "; Incurring penalty term: " << _mypnalty
                  << std::endl;
    }
#endif
    // Zcs resonances part
    int irX = 0;
    for (auto iter = _resListX->begin(); iter != _resListX->end(); ++iter) {
        RooArgList *resonance = static_cast<RooArgList *>(*iter);
        int resonance_size = resonance->getSize();
        int index = NR + NZ + irX;

        // Set the values of m0 and g0
        float m0 = static_cast<float>(GetValue(resonance, resonance_size - 5));
        float g0 = static_cast<float>(GetValue(resonance, resonance_size - 4));
        _paraList[index * nset + MASS] = m0;
        _paraList[index * nset + WIDTH] = g0;

        // Get spin
        int S2 = static_cast<int>(_paraList[index * nset + SPIN]);
        float S = _paraList[index * nset + SPIN] / 2;

        bool include_resonance = FORCE_ALL || std::any_of(Zcs_indices.begin(),
                                                          Zcs_indices.end(),
                                                          [&irX](const unsigned int Zcs_index) {
                                                              return irX == Zcs_index;
                                                          });

        for (int k = 0; k <= 1; ++k) { // hel3 proton. Maybe not needed...
            float hel3 = (k == 0) ? -0.5 : 0.5;
            int m(0);
            for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                if (abs(helpsi) > S)
                    continue;
                for (int ihp = 0; ihp <= 1; ++ihp) {
                    float help = (ihp == 0) ? -0.5 : 0.5;
                    for (int ihz = 0; ihz <= 1; ++ihz) {
                        float helZ = (ihz == 0) ? help - 0.5 : help + 0.5;
                        if (fabs(helZ) > S)
                            continue;
                        TComplex ampCoff = PartWaveCoffX(
                            *resonance, S2, (int)(helZ * 2.), (int)(helpsi * 2.), (int)(help * 2.));
#ifdef Misha
                        ampCoff = ampCoff * pow(-1, (1 - ihp)) * pow(-1, (1 - helpsi));
#endif
                        ampX[irX][k][m] = ampCoff;
                        float Re = include_resonance ? ampCoff.Re() : 0.;
                        float Im = include_resonance ? ampCoff.Im() : 0.;
                        _vamp.push_back(Re);
                        _vamp.push_back(Im);
                        m++;
                    }
                }
            }
        }
        irX++;
    }
}

void RooDalitzAmplitude::CalCoupling() const { ConfigureCouplings<true>(); }

void RooDalitzAmplitude::SetupCoupling(const std::vector<int> &Lz_indices,
                                       const std::vector<int> &Pc_indices,
                                       const std::vector<int> &Zcs_indices) const {
    ConfigureCouplings<false>(Lz_indices, Pc_indices, Zcs_indices);
}

// check for phi_Mu change
void RooDalitzAmplitude::ConvCoupling() const {
    //  std::cout << "update coupling " << std::endl;
    TComplex ampCoff;
    // float hel3;
    //   int delhelmu;
    float S, hel2;
    int S2;
    //  float Re, Im;
    TComplex Hamp[6];
    int ir(0);
    TIterator *coefIter = _resList->MakeIterator();
    while (RooArgList *Ires = (RooArgList *)coefIter->Next()) {
        RooArgList ires = (*Ires);
        //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
        int iressize = ires.getSize();
        // if (type!=1&&type!=2&&type!=3&&type!=4) continue;
        // spin; inputs is 2xspin
        //     int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
        S2 = (int)((RooAbsReal &)ires[iressize - 2]).getVal();
        S = (float)S2 / 2.;
        //    float paritypart;//=pow(-1.,(int)(S-1.5))*parity;
        for (int m = 0; m < 6; ++m) {
            //      amp[ir][i][j][k][m] = 0.0;
            if (fabs(S - 0.5) < 1e-10 && m >= 4) {
                continue;
            }
            //      hel1 = (float)Hel1Two[m]/2.;
            hel2 = Hel2[m];
            //        std::cout << "defined .. " << std::endl;
            ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2 * 2);
            // add minus to abs(Hel_Jpsi)=1;
            Hamp[m] = ampCoff;
            std::cout << "Hamp-old " << m << Hamp[m] << std::endl;
            if (abs(hel2) > 0.5)
                Hamp[m] = Hamp[m] * (-1.);
        }

        // J=S2
        int ib(0);

        for (int S1 = abs(S2 - 2); S1 <= S2 + 2; S1 += 2) {
            for (int L1 = S1 - 1; L1 <= S1 + 1; L1 += 2) {
                TComplex M(((RooAbsReal &)ires[ib * 2]).getVal(),
                           ((RooAbsReal &)ires[ib * 2 + 1]).getVal());
                TComplex M1 = HeliWaveCoff(Hamp, S2, L1, S1);
                ((RooRealVar &)ires[ib * 2]).setVal(M1.Re());
                ((RooRealVar &)ires[ib * 2 + 1]).setVal(M1.Im());
                //         std::cout << "J,S,L " << S2 << " " << S1 <<","<< L1 << " " << M << " " <<
                //         M1 << " " << M1/M << std::endl;
                ib++;
            }
        }
        for (int m = 0; m < 6; ++m) {
            //      amp[ir][i][j][k][m] = 0.0;
            if (fabs(S - 0.5) < 1e-10 && m >= 4) {
                continue;
            }
            //      hel1 = (float)Hel1Two[m]/2.;
            hel2 = Hel2[m];
            //        std::cout << "defined .. " << std::endl;
            ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2 * 2);
            // add minus to abs(Hel_Jpsi)=1;
            // Hamp[m] = ampCoff;
            // if(abs(hel2)>0.5) Hamp[m] *= -1.;
            std::cout << "Hamp-new " << m << ampCoff << std::endl;
        }
        ir++;
    }
    delete coefIter;
}

void RooDalitzAmplitude::setup_paraList() const {
    int S2, LR;
    int ir(0);
    float S;
    TIterator *coefIter = _resList->MakeIterator();
    while (RooArgList *Ires = (RooArgList *)coefIter->Next()) {
        RooArgList ires = (*Ires);
        int iressize = ires.getSize();

        int type = 1; //
        //    if(TString(Ires->GetName()).Contains("1670Flatte")) type = 2;
        type = (int)((RooAbsReal &)ires[iressize - 3]).getVal();
        S2 = (int)((RooAbsReal &)ires[iressize - 2]).getVal();
        S = (float)S2 / 2.;
        int parity = (int)((RooAbsReal &)ires[iressize - 1]).getVal();
        LR = (int)(S - 0.5);
        //(-1)*(-1)^LR = P_Ln
        if ((pow(-1, LR + 1) * parity) < 0)
            LR += 1;
        _paraList[ir * nset + SPIN] = S2;
        _paraList[ir * nset + LRESON] = LR;
        _paraList[ir * nset + TYPE] = type;
        _paraList[ir * nset + PARITY] = parity;
        //    _paraList[ir*nset+5] = 0;
        ir++;
    }
    delete coefIter;

    TIterator *coefIterZ = _resListZ->MakeIterator();
    while (RooArgList *Ires = (RooArgList *)coefIterZ->Next()) {
        RooArgList ires = (*Ires);
        int iressize = ires.getSize();
        int type = 1;
        type = (int)((RooAbsReal &)ires[iressize - 3]).getVal();
        S2 = (int)((RooAbsReal &)ires[iressize - 2]).getVal();
        S = (float)S2 / 2.;
        int parity = (int)((RooAbsReal &)ires[iressize - 1]).getVal();
        LR = TMath::Max((int)(S - 1.5), 0);
        //(-1)*(-1)^LR = P_Lz
        if ((pow(-1, LR + 1) * parity) < 0)
            LR += 1;
        _paraList[ir * nset + SPIN] = S2;
        _paraList[ir * nset + LRESON] = LR;
        _paraList[ir * nset + TYPE] = type;
        _paraList[ir * nset + PARITY] = parity;
        //    _paraList[ir*nset+5] = 0;
        ir++;
    }
    delete coefIterZ;

    TIterator *coefIterX = _resListX->MakeIterator();
    while (RooArgList *Ires = (RooArgList *)coefIterX->Next()) {
        RooArgList ires = (*Ires);
        int iressize = ires.getSize();
        int type = 1;
        type = (int)((RooAbsReal &)ires[iressize - 3]).getVal();
        S2 = (int)((RooAbsReal &)ires[iressize - 2]).getVal();
        S = (float)S2 / 2.;
        int parity = (int)((RooAbsReal &)ires[iressize - 1]).getVal();
        LR = TMath::Max(abs((int)(S - 1)), 0); // TMath::Max((int)(S-1.5),0);
        //(-1)*(-1)^LR = P_Lz
        if ((pow(-1, LR) * parity) < 0)
            LR += 1; // if((pow(-1,LR+1)*parity)<0) LR += 1;
        _paraList[ir * nset + 2] = S2;
        _paraList[ir * nset + 3] = LR;
        _paraList[ir * nset + 4] = type;
        _paraList[ir * nset + 5] = parity;
        ir++;
    }
    delete coefIterX;
}

// pass
void RooDalitzAmplitude::cu_init_data(float *&h_paraList, double *&h_fx, int i_End) const {
    // init h_couping
    /*
      int sizeamp = sizeof(amp);
      h_coupling = (TComplex *)malloc(sizeamp);
    int array_num = sizeamp / sizeof(TComplex);
    for(int i=0;i<array_num; i++) {
      h_coupling[i] =
      */
    int size_para = _paraList.size();
    int size_vamp = _vamp.size();
    int size_spline = _paraSpline.size();
    int size_km = (Npmax + NKMC) * NKMC + ((LINEAR_KMNR) ? NKMC : 0);
    //  std::cout << "total size " << size_para+size_vamp+size_spline+size_km*2 << std::endl;
    h_paraList =
        (float *)malloc((size_para + size_vamp + size_spline + size_km * 4) * sizeof(float));

    int icount(0);
    for (int i = 0; i < size_para; i++) {
        h_paraList[icount++] = _paraList[i];
    }
    //  std::cout << "h_paraList[2] " << h_paraList[2] <<std::endl;
    //  h_vamp=(float*)malloc(_vamp.size()*sizeof(float));
    for (int i = 0; i < size_vamp; i++) {
        h_paraList[icount++] = _vamp[i];
    }
    //  size_para += size_vamp;
    //  h_paraSpline=(float*)malloc(_paraSpline.size()*sizeof(float));
    for (int i = 0; i < size_spline; i++) {
        h_paraList[icount++] = _paraSpline[i];
    }
    // size_para += size_spline;
    // put Kmatrix parameters
    //   std::cout << " icount0 " << icount << std::endl;
    for (int ik = 0; ik < 4; ++ik) {
        //  std::cout << "Km " << ik << " size " << _galpha[ik].size() << " " << _fscat[ik].size()
        //  << std::endl;
        int gsize = _galpha[ik].size();
        for (int i = 0; i < gsize; ++i) {
            h_paraList[icount++] = _galpha[ik][i];
        }
        for (int i = gsize; i < Npmax * NKMC; ++i) {
            h_paraList[icount++] = 0;
        }
        gsize = _fscat[ik].size();
        for (int i = 0; i < gsize; ++i) {
            h_paraList[icount++] = _fscat[ik][i];
        }
        // std::cout << " icount1 " << icount << std::endl;
    }

    if (LINEAR_KMNR) {
        for (int ik = 0; ik < 4; ik++) {
            for (int i = 0; i < NKMC; i++) {
                h_paraList[icount++] = _bprod[ik][i];
            }
        }
    }

    /*  std::cout << "paraList[] = {" << std::endl;
    for(int i=0; i<(size_para+size_vamp+size_spline); ++i) {
     std::cout << h_paraList[i] << ";" <<std::endl;
    }
    std::cout << "}" << std::endl;*/
    //  std::cout << "h_vamp[2] " << h_vamp[2] << std::endl;

    h_fx = new double[i_End];
    //  std::cout << "shared size " << _paraList.size()+_vamp.size()+_paraSpline.size() <<
    //  std::endl;
}

Double_t RooDalitzAmplitude::GetAmp2sSMR(Jpsihh_dlz &dlz,
                                         Amp_dlz *tnew,
                                         bool method1,
                                         bool finebinning) const {
    //  TComplex H[2][2][2];//delhelmu=+/-1,hel0=+/-1/2,hel3=+/-1/2

    TComplex H_L_Zcs[2][2][2];
    TComplex HZ[MYZN][2][2][2]; // at most 10 Pc
    TComplex BW1Pc[MYZN];       // at most MYZN Pc
    TComplex BWPc_tmp[MYZN];    // at most MYZN Pc
    float BW2PcRR[MYZN][MYZN];
    float BW2PcII[MYZN][MYZN];
    float BW2PcIR[MYZN][MYZN];
    float BW2PcRI[MYZN][MYZN];

    for (int i = 0; i <= 1; ++i) {
        for (int j = 0; j <= 1; ++j) {
            for (int k = 0; k <= 1; ++k) {
                H_L_Zcs[i][j][k] = TComplex(0, 0);
                for (int iPc = 0; iPc < MYZN; ++iPc) {
                    HZ[iPc][i][j][k] = TComplex(0, 0);
                }
            }
        }
    }

    for (int iPc = 0; iPc < MYZN; ++iPc) {
        BW1Pc[iPc] = TComplex(0.0, 0.0);
        BWPc_tmp[iPc] = TComplex(0.0, 0.0);
        for (int jPc = 0; jPc < MYZN; ++jPc) {
            BW2PcRR[iPc][jPc] = 0.;
            BW2PcII[iPc][jPc] = 0.;
            BW2PcIR[iPc][jPc] = 0.;
            BW2PcRI[iPc][jPc] = 0.;
        }
    }

    float re_i, im_i;
    //  float hel0, hel3;
    //  int delhelmu;
    float S;
    float mppi(dlz.mppi);
    int S2, LR;
    int type;
    int iS2, iLR;
    float iS;
    int itype;
    TComplex RM;
    TComplex ampCoff, AIndep;
    TComplex iBW;
    TComplex jBW;
    float iBterm;
    float Bterm;
    float im0, ig0;
    int ir(0);
    int isp(0);
    int splcount(0); // not very good as L* and Z are different syst.
    TComplex tp, tpz;
    while (ir < NR) {
        float m0 = _paraList[ir * nset + MASS];
        float g0 = _paraList[ir * nset + WIDTH];
        S2 = (int)(_paraList[ir * nset + SPIN]);
        LR = (int)(_paraList[ir * nset + LRESON]);
        type = (int)(_paraList[ir * nset + TYPE]);
        S = (float)S2 / 2.;
        //(-1)*(-1)^LR = P_Ln
        switch (type) {
        case BREITWIGNER: {
            BW_AMP(m0, g0, mppi, LR, re_i, im_i);
            break;
        }
        case FLATTE: {
            // need to update
            BW_AMP(m0, g0, mppi, LR, re_i, im_i, 1. / (1. + 0.37));
            break;
        }
            // Bterm = BTerm(S, mppi, m0);
        case REVISEDKMATRIX: {
            Revised_KMAMP(mppi, ir, 0, NR, re_i, im_i, 0);
            break;
        }
        case MODELINDEPENDENT: { // for mhh only
            ModelIndependentWave3(&_paraSpline[splcount], mppi, re_i, im_i);
            // a bug here
            //         spline((double)mppi,re_i,im_i);

            m0 = -0.5; // 4.1163770;
            splcount += 9 * NUMSP;
            break;
        }
        }
        Bterm = BTerm(S, mppi, m0);

        RM = TComplex((double)re_i, (double)im_i) * (double)Bterm;
        //    if(type==MODELINDEPENDENT) std::cout << "ZLM " << mppi << " " << RM.Rho2() <<
        //    std::endl;
        for (int i = 0; i <= 1; ++i) { // delmu
            //      delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                //      hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    //      hel3 = (k==0) ? -0.5: 0.5;
                    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
                    for (int m = 0; m < 6; ++m) {

                        if (fabs(S - 0.5) < 1e-10 && m >= 4) {
                            if (method1) {
                                tnew->ARe[ir][i][j][k][m] = 0.0;
                                tnew->AIm[ir][i][j][k][m] = 0.0;
                            }
                            continue;
                        }

                        ampCoff = amp[ir][k][m];
                        tp = ((double)dlz.DL[(S2 - 1) / 2][k][m]) *
                             TComplex((double)dlz.ARe[i][j][m], (double)dlz.AIm[i][j][m]) * RM;
                        if (method1) {
                            tnew->ARe[ir][i][j][k][m] = tp.Re();
                            tnew->AIm[ir][i][j][k][m] = tp.Im();
                        }
                        if ((ampCoff.Rho2()) < 1e-10)
                            continue;
                        H_L_Zcs[i][j][k] += tp * ampCoff;
                    }
                }
            }
        }
        ir++;
    }

    // Z part
    int irZ(0);
    float help;
    float mjpsip(dlz.mjpsip);
    while (irZ < NZ) {
        S2 = (int)(_paraList[ir * nset + SPIN]);
        S = (float)S2 / 2.;

        float m0 = _paraList[ir * nset + MASS];
        float g0 = _paraList[ir * nset + WIDTH];

        LR = (int)(_paraList[ir * nset + LRESON]);

        type = (int)(_paraList[ir * nset + TYPE]);

        // Rj BW here
        for (int i = 0; i <= 1; ++i) { // delmu
            // delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                // hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    // hel3 = (k==0) ? -0.5: 0.5;
                    // there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2,
                    // help=+/-1/2
                    int m(0);
                    for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                        for (int ihz = 0; ihz <= 1; ++ihz) {
                            //   helZ = (ihz==0) ? -0.5: 0.5;
                            for (int ihp = 0; ihp <= 1; ++ihp) {
                                help = (ihp == 0) ? -0.5 : 0.5;
                                if (fabs((float)helpsi - help) > S) {
                                    if (method1) {
                                        tnew->AZRe[irZ][i][j][k][m] = 0.0;
                                        tnew->AZIm[irZ][i][j][k][m] = 0.0;
                                    }
                                    m++;
                                    continue;
                                }
                                ampCoff = ampZ[irZ][k][m];
                                tpz =
                                    ((double)dlz.DZ[(S2 - 1) / 2][k][m]) *
                                    TComplex((double)dlz.AZRe[i][j][m], (double)dlz.AZIm[i][j][m]);
                                //*TComplex(dlz.AZRe[i][j][m], dlz.AZIm[i][j][m]) * RM;
                                if (method1) {
                                    tnew->AZRe[irZ][i][j][k][m] = tpz.Re();
                                    tnew->AZIm[irZ][i][j][k][m] = tpz.Im();
                                }
                                if ((ampCoff.Rho2()) < 1e-10) {
                                    m++;
                                    continue;
                                }

                                HZ[irZ][i][j][k] += tpz * ampCoff;
                                //* TComplex(dlz.RM[ir][0],dlz.RM[ir][1])
                                //* ((float)dlz.DZ[((S2-1)/2)][k][m]) ;//AIndep;
                                m++;
                            }
                        }
                    }
                }
            }
        }
        ir++;
        irZ++;
    }

    // Zcs part
    int irX(0);
    //  float help;
    float mjpsipi(dlz.mjpsipi);

    while (irX < NX) {
        S2 = (int)(_paraList[ir * nset + 2]);
        S = (float)S2 / 2.;

        float m0 = _paraList[ir * nset];
        float g0 = _paraList[ir * nset + 1];

        LR = (int)(_paraList[ir * nset + 3]);

        type = (int)(_paraList[ir * nset + 4]); // Only consider BW at this moment
                                                // Mass-dependent term
        BW_AMPX(m0, g0, mjpsipi, LR, re_i, im_i);
        Bterm = BTermX(S, mjpsipi, m0);
        RM = TComplex((double)re_i, (double)im_i) * (double)Bterm;

        // Angular-dependent term
        for (int i = 0; i <= 1; ++i) { // delmu
            //        delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                //          hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    //            hel3 = (k==0) ? -0.5: 0.5;
                    // there are 12 amplitudes to be added coherently //helpsi,0,+/-1,
                    // helX,help+/-1/2, help=+/-1/2
                    int m(0);
                    for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                        if (abs(helpsi) > S)
                            continue;
                        for (int ihp = 0; ihp <= 1; ++ihp) {
                            help = (ihp == 0) ? -0.5 : 0.5;
                            for (int ihz = 0; ihz <= 1; ++ihz) {
                                float helZ = (ihz == 0) ? help - 0.5 : help + 0.5;
                                if (fabs(helZ) > S)
                                    continue;
                                ampCoff = ampX[irX][k][m];
                                tpz =
                                    ((double)dlz.DX[(S2) / 2][k][m]) *
                                    TComplex((double)dlz.AXRe[i][j][m], (double)dlz.AXIm[i][j][m]) *
                                    RM;
                                if ((ampCoff.Rho2()) < 1e-10) {
                                    m++;
                                    continue;
                                }

                                H_L_Zcs[i][j][k] += ampCoff * tpz;
                                m++;
                            }
                        }
                    }
                }
            }
        }
        ir++;
        irX++;
    }

    int splcount0 = splcount;
    float mres = _mres0 + mjpsip * (_mres1 + mjpsip * _mres2);
#ifdef RESPLUS
    mres = mres * 1.1;
#endif
#ifdef RESMINUS
    mres = mres * 0.9;
#endif
    int _smear_nbins_tmp = SMEAR_NBINS;
    if (finebinning) {
        _smear_nbins_tmp = SMEAR_FINE_NBINS;
    }
    float smear_binwidth = mres * _smear_nsigmas * 2 / _smear_nbins_tmp;
    float mjpsip_smear;
    int iPc;
    int jPc;
    int iir;
    for (int smear_ibin = 0; smear_ibin < _smear_nbins_tmp; smear_ibin++) {
        iPc = 0;
        jPc = 0;
        iir = 0;
        mjpsip_smear = -_smear_nsigmas * mres + smear_binwidth * smear_ibin + smear_binwidth * 0.5;
        float weight_smear = TMath::Gaus(mjpsip_smear, 0, mres, true) * smear_binwidth;

        splcount = splcount0;
        std::vector<TComplex> AKM[4];
        AKM[0].push_back(0);
        AKM[1].push_back(0);
        AKM[2].push_back(0);
        AKM[3].push_back(0);
        int ikmcount[] = {0, 0, 0, 0};

        while (iPc < NZ) {
            iir = NR + iPc;
            im0 = _paraList[iir * nset + MASS];
            ig0 = _paraList[iir * nset + WIDTH];
            iS2 = (int)(_paraList[iir * nset + SPIN]);
            iLR = (int)(_paraList[iir * nset + LRESON]);
            itype = (int)(_paraList[iir * nset + TYPE]);
            iS = (float)iS2 / 2.;
            int isp(0);
            switch (itype) {
            case MODELINDEPENDENT: {
                ModelIndependentWave(&_paraSpline[splcount], mjpsip + mjpsip_smear, re_i, im_i);
                // Bterm = BTermZ(S, mjpsip,-1000);
                im0 = -0.5;
                splcount += 9 * NUMSPZ;
                break;
            }
            case BREITWIGNER: {
                BW_AMPZ(im0, ig0, mjpsip + mjpsip_smear, iLR, re_i, im_i);
                break;
            }
            case REVISEDKMATRIX: {
                Revised_KMAMP(mjpsip + mjpsip_smear, iir, NR, NR + NZ, re_i, im_i, 1);
                break;
            } // do smear ==To check by Mengzhen
            case TRIANGLE: {
                GetCusp_AMP(im0, ig0, mjpsip + mjpsip_smear, re_i, im_i);
                break;
            }
            case KMATRIX: {
                int ik(0);
                if (iS2 == 3)
                    ik = 1;
                if (iLR > 0)
                    ik += 2;
                if (AKM[ik][0].Rho2() < 1e-10) {
                    //          KMatrix(mjpsip + mjpsip_smear, iS2, -1, _galpha[ik], _fscat[ik],
                    //          AKM[ik]);
                    KMatrix(mjpsip + mjpsip_smear,
                            iS2,
                            ((iLR > 0) ? 1 : -1),
                            _galpha[ik],
                            _fscat[ik],
                            AKM[ik]);
                }
                re_i = AKM[ik][ikmcount[ik]].Re();
                im_i = AKM[ik][ikmcount[ik]].Im();
                ikmcount[ik]++;

                break;
            }
            }
            iBterm = BTermZ(iS, mjpsip + mjpsip_smear, im0) * weight_smear;
            //       RM = TComplex(re_i,im_i)*Bterm;
            BWPc_tmp[iPc] = TComplex((double)re_i * iBterm, (double)im_i * iBterm, false);
            BW1Pc[iPc] += TComplex((double)re_i * iBterm, (double)im_i * iBterm, false);
            iPc++;
        }
        iPc = 0;
        while (iPc < NZ) {
            jPc = 0;
            while (jPc < NZ) {
                iBW = BWPc_tmp[iPc];
                jBW = 1. / weight_smear * BWPc_tmp[jPc];
                BW2PcRR[iPc][jPc] += iBW.Re() * jBW.Re(); // weight involved in iBW, float counted.
                BW2PcII[iPc][jPc] += iBW.Im() * jBW.Im();
                BW2PcIR[iPc][jPc] += iBW.Im() * jBW.Re();
                BW2PcRI[iPc][jPc] += iBW.Re() * jBW.Im();
                //        std::cout << "wmz debug smear BW2PcRR : " << iPc << " " << jPc << "  " <<
                //        BW2PcRR[iPc][jPc]<< std::endl; std::cout << "wmz debug smear BW2PcII : "
                //        << iPc << " " << jPc << "  " << BW2PcII[iPc][jPc]<< std::endl; std::cout
                //        << "wmz debug smear BW2PcIR : " << iPc << " " << jPc << "  " <<
                //        BW2PcIR[iPc][jPc]<< std::endl; std::cout << "wmz debug smear BW2PcRI : "
                //        << iPc << " " << jPc << "  " << BW2PcRI[iPc][jPc]<< std::endl;
                jPc++;
            }
            iPc++;
        }
    }

    //  float totalA = H[0][0][0].Rho2() + H[0][0][1].Rho2()
    //    + H[0][1][0].Rho2() + H[0][1][1].Rho2()
    //    + H[1][0][0].Rho2() + H[1][0][1].Rho2()
    //    + H[1][1][0].Rho2() + H[1][1][1].Rho2();

    float totalA = 0.;
    TComplex Amp1L;
    TComplex Amp1Pc;
    for (int k = 0; k <= 1; ++k) {
        for (int i = 0; i <= 1; ++i) {
            for (int j = 0; j <= 1; ++j) {
                totalA += H_L_Zcs[i][j][k].Rho2();
                //        std::cout << "wmz debug smear L* part: " << totalA << std::endl;
                int iPc = 0;
                while (iPc < NZ) {
                    Amp1Pc = BW1Pc[iPc] * HZ[iPc][i][j][k];
                    Amp1L = H_L_Zcs[i][j][k];
                    totalA += 2 * (Amp1Pc.Re() * Amp1L.Re() + Amp1Pc.Im() * Amp1L.Im());
                    //                std::cout << "wmz debug smear L* Z interference: " << totalA
                    //                << std::endl;
                    int jPc = 0;
                    while (jPc < NZ) {
                        totalA += (BW2PcRR[iPc][jPc] + BW2PcII[iPc][jPc]) *
                                      (HZ[iPc][i][j][k].Re() * HZ[jPc][i][j][k].Re() +
                                       HZ[iPc][i][j][k].Im() * HZ[jPc][i][j][k].Im()) +
                                  (BW2PcIR[iPc][jPc] - BW2PcRI[iPc][jPc]) *
                                      (HZ[iPc][i][j][k].Re() * HZ[jPc][i][j][k].Im() -
                                       HZ[iPc][i][j][k].Im() * HZ[jPc][i][j][k].Re());
                        //                        std::cout << "wmz debug smear Z Z interference: "
                        //                        << BW2PcRR[iPc][jPc] << "   " << BW2PcII[iPc][jPc]
                        //                        << "  " <<
                        //                        HZ[iPc][i][j][k].Re()*HZ[jPc][i][j][k].Re()+HZ[iPc][i][j][k].Im()*HZ[jPc][i][j][k].Im()
                        //                        << "   " << BW2PcIR[iPc][jPc] << "  " <<
                        //                        BW2PcRI[iPc][jPc] << "    " <<
                        //                        HZ[iPc][i][j][k].Re()*HZ[jPc][i][j][k].Im()-HZ[iPc][i][j][k].Im()*HZ[jPc][i][j][k].Re()
                        //                        << std::endl;
                        jPc++;
                    }

                    iPc++;
                }
            }
        }
    }
    //  std::cout << "wmz debug smear " << totalA << std::endl;
    return totalA;
}

Double_t
RooDalitzAmplitude::GetAmp2sSMR_badbinning(Jpsihh_dlz &dlz, Amp_dlz *tnew, bool method1) const {
    // const unsigned int SMEAR_BAD_NBINS = 20;
    const float SMEAR_BAD_BINNING[20] = {-1.960, -1.440, -1.150, -0.934, -0.755, -0.598, -0.454,
                                         -0.319, -0.189, -0.063, 0.063,  0.189,  0.319,  0.454,
                                         0.598,  0.755,  0.935,  1.150,  1.440,  1.960};
    //  TComplex H[2][2][2];//delhelmu=+/-1,hel0=+/-1/2,hel3=+/-1/2

    TComplex H_L_Zcs[2][2][2];
    TComplex HZ[MYZN][2][2][2]; // at most 10 Pc
    TComplex BW1Pc[MYZN];       // at most MYZN Pc
    TComplex BWPc_tmp[MYZN];    // at most MYZN Pc
    float BW2PcRR[MYZN][MYZN];
    float BW2PcII[MYZN][MYZN];
    float BW2PcIR[MYZN][MYZN];
    float BW2PcRI[MYZN][MYZN];

    for (int i = 0; i <= 1; ++i) {
        for (int j = 0; j <= 1; ++j) {
            for (int k = 0; k <= 1; ++k) {
                H_L_Zcs[i][j][k] = TComplex(0, 0);
                for (int iPc = 0; iPc < MYZN; ++iPc) {
                    HZ[iPc][i][j][k] = TComplex(0, 0);
                }
            }
        }
    }

    for (int iPc = 0; iPc < MYZN; ++iPc) {
        BW1Pc[iPc] = TComplex(0.0, 0.0);
        BWPc_tmp[iPc] = TComplex(0.0, 0.0);
        for (int jPc = 0; jPc < MYZN; ++jPc) {
            BW2PcRR[iPc][jPc] = 0.;
            BW2PcII[iPc][jPc] = 0.;
            BW2PcIR[iPc][jPc] = 0.;
            BW2PcRI[iPc][jPc] = 0.;
        }
    }

    float re_i, im_i;
    //  float hel0, hel3;
    //  int delhelmu;
    float S;
    float mppi(dlz.mppi);
    int S2, LR;
    int type;
    int iS2, iLR;
    float iS;
    int itype;
    TComplex RM;
    TComplex ampCoff, AIndep;
    TComplex iBW;
    TComplex jBW;
    float iBterm;
    float Bterm;
    float im0, ig0;
    int ir(0);
    int isp(0);
    int splcount(0); // not very good as L* and Z are different syst.
    TComplex tp, tpz;
    while (ir < NR) {
        float m0 = _paraList[ir * nset + MASS];
        float g0 = _paraList[ir * nset + WIDTH];
        S2 = (int)(_paraList[ir * nset + SPIN]);
        LR = (int)(_paraList[ir * nset + LRESON]);
        type = (int)(_paraList[ir * nset + TYPE]);
        S = (float)S2 / 2.;
        //(-1)*(-1)^LR = P_Ln
        switch (type) {
        case BREITWIGNER: {
            BW_AMP(m0, g0, mppi, LR, re_i, im_i);
            break;
        }
        case FLATTE: {
            // need to update
            BW_AMP(m0, g0, mppi, LR, re_i, im_i, 1. / (1. + 0.37));
            break;
        }
            // Bterm = BTerm(S, mppi, m0);
        case REVISEDKMATRIX: {
            Revised_KMAMP(mppi, ir, 0, NR, re_i, im_i, 0);
            break;
        }
        case MODELINDEPENDENT: { // for mhh only
            ModelIndependentWave3(&_paraSpline[splcount], mppi, re_i, im_i);
            // a bug here
            //         spline((double)mppi,re_i,im_i);

            m0 = -0.5; // 4.1163770;
            splcount += 9 * NUMSP;
            break;
        }
        }
        Bterm = BTerm(S, mppi, m0);

        RM = TComplex((double)re_i, (double)im_i) * (double)Bterm;
        //    if(type==MODELINDEPENDENT) std::cout << "ZLM " << mppi << " " << RM.Rho2() <<
        //    std::endl;
        for (int i = 0; i <= 1; ++i) { // delmu
            //      delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                //      hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    //      hel3 = (k==0) ? -0.5: 0.5;
                    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
                    for (int m = 0; m < 6; ++m) {

                        if (fabs(S - 0.5) < 1e-10 && m >= 4) {
                            if (method1) {
                                tnew->ARe[ir][i][j][k][m] = 0.0;
                                tnew->AIm[ir][i][j][k][m] = 0.0;
                            }
                            continue;
                        }

                        ampCoff = amp[ir][k][m];
                        tp = ((double)dlz.DL[(S2 - 1) / 2][k][m]) *
                             TComplex((double)dlz.ARe[i][j][m], (double)dlz.AIm[i][j][m]) * RM;
                        if (method1) {
                            tnew->ARe[ir][i][j][k][m] = tp.Re();
                            tnew->AIm[ir][i][j][k][m] = tp.Im();
                        }
                        if ((ampCoff.Rho2()) < 1e-10)
                            continue;
                        H_L_Zcs[i][j][k] += tp * ampCoff;
                    }
                }
            }
        }
        ir++;
    }

    // Z part
    int irZ(0);
    float help;
    float mjpsip(dlz.mjpsip);
    while (irZ < NZ) {
        S2 = (int)(_paraList[ir * nset + SPIN]);
        S = (float)S2 / 2.;

        float m0 = _paraList[ir * nset + MASS];
        float g0 = _paraList[ir * nset + WIDTH];

        LR = (int)(_paraList[ir * nset + LRESON]);

        type = (int)(_paraList[ir * nset + TYPE]);

        // Rj BW here
        for (int i = 0; i <= 1; ++i) { // delmu
            // delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                // hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    // hel3 = (k==0) ? -0.5: 0.5;
                    // there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2,
                    // help=+/-1/2
                    int m(0);
                    for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                        for (int ihz = 0; ihz <= 1; ++ihz) {
                            //   helZ = (ihz==0) ? -0.5: 0.5;
                            for (int ihp = 0; ihp <= 1; ++ihp) {
                                help = (ihp == 0) ? -0.5 : 0.5;
                                if (fabs((float)helpsi - help) > S) {
                                    if (method1) {
                                        tnew->AZRe[irZ][i][j][k][m] = 0.0;
                                        tnew->AZIm[irZ][i][j][k][m] = 0.0;
                                    }
                                    m++;
                                    continue;
                                }
                                ampCoff = ampZ[irZ][k][m];
                                tpz =
                                    ((double)dlz.DZ[(S2 - 1) / 2][k][m]) *
                                    TComplex((double)dlz.AZRe[i][j][m], (double)dlz.AZIm[i][j][m]);
                                //*TComplex(dlz.AZRe[i][j][m], dlz.AZIm[i][j][m]) * RM;
                                if (method1) {
                                    tnew->AZRe[irZ][i][j][k][m] = tpz.Re();
                                    tnew->AZIm[irZ][i][j][k][m] = tpz.Im();
                                }
                                if ((ampCoff.Rho2()) < 1e-10) {
                                    m++;
                                    continue;
                                }

                                HZ[irZ][i][j][k] += tpz * ampCoff;
                                //* TComplex(dlz.RM[ir][0],dlz.RM[ir][1])
                                //* ((float)dlz.DZ[((S2-1)/2)][k][m]) ;//AIndep;
                                m++;
                            }
                        }
                    }
                }
            }
        }
        ir++;
        irZ++;
    }

    // Zcs part
    int irX(0);
    //  float help;
    float mjpsipi(dlz.mjpsipi);

    while (irX < NX) {
        S2 = (int)(_paraList[ir * nset + 2]);
        S = (float)S2 / 2.;

        float m0 = _paraList[ir * nset];
        float g0 = _paraList[ir * nset + 1];

        LR = (int)(_paraList[ir * nset + 3]);

        type = (int)(_paraList[ir * nset + 4]); // Only consider BW at this moment
                                                // Mass-dependent term
        BW_AMPX(m0, g0, mjpsipi, LR, re_i, im_i);
        Bterm = BTermX(S, mjpsipi, m0);
        RM = TComplex((double)re_i, (double)im_i) * (double)Bterm;

        // Angular-dependent term
        for (int i = 0; i <= 1; ++i) { // delmu
            //        delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                //          hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    //            hel3 = (k==0) ? -0.5: 0.5;
                    // there are 12 amplitudes to be added coherently //helpsi,0,+/-1,
                    // helX,help+/-1/2, help=+/-1/2
                    int m(0);
                    for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                        if (abs(helpsi) > S)
                            continue;
                        for (int ihp = 0; ihp <= 1; ++ihp) {
                            help = (ihp == 0) ? -0.5 : 0.5;
                            for (int ihz = 0; ihz <= 1; ++ihz) {
                                float helZ = (ihz == 0) ? help - 0.5 : help + 0.5;
                                if (fabs(helZ) > S)
                                    continue;
                                ampCoff = ampX[irX][k][m];
                                tpz =
                                    ((double)dlz.DX[(S2) / 2][k][m]) *
                                    TComplex((double)dlz.AXRe[i][j][m], (double)dlz.AXIm[i][j][m]) *
                                    RM;
                                if ((ampCoff.Rho2()) < 1e-10) {
                                    m++;
                                    continue;
                                }

                                H_L_Zcs[i][j][k] += ampCoff * tpz;
                                m++;
                            }
                        }
                    }
                }
            }
        }
        ir++;
        irX++;
    }

    int splcount0 = splcount;
    float mres = _mres0 + mjpsip * (_mres1 + mjpsip * _mres2);
#ifdef RESPLUS
    mres = mres * 1.1;
#endif
#ifdef RESMINUS
    mres = mres * 0.9;
#endif

    float weight_smear = 1. / SMEAR_BAD_NBINS;

    float mjpsip_smear;
    int iPc;
    int jPc;
    int iir;
    for (int smear_ibin = 0; smear_ibin < SMEAR_BAD_NBINS; smear_ibin++) {
        iPc = 0;
        jPc = 0;
        iir = 0;
        splcount = splcount0;
        mjpsip_smear = SMEAR_BAD_BINNING[smear_ibin] * mres;
        std::vector<TComplex> AKM[4];
        AKM[0].push_back(0);
        AKM[1].push_back(0);
        AKM[2].push_back(0);
        AKM[3].push_back(0);
        int ikmcount[] = {0, 0, 0, 0};

        while (iPc < NZ) {
            iir = NR + iPc;
            im0 = _paraList[iir * nset + MASS];
            ig0 = _paraList[iir * nset + WIDTH];
            iS2 = (int)(_paraList[iir * nset + SPIN]);
            iLR = (int)(_paraList[iir * nset + LRESON]);
            itype = (int)(_paraList[iir * nset + TYPE]);
            iS = (float)iS2 / 2.;
            int isp(0);
            switch (itype) {
            case MODELINDEPENDENT: {
                ModelIndependentWave(&_paraSpline[splcount], mjpsip + mjpsip_smear, re_i, im_i);
                // Bterm = BTermZ(S, mjpsip,-1000);
                im0 = -0.5;
                splcount += 9 * NUMSPZ;
                break;
            }
            case BREITWIGNER: {
                BW_AMPZ(im0, ig0, mjpsip + mjpsip_smear, iLR, re_i, im_i);
                break;
            }
            case REVISEDKMATRIX: {
                Revised_KMAMP(mjpsip + mjpsip_smear, iir, NR, NR + NZ, re_i, im_i, 1);
                break;
            } // do smear ==To check by Mengzhen
            case TRIANGLE: {
                GetCusp_AMP(im0, ig0, mjpsip + mjpsip_smear, re_i, im_i);
                break;
            }
            case KMATRIX: {
                int ik(0);
                if (iS2 == 3)
                    ik = 1;
                if (iLR > 0)
                    ik += 2;
                if (AKM[ik][0].Rho2() < 1e-10) {
                    //          KMatrix(mjpsip + mjpsip_smear, iS2, -1, _galpha[ik], _fscat[ik],
                    //          AKM[ik]);
                    KMatrix(mjpsip + mjpsip_smear,
                            iS2,
                            ((iLR > 0) ? 1 : -1),
                            _galpha[ik],
                            _fscat[ik],
                            AKM[ik]);
                }
                re_i = AKM[ik][ikmcount[ik]].Re();
                im_i = AKM[ik][ikmcount[ik]].Im();
                ikmcount[ik]++;

                break;
            }
            }
            iBterm = BTermZ(iS, mjpsip + mjpsip_smear, im0) * weight_smear;
            //       RM = TComplex(re_i,im_i)*Bterm;
            BWPc_tmp[iPc] = TComplex((double)re_i * iBterm, (double)im_i * iBterm, false);
            BW1Pc[iPc] += TComplex((double)re_i * iBterm, (double)im_i * iBterm, false);
            iPc++;
        }
        iPc = 0;
        while (iPc < NZ) {
            jPc = 0;
            while (jPc < NZ) {
                iBW = BWPc_tmp[iPc];
                jBW = 1. / weight_smear * BWPc_tmp[jPc];
                BW2PcRR[iPc][jPc] += iBW.Re() * jBW.Re(); // weight involved in iBW, float counted.
                BW2PcII[iPc][jPc] += iBW.Im() * jBW.Im();
                BW2PcIR[iPc][jPc] += iBW.Im() * jBW.Re();
                BW2PcRI[iPc][jPc] += iBW.Re() * jBW.Im();
                //        std::cout << "wmz debug smear BW2PcRR : " << iPc << " " << jPc << "  " <<
                //        BW2PcRR[iPc][jPc]<< std::endl; std::cout << "wmz debug smear BW2PcII : "
                //        << iPc << " " << jPc << "  " << BW2PcII[iPc][jPc]<< std::endl; std::cout
                //        << "wmz debug smear BW2PcIR : " << iPc << " " << jPc << "  " <<
                //        BW2PcIR[iPc][jPc]<< std::endl; std::cout << "wmz debug smear BW2PcRI : "
                //        << iPc << " " << jPc << "  " << BW2PcRI[iPc][jPc]<< std::endl;
                jPc++;
            }
            iPc++;
        }
    }

    //  float totalA = H[0][0][0].Rho2() + H[0][0][1].Rho2()
    //    + H[0][1][0].Rho2() + H[0][1][1].Rho2()
    //    + H[1][0][0].Rho2() + H[1][0][1].Rho2()
    //    + H[1][1][0].Rho2() + H[1][1][1].Rho2();

    float totalA = 0.;
    TComplex Amp1L;
    TComplex Amp1Pc;
    for (int k = 0; k <= 1; ++k) {
        for (int i = 0; i <= 1; ++i) {
            for (int j = 0; j <= 1; ++j) {
                totalA += H_L_Zcs[i][j][k].Rho2();
                //        std::cout << "wmz debug smear L* part: " << totalA << std::endl;
                int iPc = 0;
                while (iPc < NZ) {
                    Amp1Pc = BW1Pc[iPc] * HZ[iPc][i][j][k];
                    Amp1L = H_L_Zcs[i][j][k];
                    totalA += 2 * (Amp1Pc.Re() * Amp1L.Re() + Amp1Pc.Im() * Amp1L.Im());
                    //                std::cout << "wmz debug smear L* Z interference: " << totalA
                    //                << std::endl;
                    int jPc = 0;
                    while (jPc < NZ) {
                        totalA += (BW2PcRR[iPc][jPc] + BW2PcII[iPc][jPc]) *
                                      (HZ[iPc][i][j][k].Re() * HZ[jPc][i][j][k].Re() +
                                       HZ[iPc][i][j][k].Im() * HZ[jPc][i][j][k].Im()) +
                                  (BW2PcIR[iPc][jPc] - BW2PcRI[iPc][jPc]) *
                                      (HZ[iPc][i][j][k].Re() * HZ[jPc][i][j][k].Im() -
                                       HZ[iPc][i][j][k].Im() * HZ[jPc][i][j][k].Re());
                        //                        std::cout << "wmz debug smear Z Z interference: "
                        //                        << BW2PcRR[iPc][jPc] << "   " << BW2PcII[iPc][jPc]
                        //                        << "  " <<
                        //                        HZ[iPc][i][j][k].Re()*HZ[jPc][i][j][k].Re()+HZ[iPc][i][j][k].Im()*HZ[jPc][i][j][k].Im()
                        //                        << "   " << BW2PcIR[iPc][jPc] << "  " <<
                        //                        BW2PcRI[iPc][jPc] << "    " <<
                        //                        HZ[iPc][i][j][k].Re()*HZ[jPc][i][j][k].Im()-HZ[iPc][i][j][k].Im()*HZ[jPc][i][j][k].Re()
                        //                        << std::endl;
                        jPc++;
                    }

                    iPc++;
                }
            }
        }
    }
    //  std::cout << "wmz debug smear " << totalA << std::endl;
    return totalA;
}

Double_t RooDalitzAmplitude::GetAmp2s(Jpsihh_dlz &dlz, Amp_dlz *tnew, bool method1) const {
    TComplex H[2][2][2]; // delhelmu=+/-1,hel0=+/-1/2,hel3=+/-1/2
    for (int i = 0; i <= 1; ++i) {
        for (int j = 0; j <= 1; ++j) {
            for (int k = 0; k <= 1; ++k) {
                H[i][j][k] = TComplex(0, 0);
            }
        }
    }

    float re_i, im_i;
    //  float hel0, hel3;
    //  int delhelmu;
    float S;
    float mppi(dlz.mppi);
    int S2, LR;
    int type;
    TComplex RM;
    TComplex ampCoff, AIndep;
    float Bterm;
    int ir(0);
    int isp(0);
    int splcount(0); // not very good as L* and Z are different syst.
    TComplex tp, tpz;
    while (ir < NR) {

        S2 = (int)(_paraList[ir * nset + SPIN]);
        S = (float)S2 / 2.;

        float m0 = _paraList[ir * nset + MASS];
        float g0 = _paraList[ir * nset + WIDTH];

        LR = (int)(_paraList[ir * nset + LRESON]);
        type = (int)(_paraList[ir * nset + TYPE]);
        //(-1)*(-1)^LR = P_Ln
        switch (type) {
        case BREITWIGNER: {
            BW_AMP(m0, g0, mppi, LR, re_i, im_i);
            break;
        }
        case FLATTE: {
            // need to update
            BW_AMP(m0, g0, mppi, LR, re_i, im_i, 1. / (1. + 0.37));
            break;
        }
            // Bterm = BTerm(S, mppi, m0);
        case REVISEDKMATRIX: {
            Revised_KMAMP(mppi, ir, 0, NR, re_i, im_i, 0);
            break;
        }
        case MODELINDEPENDENT: { // for mhh only
            ModelIndependentWave3(&_paraSpline[splcount], mppi, re_i, im_i);
            // bug
            //         spline((double)mppi,re_i,im_i);
            m0 = -0.5; // 4.1163770;
            splcount += 9 * NUMSP;
            break;
        }
        }
        Bterm = BTerm(S, mppi, m0);

        RM = TComplex((double)re_i, (double)im_i) * (double)Bterm;
        //    if(type==MODELINDEPENDENT) std::cout << "ZLM " << mppi << " " << RM.Rho2() <<
        //    std::endl;
        for (int i = 0; i <= 1; ++i) { // delmu
            //      delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                //  hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    //    hel3 = (k==0) ? -0.5: 0.5;
                    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
                    for (int m = 0; m < 6; ++m) {

                        if (fabs(S - 0.5) < 1e-10 && m >= 4) {
                            if (method1) {
                                tnew->ARe[ir][i][j][k][m] = 0.0;
                                tnew->AIm[ir][i][j][k][m] = 0.0;
                            }
                            continue;
                        }
                        //      hel1 = (float)Hel1Two[m]/2.;
                        //      hel2 = Hel2[m];
                        ampCoff = amp[ir][k][m];
                        tp = ((double)dlz.DL[(S2 - 1) / 2][k][m]) *
                             TComplex((double)dlz.ARe[i][j][m], (double)dlz.AIm[i][j][m]) * RM;
                        if (method1) {
                            tnew->ARe[ir][i][j][k][m] = tp.Re();
                            tnew->AIm[ir][i][j][k][m] = tp.Im();
                        }
                        if ((ampCoff.Rho2()) < 1e-10)
                            continue;
                        H[i][j][k] += tp * ampCoff;
                    }
                }
            }
        }
        ir++;
    }

    // Z part
    int irZ(0);
    float help;
    float mjpsip(dlz.mjpsip);
    // kMatrix..
    std::vector<TComplex> AKM[4];
    AKM[0].push_back(0);
    AKM[1].push_back(0);
    AKM[2].push_back(0);
    AKM[3].push_back(0);
    int ikmcount[] = {0, 0, 0, 0};
    while (irZ < NZ) {
        S2 = (int)(_paraList[ir * nset + SPIN]);
        S = (float)S2 / 2.;

        float m0 = _paraList[ir * nset + MASS];
        float g0 = _paraList[ir * nset + WIDTH];
        LR = (int)(_paraList[ir * nset + LRESON]);
        type = (int)(_paraList[ir * nset + TYPE]);
        switch (type) {
        case MODELINDEPENDENT: {
            ModelIndependentWave(&_paraSpline[splcount], mjpsip, re_i, im_i);
            // Bterm = BTermZ(S, mjpsip,-1000);
            m0 = -0.5;
            splcount += 9 * NUMSPZ;
            break;
        }
        case BREITWIGNER: {
            BW_AMPZ(m0, g0, mjpsip, LR, re_i, im_i);
            break;
        }
        case REVISEDKMATRIX: {
            Revised_KMAMP(mjpsip, ir, NR, NR + NZ, re_i, im_i, 1);
            break;
        }
        case TRIANGLE: {
            GetCusp_AMP(m0, g0, mjpsip, re_i, im_i);
            break;
        }
        case KMATRIX: {
            int ik(0);
            if (S2 == 3)
                ik = 1;
            if (LR > 0)
                ik += 2;
            if (AKM[ik][0].Rho2() < 1e-10) {
                //        KMatrix(mjpsip, S2, -1, _galpha[ik], _fscat[ik], AKM[ik]);
                KMatrix(mjpsip, S2, ((LR > 0) ? 1 : -1), _galpha[ik], _fscat[ik], AKM[ik]);
            }
            re_i = AKM[ik][ikmcount[ik]].Re();
            im_i = AKM[ik][ikmcount[ik]].Im();
            ikmcount[ik]++;
            break;
        }
        }
        Bterm = BTermZ(S, mjpsip, m0);
        RM = TComplex((double)re_i, (double)im_i) * (double)Bterm;
        //      dlz.defed[ir] = true;
        // Rj BW here
        for (int i = 0; i <= 1; ++i) { // delmu
            // delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                // hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    // hel3 = (k==0) ? -0.5: 0.5;
                    // there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2,
                    // help=+/-1/2
                    int m(0);
                    for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                        for (int ihz = 0; ihz <= 1; ++ihz) {
                            //   helZ = (ihz==0) ? -0.5: 0.5;
                            for (int ihp = 0; ihp <= 1; ++ihp) {
                                help = (ihp == 0) ? -0.5 : 0.5;
                                if (fabs((float)helpsi - help) > S) {
                                    if (method1) {
                                        tnew->AZRe[irZ][i][j][k][m] = 0.0;
                                        tnew->AZIm[irZ][i][j][k][m] = 0.0;
                                    }
                                    m++;
                                    continue;
                                }
                                ampCoff = ampZ[irZ][k][m];
                                tpz =
                                    ((double)dlz.DZ[(S2 - 1) / 2][k][m]) *
                                    TComplex((double)dlz.AZRe[i][j][m], (double)dlz.AZIm[i][j][m]) *
                                    RM;
                                if (method1) {
                                    tnew->AZRe[irZ][i][j][k][m] = tpz.Re();
                                    tnew->AZIm[irZ][i][j][k][m] = tpz.Im();
                                }
                                if ((ampCoff.Rho2()) < 1e-10) {
                                    m++;
                                    continue;
                                }

                                H[i][j][k] += tpz * ampCoff;
                                //* TComplex(dlz.RM[ir][0],dlz.RM[ir][1])
                                //* ((float)dlz.DZ[((S2-1)/2)][k][m]) ;//AIndep;
                                m++;
                            }
                        }
                    }
                }
            }
        }
        ir++;
        irZ++;
    }

    // Zcs part
    int irX(0);
    //  float help;
    float mjpsipi(dlz.mjpsipi);

    while (irX < NX) {
        S2 = (int)(_paraList[ir * nset + 2]);
        S = (float)S2 / 2.;

        float m0 = _paraList[ir * nset];
        float g0 = _paraList[ir * nset + 1];

        LR = (int)(_paraList[ir * nset + 3]);

        type = (int)(_paraList[ir * nset + 4]); // Only consider BW at this moment
                                                // Mass-dependent term
        BW_AMPX(m0, g0, mjpsipi, LR, re_i, im_i);
        Bterm = BTermX(S, mjpsipi, m0);
        RM = TComplex((double)re_i, (double)im_i) * (double)Bterm;
        // Angular-dependent term
        for (int i = 0; i <= 1; ++i) { // delmu
            //        delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                //          hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    //            hel3 = (k==0) ? -0.5: 0.5;
                    // there are 12 amplitudes to be added coherently //helpsi,0,+/-1,
                    // helX,help+/-1/2, help=+/-1/2
                    int m(0);
                    for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                        if (abs(helpsi) > S)
                            continue;
                        for (int ihp = 0; ihp <= 1; ++ihp) {
                            help = (ihp == 0) ? -0.5 : 0.5;
                            for (int ihz = 0; ihz <= 1; ++ihz) {
                                float helZ = (ihz == 0) ? help - 0.5 : help + 0.5;
                                if (fabs(helZ) > S)
                                    continue;
                                ampCoff = ampX[irX][k][m];
                                tpz =
                                    ((double)dlz.DX[(S2) / 2][k][m]) *
                                    TComplex((double)dlz.AXRe[i][j][m], (double)dlz.AXIm[i][j][m]) *
                                    RM;
                                if ((ampCoff.Rho2()) < 1e-10) {
                                    m++;
                                    continue;
                                }

                                H[i][j][k] += ampCoff * tpz;
                                m++;
                            }
                        }
                    }
                }
            }
        }
        ir++;
        irX++;
    }

    double totalA = H[0][0][0].Rho2() + H[0][0][1].Rho2() + H[0][1][0].Rho2() + H[0][1][1].Rho2() +
                    H[1][0][0].Rho2() + H[1][0][1].Rho2() + H[1][1][0].Rho2() + H[1][1][1].Rho2();

    return totalA;
}

Double_t RooDalitzAmplitude::GetAmp2sForInt_SMR(
    Jpsihh_dlz &dlz, int index, int group, Amp_dlz *tnew, bool method1, bool finebinning) const {
    //  TComplex H[2][2][2];//delhelmu=+/-1,hel0=+/-1/2,hel3=+/-1/2
    //  std::cout << "wmz debug start Int_SMEAR" << std::endl;

    TComplex H_L_Zcs[2][2][2];
    TComplex HZ[MYZN][2][2][2]; // at most 10 Pc
    TComplex BW1Pc[MYZN];       // at most MYZN Pc
    TComplex BWPc_tmp[MYZN];    // at most MYZN Pc
    float BW2PcRR[MYZN][MYZN];
    float BW2PcII[MYZN][MYZN];
    float BW2PcIR[MYZN][MYZN];
    float BW2PcRI[MYZN][MYZN];

    for (int i = 0; i <= 1; ++i) {
        for (int j = 0; j <= 1; ++j) {
            for (int k = 0; k <= 1; ++k) {
                H_L_Zcs[i][j][k] = TComplex(0, 0);
                for (int iPc = 0; iPc < MYZN; ++iPc) {
                    HZ[iPc][i][j][k] = TComplex(0, 0);
                }
            }
        }
    }
    for (int iPc = 0; iPc < MYZN; ++iPc) {
        BW1Pc[iPc] = TComplex(0.0, 0.0);
        BWPc_tmp[iPc] = TComplex(0.0, 0.0);
        for (int jPc = 0; jPc < MYZN; ++jPc) {
            BW2PcRR[iPc][jPc] = 0.;
            BW2PcII[iPc][jPc] = 0.;
            BW2PcIR[iPc][jPc] = 0.;
            BW2PcRI[iPc][jPc] = 0.;
        }
    }

    float re_i, im_i;
    //  float hel0, hel3;
    //  int delhelmu;
    float S;
    float mppi(dlz.mppi);
    int S2, LR;
    int type;
    int iS2, iLR;
    float iS;
    int itype;
    TComplex RM;
    TComplex ampCoff, AIndep;
    TComplex iBW;
    TComplex jBW;
    float iBterm;
    float Bterm;
    float im0, ig0;
    int ir(0);
    int isp(0);
    int splcount(0); // not very good as L* and Z are different syst.
    TComplex tp, tpz;
    //  std::cout << "wmz debug start Lst" << std::endl;
    while (ir < NR) {
        S2 = (int)(_paraList[ir * nset + SPIN]);
        S = (float)S2 / 2.;

        float m0 = _paraList[ir * nset + MASS];
        float g0 = _paraList[ir * nset + WIDTH];

        LR = (int)(_paraList[ir * nset + LRESON]);
        type = (int)(_paraList[ir * nset + TYPE]);
        if ((group != 1) && !(group == 0 && ir == index) && (group != 3 && group != 4)) {
            ir++;
            if (type == MODELINDEPENDENT)
                splcount += 9 * NUMSP;
            ;
            continue;
        }
        if ((group == 3) && ((LR + S2) != index)) {
            ir++;
            if (type == MODELINDEPENDENT)
                splcount += 9 * NUMSP;
            ;
            continue;
        }

        switch (type) {
        case BREITWIGNER:

        {
            BW_AMP(m0, g0, mppi, LR, re_i, im_i);
            break;
        }
        case FLATTE: {
            // need to update
            BW_AMP(m0, g0, mppi, LR, re_i, im_i, 1. / (1. + 0.37));
            break;
        }
        case REVISEDKMATRIX: {
            Revised_KMAMP(mppi, ir, 0, NR, re_i, im_i, 0);
            break;
        }
        case MODELINDEPENDENT: { // for mhh only
            ModelIndependentWave3(&_paraSpline[splcount], mppi, re_i, im_i);
            // a bug here
            //        spline((double)mppi,re_i,im_i);

            m0 = -0.5; // 4.1163770;
            splcount += 9 * NUMSP;
            break;
        }
        }
        Bterm = BTerm(S, mppi, m0);

        RM = TComplex((double)re_i, (double)im_i) * (double)Bterm;
        //    if(type==MODELINDEPENDENT) std::cout << "ZLM " << mppi << " " << RM.Rho2() <<
        //    std::endl;
        for (int i = 0; i <= 1; ++i) { // delmu
            //      delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                //      hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    //      hel3 = (k==0) ? -0.5: 0.5;
                    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
                    for (int m = 0; m < 6; ++m) {

                        if (fabs(S - 0.5) < 1e-10 && m >= 4) {
                            if (method1) {
                                tnew->ARe[ir][i][j][k][m] = 0.0;
                                tnew->AIm[ir][i][j][k][m] = 0.0;
                            }
                            continue;
                        }

                        ampCoff = amp[ir][k][m];
                        tp = ((double)dlz.DL[(S2 - 1) / 2][k][m]) *
                             TComplex((double)dlz.ARe[i][j][m], (double)dlz.AIm[i][j][m]) * RM;
                        if (method1) {
                            tnew->ARe[ir][i][j][k][m] = tp.Re();
                            tnew->AIm[ir][i][j][k][m] = tp.Im();
                        }
                        if ((ampCoff.Rho2()) < 1e-10)
                            continue;
                        H_L_Zcs[i][j][k] += tp * ampCoff;
                    }
                }
            }
        }
        ir++;
    }

    // Z part
    int irZ(0);
    float help;
    float mjpsip(dlz.mjpsip);
    //  std::vector<TComplex> AKM[4];
    //  AKM[0].push_back(0);
    //  AKM[1].push_back(0);
    //  AKM[2].push_back(0);
    //  AKM[3].push_back(0);
    //  int ikmcount[] = {0, 0,0, 0};
    //  std::cout << "wmz debug start Pc" << std::endl;
    while (irZ < NZ) {
        S2 = (int)(_paraList[ir * nset + SPIN]);
        S = (float)S2 / 2.;

        float m0 = _paraList[ir * nset + MASS];
        float g0 = _paraList[ir * nset + WIDTH];

        LR = (int)(_paraList[ir * nset + LRESON]);

        type = (int)(_paraList[ir * nset + TYPE]);
        if ((group != 2) && !(group == 0 && ir == index) && (group != 5)) {
            ir++;
            irZ++;
            continue;
        }
        if ((group == 5) && ((LR + 2 * S2) != index)) {
            ir++;
            irZ++;
            continue;
        }

        // Rj BW here
        for (int i = 0; i <= 1; ++i) { // delmu
            // delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                // hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    // hel3 = (k==0) ? -0.5: 0.5;
                    // there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2,
                    // help=+/-1/2
                    int m(0);
                    for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                        for (int ihz = 0; ihz <= 1; ++ihz) {
                            //   helZ = (ihz==0) ? -0.5: 0.5;
                            for (int ihp = 0; ihp <= 1; ++ihp) {
                                help = (ihp == 0) ? -0.5 : 0.5;
                                if (fabs((float)helpsi - help) > S) {
                                    if (method1) {
                                        tnew->AZRe[irZ][i][j][k][m] = 0.0;
                                        tnew->AZIm[irZ][i][j][k][m] = 0.0;
                                    }
                                    m++;
                                    continue;
                                }
                                ampCoff = ampZ[irZ][k][m];
                                tpz =
                                    ((double)dlz.DZ[(S2 - 1) / 2][k][m]) *
                                    TComplex((double)dlz.AZRe[i][j][m], (double)dlz.AZIm[i][j][m]);
                                //*TComplex(dlz.AZRe[i][j][m], dlz.AZIm[i][j][m]) * RM;
                                if (method1) {
                                    tnew->AZRe[irZ][i][j][k][m] = tpz.Re();
                                    tnew->AZIm[irZ][i][j][k][m] = tpz.Im();
                                }
                                if ((ampCoff.Rho2()) < 1e-10) {
                                    m++;
                                    continue;
                                }

                                HZ[irZ][i][j][k] += tpz * ampCoff;
                                //* TComplex(dlz.RM[ir][0],dlz.RM[ir][1])
                                //* ((float)dlz.DZ[((S2-1)/2)][k][m]) ;//AIndep;
                                m++;
                            }
                        }
                    }
                }
            }
        }
        ir++;
        irZ++;
    }

    // Zcs part
    int irX(0);
    //  float help;
    float mjpsipi(dlz.mjpsipi);

    //  std::cout << "wmz debug start Zcs" << std::endl;
    while (irX < NX) {
        if ((group != 10) && !(group == 0 && ir == index)) {
            ir++;
            irX++;
            continue;
        } // 10 for Zcs contribution
        S2 = (int)(_paraList[ir * nset + SPIN]);
        S = (float)S2 / 2.;

        float m0 = _paraList[ir * nset + MASS];
        float g0 = _paraList[ir * nset + WIDTH];

        LR = (int)(_paraList[ir * nset + LRESON]);

        type = (int)(_paraList[ir * nset + TYPE]); // Only consider BW at this moment
                                                   // Mass-dependent term
        BW_AMPX(m0, g0, mjpsipi, LR, re_i, im_i);
        Bterm = BTermX(S, mjpsipi, m0);
        RM = TComplex((double)re_i, (double)im_i) * (double)Bterm;

        // Angular-dependent term
        for (int i = 0; i <= 1; ++i) { // delmu
            //        delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                //          hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    //            hel3 = (k==0) ? -0.5: 0.5;
                    // there are 12 amplitudes to be added coherently //helpsi,0,+/-1,
                    // helX,help+/-1/2, help=+/-1/2
                    int m(0);
                    for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                        if (abs(helpsi) > S)
                            continue;
                        for (int ihp = 0; ihp <= 1; ++ihp) {
                            help = (ihp == 0) ? -0.5 : 0.5;
                            for (int ihz = 0; ihz <= 1; ++ihz) {
                                float helZ = (ihz == 0) ? help - 0.5 : help + 0.5;
                                if (fabs(helZ) > S)
                                    continue;
                                ampCoff = ampX[irX][k][m];
                                tpz =
                                    ((double)dlz.DX[(S2) / 2][k][m]) *
                                    TComplex((double)dlz.AXRe[i][j][m], (double)dlz.AXIm[i][j][m]) *
                                    RM;
                                if ((ampCoff.Rho2()) < 1e-10) {
                                    m++;
                                    continue;
                                }

                                H_L_Zcs[i][j][k] += ampCoff * tpz;
                                m++;
                            }
                        }
                    }
                }
            }
        }
        ir++;
        irX++;
    }

    float mres = _mres0 + mjpsip * (_mres1 + mjpsip * _mres2);
#ifdef RESPLUS
    mres = mres * 1.1;
#endif
#ifdef RESMINUS
    mres = mres * 0.9;
#endif
    int _smear_nbins_tmp = SMEAR_NBINS;
    if (finebinning) {
        _smear_nbins_tmp = SMEAR_FINE_NBINS;
    }

    float smear_binwidth = mres * _smear_nsigmas * 2 / _smear_nbins_tmp;
    float mjpsip_smear;
    int iPc;
    int jPc;
    int iir;
    int splcount0 = splcount;
    //  std::cout << "wmz debug start smear" << std::endl;
    for (int smear_ibin = 0; smear_ibin < _smear_nbins_tmp; smear_ibin++) {
        splcount = splcount0;
        iPc = 0;
        jPc = 0;
        iir = 0;
        mjpsip_smear = -_smear_nsigmas * mres + smear_binwidth * smear_ibin + smear_binwidth * 0.5;
        float weight_smear = TMath::Gaus(mjpsip_smear, 0, mres, true) * smear_binwidth;

        std::vector<TComplex> AKM[4];
        AKM[0].push_back(0);
        AKM[1].push_back(0);
        AKM[2].push_back(0);
        AKM[3].push_back(0);
        int ikmcount[] = {0, 0, 0, 0};

        while (iPc < NZ) {
            iir = NR + iPc;
            im0 = _paraList[iir * nset + MASS];
            ig0 = _paraList[iir * nset + WIDTH];
            iS2 = (int)(_paraList[iir * nset + SPIN]);
            iLR = (int)(_paraList[iir * nset + LRESON]);
            itype = (int)(_paraList[iir * nset + TYPE]);
            iS = (float)iS2 / 2.;
            //       int isp(0);
            if ((group != 2) && !(group == 0 && iir == index) && (group != 5)) {
                iPc++;
                if (type == MODELINDEPENDENT)
                    splcount += 9 * NUMSPZ;
                if (type == KMATRIX) {
                    int ik(0);
                    if (iS2 == 3)
                        ik = 1;
                    if (iLR > 0)
                        ik += 2;
                    ikmcount[ik]++;
                }
                //               if(itype==3) isp++;
                BWPc_tmp[iPc] = TComplex(0., 0., false);
                continue;
            }
            if ((group == 5) && ((iLR + 2 * iS2) != index)) {
                iPc++;
                if (type == MODELINDEPENDENT)
                    splcount += 9 * NUMSPZ;
                if (type == KMATRIX) {
                    int ik(0);
                    if (iS2 == 3)
                        ik = 1;
                    if (iLR > 0)
                        ik += 2;
                    ikmcount[ik]++;
                }
                BWPc_tmp[iPc] = TComplex(0., 0., false);
                continue;
            }
            switch (itype) {

                /*       case MODELINDEPENDENT:
                        {
                         ModelIndependentWave(&_paraSpline[isp*NUMSP*2], mjpsip+mjpsip_smear,re_i,
                   im_i);
                         //Bterm = BTermZ(S, mjpsip,-1000);
                         im0 = -1000;
                         isp ++;
                         break;
                        }*/
            case MODELINDEPENDENT: {
                ModelIndependentWave(&_paraSpline[splcount], mjpsip + mjpsip_smear, re_i, im_i);
                // Bterm = BTermZ(S, mjpsip,-1000);
                im0 = -0.5;
                splcount += 9 * NUMSPZ;
                break;
            }
            case BREITWIGNER: {
                BW_AMPZ(im0, ig0, mjpsip + mjpsip_smear, iLR, re_i, im_i);
                break;
            }
            case REVISEDKMATRIX: {
                Revised_KMAMP(mjpsip + mjpsip_smear, iir, NR, NR + NZ, re_i, im_i, 1);
                break;
            }
            case TRIANGLE: {
                GetCusp_AMP(im0, ig0, mjpsip + mjpsip_smear, re_i, im_i);
                break;
            }
            case KMATRIX: {
                int ik(0);
                if (iS2 == 3)
                    ik = 1;
                if (iLR > 0)
                    ik += 2;
                //                 std::cout << "wmz debug AKM[ik][0]: " << AKM[ik][0] << std::endl;
                //                 std::cout << "wmz debug AKM before: " << AKM[ik][ikmcount[ik]]<<
                //                 "   " << mjpsip << "   " << mjpsip_smear << "   " <<
                //                 ikmcount[ik]<<  "   "  << iPc <<std::endl;
                if (AKM[ik][0].Rho2() < 1e-10) {
                    //                       KMatrix(mjpsip + mjpsip_smear, iS2, -1, _galpha[ik],
                    //                       _fscat[ik], AKM[ik]);
                    KMatrix(mjpsip + mjpsip_smear,
                            iS2,
                            ((iLR > 0) ? 1 : -1),
                            _galpha[ik],
                            _fscat[ik],
                            AKM[ik]);
                }
                re_i = AKM[ik][ikmcount[ik]].Re();
                im_i = AKM[ik][ikmcount[ik]].Im();
                //                 std::cout << "wmz debug AKM: " << AKM[ik][ikmcount[ik]]<< "   "
                //                 << mjpsip << "   " << mjpsip_smear << std::endl;
                ikmcount[ik]++;

                break;
            }
            }
            iBterm = BTermZ(iS, mjpsip + mjpsip_smear, im0) * weight_smear;
            //       RM = TComplex(re_i,im_i)*Bterm;
            BWPc_tmp[iPc] = TComplex((double)re_i * iBterm, (double)im_i * iBterm, false);
            BW1Pc[iPc] += TComplex((double)re_i * iBterm, (double)im_i * iBterm, false);
            //       std::cout << "wmz debug BW1Pc: " << re_i << "  " << im_i << "   " << BTermZ(iS,
            //       mjpsip+mjpsip_smear, im0) << "  " << weight_smear << std::endl;
            iPc++;
        }

        iPc = 0;
        while (iPc < NZ) {
            jPc = 0;
            while (jPc < NZ) {
                iBW = BWPc_tmp[iPc];
                jBW = 1. / weight_smear * BWPc_tmp[jPc];
                BW2PcRR[iPc][jPc] += iBW.Re() * jBW.Re(); // weight involved in iBW, float counted.
                BW2PcII[iPc][jPc] += iBW.Im() * jBW.Im();
                BW2PcIR[iPc][jPc] += iBW.Im() * jBW.Re();
                BW2PcRI[iPc][jPc] += iBW.Re() * jBW.Im();
                jPc++;
            }
            iPc++;
        }
    }
    float totalA = 0.;
    TComplex Amp1L;
    TComplex Amp1Pc;
    for (int k = 0; k <= 1; ++k) {
        for (int i = 0; i <= 1; ++i) {
            for (int j = 0; j <= 1; ++j) {
                totalA += H_L_Zcs[i][j][k].Rho2();
                //        std::cout << "wmz debug smear L* part: " << totalA << std::endl;
                int iPc = 0;
                while (iPc < NZ) {
                    Amp1Pc = BW1Pc[iPc] * HZ[iPc][i][j][k];
                    Amp1L = H_L_Zcs[i][j][k];
                    totalA += 2 * (Amp1Pc.Re() * Amp1L.Re() + Amp1Pc.Im() * Amp1L.Im());
                    //                std::cout << "wmz debug smear L* Z interference: " <<
                    //                Amp1Pc.Re() << " " << Amp1L.Re() << "  " << Amp1Pc.Im() << "
                    //                " << Amp1L.Im() << "  " << HZ[iPc][i][j][k] << "   " <<
                    //                H_L_Zcs[i][j][k] << std::endl;
                    int jPc = 0;
                    while (jPc < NZ) {
                        totalA += (BW2PcRR[iPc][jPc] + BW2PcII[iPc][jPc]) *
                                      (HZ[iPc][i][j][k].Re() * HZ[jPc][i][j][k].Re() +
                                       HZ[iPc][i][j][k].Im() * HZ[jPc][i][j][k].Im()) +
                                  (BW2PcIR[iPc][jPc] - BW2PcRI[iPc][jPc]) *
                                      (HZ[iPc][i][j][k].Re() * HZ[jPc][i][j][k].Im() -
                                       HZ[iPc][i][j][k].Im() * HZ[jPc][i][j][k].Re());
                        //                        std::cout << "wmz debug smear Z Z interference: "
                        //                        << BW2PcRR[iPc][jPc] << "   " << BW2PcII[iPc][jPc]
                        //                        << "  " <<
                        //                        HZ[iPc][i][j][k].Re()*HZ[jPc][i][j][k].Re()+HZ[iPc][i][j][k].Im()*HZ[jPc][i][j][k].Im()
                        //                        << "   " << BW2PcIR[iPc][jPc] << "  " <<
                        //                        BW2PcRI[iPc][jPc] << "    " <<
                        //                        HZ[iPc][i][j][k].Re()*HZ[jPc][i][j][k].Im()-HZ[iPc][i][j][k].Im()*HZ[jPc][i][j][k].Re()
                        //                        << std::endl;
                        jPc++;
                    }

                    iPc++;
                }
            }
        }
    }
    //  std::cout << "wmz debug smear " << totalA << std::endl;
    return totalA;
}

Float_t RooDalitzAmplitude::KMLineshape(float mjpsip, int S2, int parity, int ikmcount) const {
    // Z part
    // kMatrix..
    std::vector<TComplex> AKM;
    AKM.push_back(0);
    int ik(0);
    if (S2 == 3)
        ik = 1;
    if (parity > 0)
        ik += 2;
    KMatrix(mjpsip, S2, parity, _galpha[ik], _fscat[ik], AKM);
    return AKM[ikmcount].Rho2();
}

Float_t RooDalitzAmplitude::KMLineshapesmear(float mjpsip, int S2, int parity, int ikmcount) const {
    float mres = _mres0 + mjpsip * (_mres1 + mjpsip * _mres2);
#ifdef SMARTBINNING
    float weight_smear = 1. / SMEAR_FINE_NBINS;
#else
    float smear_binwidth = mres * _smear_nsigmas * 2 / SMEAR_FINE_NBINS;
#endif
    float mjpsip_smear;
    double sum(0);
    for (int smear_ibin = 0; smear_ibin < SMEAR_FINE_NBINS; smear_ibin++) {
#ifdef SMARTBINNING
        mjpsip_smear = _smear_fine_binning_scheme[smear_ibin] * mres;
#else
        mjpsip_smear = -_smear_nsigmas * mres + smear_binwidth * smear_ibin + smear_binwidth * 0.5f;
        float weight_smear = TMath::Gaus(mjpsip_smear, 0, mres, true) * smear_binwidth;
#endif

        sum += KMLineshape(mjpsip + mjpsip_smear, S2, parity, ikmcount) * weight_smear;
    }

    return sum;
}

// rough
Float_t
RooDalitzAmplitude::KMLineshapesmear1(float mjpsip, int S2, int parity, int ikmcount) const {
    float mres = _mres0 + mjpsip * (_mres1 + mjpsip * _mres2);
#ifdef SMARTBINNING
    float weight_smear = 1. / SMEAR_NBINS;
#else
    float smear_binwidth = mres * _smear_nsigmas * 2 / SMEAR_NBINS;
#endif
    float mjpsip_smear;
    double sum(0);
    for (int smear_ibin = 0; smear_ibin < SMEAR_NBINS; smear_ibin++) {
#ifdef SMARTBINNING
        mjpsip_smear = _smear_binning_scheme[smear_ibin] * mres;
#else
        mjpsip_smear = -_smear_nsigmas * mres + smear_binwidth * smear_ibin + smear_binwidth * 0.5f;
        float weight_smear = TMath::Gaus(mjpsip_smear, 0, mres, true) * smear_binwidth;
#endif

        sum += KMLineshape(mjpsip + mjpsip_smear, S2, parity, ikmcount) * weight_smear;
    }

    return sum;
}

// only do for 4457 in m0+/-range MeV, using nbin; //can be optimized. Default nbin = 500, range
// = 2.5, m0=4457
Float_t RooDalitzAmplitude::CalFWHM(float m0, int nbin, float range) const {
    //  float nbin=50000;
    //  float nbin=500;
    float xm1 = (m0 - range) / 1000.;
    float xm2 = (m0 + range) / 1000.;
    float wbin = 2. * range / 1000 / nbin;
    float xm = xm1 + wbin * 0.5;
    float pmax(-100), ptmp;
    int imax(0);
    std::vector<float> p;
    for (int i = 0; i < nbin; ++i) {
        ptmp = KMLineshape(xm, 1, -1, 0);
        p.push_back(ptmp);
        if (ptmp > pmax) {
            pmax = ptmp;
            imax = i;
        }
        xm += wbin;
    }
    pmax *= 0.5;
    int lh(imax), rh(imax);
    while (rh < nbin - 1) {
        if (p[rh] > pmax && p[rh + 1] <= pmax)
            break;
        rh++;
    }
    while (lh > 0) {
        if (p[lh] > pmax && p[lh - 1] <= pmax)
            break;
        lh--;
    }
    //        std::cout << "wmz debug FWHM = "  << 1000.*wbin*(rh-lh) << std::endl;
    return 1000. * wbin * (rh - lh);
}

// group = 0 for each component, = 1 Lambda, = 2 Z, =3 for Lambda wave
Double_t RooDalitzAmplitude::GetAmp2sForInt(Jpsihh_dlz &dlz, int index, int group) const {

    TComplex H[2][2][2]; // delhelmu=+/-1,hel0=+/-1/2,hel3=+/-1/2
    for (int i = 0; i <= 1; ++i) {
        for (int j = 0; j <= 1; ++j) {
            for (int k = 0; k <= 1; ++k) {
                H[i][j][k] = TComplex(0, 0);
            }
        }
    }

    float re_i, im_i;
    float hel3, hel0;
    int delhelmu;
    float S, hel1, hel2;
    float mppi(dlz.mppi);
    int S2, LR;
    TComplex RM;
    TComplex ampCoff, AIndep;
    float Bterm;
    int ir(0), isp(0);
    int splcount(0); // not very good as L* and Z are different syst.
    TIterator *coefIter = _resList->MakeIterator();
    while (RooArgList *Ires = (RooArgList *)coefIter->Next()) {
        RooArgList ires = (*Ires);
        int iressize = ires.getSize();

        int type = (int)((RooAbsReal &)ires[iressize - 3]).getVal();

        if ((group != 1) && !(group == 0 && ir == index) && (group != 3 && group != 4)) {
            ir++;
            if (type == MODELINDEPENDENT)
                splcount += 9 * NUMSP;
            ;
            continue;
        }

        float m0 = 0;
        float g0 = 0;
        m0 = ((RooAbsReal &)ires[iressize - 5]).getVal();
        g0 = ((RooAbsReal &)ires[iressize - 4]).getVal();
        TString m0_name = ((RooAbsReal &)ires[iressize - 5]).GetName();

        // spin; inputs is 2xspin
        int parity = (int)((RooAbsReal &)ires[iressize - 1]).getVal();
        S2 = (int)((RooAbsReal &)ires[iressize - 2]).getVal();
        S = (float)S2 / 2.;
        LR = (int)(S - 0.5);
        //(-1)*(-1)^LR = P_Ln
        if ((pow(-1, LR + 1) * parity) < 0)
            LR += 1;

        if ((group == 3) && ((LR + S2) != index)) {
            ir++;
            if (type == MODELINDEPENDENT)
                splcount += 9 * NUMSP;
            ;
            continue;
        }
        TString index_str(Form("%d", index));
        if ((group == 4) && !(m0_name.Contains(index_str))) {
            ir++;
            if (type == MODELINDEPENDENT)
                splcount += 9 * NUMSP;
            ;
            continue;
        }
        // float paritypart;
        switch (type) {
        case BREITWIGNER: {
            BW_AMP(m0, g0, mppi, LR, re_i, im_i);
            break;
        }
        case FLATTE: {
            // need to update
            BW_AMP(m0, g0, mppi, LR, re_i, im_i, 1. / (1. + 0.37));
            break;
        }
            // Bterm = BTerm(S, mppi, m0);
        case REVISEDKMATRIX: {
            Revised_KMAMP(mppi, ir, 0, NR, re_i, im_i, 0);
            break;
        }
        case MODELINDEPENDENT: { // for mhh only
            ModelIndependentWave3(&_paraSpline[splcount], mppi, re_i, im_i);
            //        spline((double)mppi,re_i,im_i);
            m0 = -0.5; // 4.1163770;
            splcount += 9 * NUMSP;
            break;
        }
        }
        Bterm = BTerm(S, mppi, m0);

        //    Bterm = BTerm(S, mppi, m0);
        //      dlz.defed[ir] = true;
        RM = TComplex((double)re_i, (double)im_i) * (double)Bterm;
        //    if(type==MODELINDEPENDENT) std::cout << "ZLM " << mppi << " " << RM.Rho2() <<
        //    std::endl;
        for (int i = 0; i <= 1; ++i) { // delmu
            delhelmu = (i == 0) ? -1 : 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                hel0 = (j == 0) ? -0.5 : 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    hel3 = (k == 0) ? -0.5 : 0.5;
                    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
                    for (int m = 0; m < 6; ++m) {
                        // amp[ir][i][j][k][m] = 0.0;
                        if (fabs(S - 0.5) < 1e-10 && m >= 4) {
                            continue;
                        }
                        hel1 = (float)Hel1Two[m] / 2.;
                        hel2 = Hel2[m];
                        ampCoff = amp[ir][k][m];

                        if ((ampCoff.Rho2()) < 1e-10)
                            continue;
                        H[i][j][k] += ampCoff *
                                      TComplex((double)dlz.ARe[i][j][m], (double)dlz.AIm[i][j][m]) *
                                      RM * ((double)dlz.DL[(S2 - 1) / 2][k][m]);
                    }
                }
            }
        }
        ir++;
    }

    // Z part
    int irZ(0);
    float help, helZ;
    float mjpsip(dlz.mjpsip);
    // kMatrix..
    std::vector<TComplex> AKM[4];
    AKM[0].push_back(0);
    AKM[1].push_back(0);
    AKM[2].push_back(0);
    AKM[3].push_back(0);
    int ikmcount[] = {0, 0, 0, 0};

    TIterator *coefIterZ = _resListZ->MakeIterator();
    while (RooArgList *Ires = (RooArgList *)coefIterZ->Next()) {
        RooArgList ires = (*Ires);
        int iressize = ires.getSize();
        int type = (int)((RooAbsReal &)ires[iressize - 3]).getVal();
        // spin; inputs is 2xspin
        int parity = (int)((RooAbsReal &)ires[iressize - 1]).getVal();
        S2 = (int)((RooAbsReal &)ires[iressize - 2]).getVal();
        S = (float)S2 / 2.;
        LR = TMath::Max((int)(S - 1.5), 0);
        //(-1)*(-1)^LR = P_Lz
        if ((pow(-1, LR + 1) * parity) < 0)
            LR += 1;
        int ik(0);
        if (S2 == 3)
            ik = 1;
        if (LR > 0) {
            if (parity < 0)
                std::cout << "LR not match parity" << std::endl;
            ik += 2;
        }
        if ((group != 2) && !(group == 0 && ir == index) && (group != 5)) {
            ir++;
            irZ++;
            if (type == MODELINDEPENDENT)
                splcount += 9 * NUMSPZ;
            if (type == KMATRIX)
                ikmcount[ik]++;
            continue;
        }
        float m0 = 0;
        float g0 = 0;
        m0 = ((RooAbsReal &)ires[iressize - 5]).getVal();
        g0 = ((RooAbsReal &)ires[iressize - 4]).getVal();

        if ((group == 5) && ((LR + 2 * S2) != index)) {
            ir++;
            irZ++;
            if (type == MODELINDEPENDENT)
                splcount += 9 * NUMSPZ;
            if (type == KMATRIX)
                ikmcount[ik]++;
            continue;
        }

        switch (type) {
        case MODELINDEPENDENT: {
            ModelIndependentWave(&_paraSpline[splcount], mjpsip, re_i, im_i);
            m0 = -0.5;
            splcount += 9 * NUMSPZ;
            break;
        }
        case BREITWIGNER: {
            BW_AMPZ(m0, g0, mjpsip, LR, re_i, im_i);
            break;
        }
        case REVISEDKMATRIX: {
            Revised_KMAMP(mjpsip, ir, NR, NR + NZ, re_i, im_i, 1);
            break;
        }
        case TRIANGLE: {
            GetCusp_AMP(m0, g0, mjpsip, re_i, im_i);
            break;
        }
        case KMATRIX: {
            if (AKM[ik][0].Rho2() < 1e-10) {
                KMatrix(mjpsip, S2, ((LR > 0) ? 1 : -1), _galpha[ik], _fscat[ik], AKM[ik]);
                //  KMatrix(mjpsip, S2, -1, _galpha[ik], _fscat[ik], AKM[ik]);
            }
            re_i = AKM[ik][ikmcount[ik]].Re();
            im_i = AKM[ik][ikmcount[ik]].Im();
            ikmcount[ik]++;
            break;
        }
        }
        Bterm = BTermZ(S, mjpsip, m0);
        RM = TComplex((double)re_i, (double)im_i) * (double)Bterm;
        // Rj BW here
        for (int i = 0; i <= 1; ++i) { // delmu
            delhelmu = (i == 0) ? -1 : 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                hel0 = (j == 0) ? -0.5 : 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    hel3 = (k == 0) ? -0.5 : 0.5;
                    // there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2,
                    // help=+/-1/2
                    int m(0);
                    for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                        for (int ihz = 0; ihz <= 1; ++ihz) {
                            helZ = (ihz == 0) ? -0.5 : 0.5;
                            for (int ihp = 0; ihp <= 1; ++ihp) {
                                help = (ihp == 0) ? -0.5 : 0.5;
                                if (fabs((float)helpsi - help) > S) {
                                    m++;
                                    continue;
                                }
                                ampCoff = ampZ[irZ][k][m];
                                if ((ampCoff.Rho2()) < 1e-10) {
                                    m++;
                                    continue;
                                }

                                H[i][j][k] +=
                                    ampCoff *
                                    TComplex((double)dlz.AZRe[i][j][m], (double)dlz.AZIm[i][j][m]) *
                                    RM * ((double)dlz.DZ[((S2 - 1) / 2)][k][m]); // AIndep;
                                m++;
                            }
                        }
                    }
                }
            }
        }
        ir++;
        irZ++;
    }

    // Zcs part
    int irX(0);
    //  float help, helZ;
    float mjpsipi(dlz.mjpsipi);
    TIterator *coefIterX = _resListX->MakeIterator();
    while (RooArgList *Ires = (RooArgList *)coefIterX->Next()) {
        RooArgList ires = (*Ires);
        int iressize = ires.getSize();
        int type = (int)((RooAbsReal &)ires[iressize - 3]).getVal();
        if ((group != 10) && !(group == 0 && ir == index)) {
            ir++;
            irX++;
            continue;
        } // 10 for Zcs contribution
        float m0 = 0;
        float g0 = 0;
        m0 = ((RooAbsReal &)ires[iressize - 5]).getVal();
        g0 = ((RooAbsReal &)ires[iressize - 4]).getVal();
        // spin; inputs is 2xspin
        int parity = (int)((RooAbsReal &)ires[iressize - 1]).getVal();
        S2 = (int)((RooAbsReal &)ires[iressize - 2]).getVal();
        S = (float)S2 / 2.;
        LR = TMath::Max(abs((int)(S - 1)), 0);
        if ((pow(-1, LR) * parity) < 0)
            LR += 1;
        BW_AMPX(m0, g0, mjpsipi, LR, re_i, im_i);
        Bterm = BTermX(S, mjpsipi, m0);
        RM = TComplex((double)re_i, (double)im_i) * (double)Bterm;
        for (int i = 0; i <= 1; ++i) { // delmu
            //        delhelmu = (i==0) ? -1: 1;
            for (int j = 0; j <= 1; ++j) { // hel0
                //          hel0 = (j==0) ? -0.5: 0.5;
                for (int k = 0; k <= 1; ++k) { // hel3 proton
                    //            hel3 = (k==0) ? -0.5: 0.5;
                    // there are 12 amplitudes to be added coherently //helpsi,0,+/-1,
                    // helX,help+/-1/2, help=+/-1/2
                    int m(0);
                    for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                        if (abs(helpsi) > S)
                            continue;
                        for (int ihp = 0; ihp <= 1; ++ihp) {
                            help = (ihp == 0) ? -0.5 : 0.5;
                            for (int ihz = 0; ihz <= 1; ++ihz) {
                                helZ = (ihz == 0) ? help - 0.5 : help + 0.5;
                                if (fabs(helZ) > S)
                                    continue;
                                ampCoff = ampX[irX][k][m];
                                //                  tpz = ((double)dlz.DX[(S2)/2][k][m])
                                //                                  *TComplex((double)dlz.AXRe[i][j][m],
                                //                                  (double)dlz.AXIm[i][j][m]) * RM;
                                if ((ampCoff.Rho2()) < 1e-10) {
                                    m++;
                                    continue;
                                }

                                H[i][j][k] +=
                                    ampCoff * ((double)dlz.DX[(S2) / 2][k][m]) *
                                    TComplex((double)dlz.AXRe[i][j][m], (double)dlz.AXIm[i][j][m]) *
                                    RM;
                                m++;
                            }
                        }
                    }
                }
            }
        }
        ir++;
        irX++;
    }

    double totalA = H[0][0][0].Rho2() + H[0][0][1].Rho2() + H[0][1][0].Rho2() + H[0][1][1].Rho2() +
                    H[1][0][0].Rho2() + H[1][0][1].Rho2() + H[1][1][0].Rho2() + H[1][1][1].Rho2();

    delete coefIter;
    delete coefIterZ;
    delete coefIterX;
    return totalA;
}

TMatrixD RooDalitzAmplitude::getIFandFF() const {

    CalCoupling();
    //  analyticalIntegral(7);
    IntegralMethod1();
    Double_t Inte(0);
    Double_t FFL(0), FFZ(0);
    Double_t InteL[NR][NR], InteZ[NZ][NZ], InteLZ[NZ][NR];
    //  Float_t IFFF[NR+NZ][NR+NZ];
    TMatrixD IFFF(NR + NZ, NR + NZ);

    for (int ir1 = 0; ir1 < NR; ++ir1) {
        for (int ir2 = 0; ir2 < NR; ++ir2) {
            InteL[ir1][ir2] = 0.0;
        }
    }
    for (int ir1 = 0; ir1 < NZ; ++ir1) {
        for (int ir2 = 0; ir2 < NR; ++ir2) {
            InteLZ[ir1][ir2] = 0.0;
        }
    }
    for (int ir1 = 0; ir1 < NZ; ++ir1) {
        for (int ir2 = 0; ir2 < NZ; ++ir2) {
            InteZ[ir1][ir2] = 0.0;
        }
    }

    TComplex a1, a2;
    for (int i = 0; i <= 1; ++i) {         // del
        for (int j = 0; j <= 1; ++j) {     // hel0
            for (int k = 0; k <= 1; ++k) { // hel3 proton
                // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
                for (int ir1 = 0; ir1 < NR; ++ir1) {
                    for (int m1 = 0; m1 < 6; ++m1) {
                        a1 = TComplex::Conjugate(amp[ir1][k][m1]);
                        if ((a1.Rho2()) < 1e-10)
                            continue;
                        for (int ir2 = 0; ir2 < NR; ++ir2) {
                            for (int m2 = 0; m2 < 6; ++m2) {
                                a2 = amp[ir2][k][m2];
                                double tmp = (a1 * a2 * AA[i][j][k][ir1][ir2][m1][m2]).Re();
                                InteL[ir1][ir2] += tmp;
                                Inte += tmp;
                                FFL += tmp;
                                //      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
                            }
                        }
                    }
                }
            }
        }
    }
    //  nres = NZ;

    for (int i = 0; i <= 1; ++i) {         // del
        for (int j = 0; j <= 1; ++j) {     // hel0
            for (int k = 0; k <= 1; ++k) { // hel3 proton
                // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
                for (int ir1 = 0; ir1 < NZ; ++ir1) {
                    for (int m1 = 0; m1 < 12; ++m1) {
                        a1 = TComplex::Conjugate(ampZ[ir1][k][m1]);
                        if ((a1.Rho2()) < 1e-10)
                            continue;
                        for (int ir2 = 0; ir2 < NZ; ++ir2) {
                            for (int m2 = 0; m2 < 12; ++m2) {
                                a2 = ampZ[ir2][k][m2];
                                double tmp = (a1 * a2 * AAZ[i][j][k][ir1][ir2][m1][m2]).Re();
                                InteZ[ir1][ir2] += tmp;
                                //      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
                                Inte += tmp;
                                FFZ += tmp;
                            }
                        }
                    }
                }
            }
        }
    }

    for (int i = 0; i <= 1; ++i) {         // del
        for (int j = 0; j <= 1; ++j) {     // hel0
            for (int k = 0; k <= 1; ++k) { // hel3 proton
                // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
                for (int ir1 = 0; ir1 < NZ; ++ir1) {
                    for (int m1 = 0; m1 < 12; ++m1) {
                        a1 = TComplex::Conjugate(ampZ[ir1][k][m1]);
                        if ((a1.Rho2()) < 1e-10)
                            continue;
                        for (int ir2 = 0; ir2 < NR; ++ir2) {
                            for (int m2 = 0; m2 < 6; ++m2) {
                                a2 = amp[ir2][k][m2];
                                double tmp = 2. * (a1 * a2 * ABZ[i][j][k][ir1][ir2][m1][m2]).Re();
                                InteLZ[ir1][ir2] += tmp;
                                //      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
                                Inte += tmp;
                            }
                        }
                    }
                }
            }
        }
    }

    for (int ir1 = 0; ir1 < NR; ++ir1) {
        for (int ir2 = 0; ir2 < NR; ++ir2) {
            IFFF(ir1, ir2) = 100. * InteL[ir1][ir2] / Inte;
        }
    }
    for (int ir1 = 0; ir1 < NZ; ++ir1) {
        for (int ir2 = 0; ir2 < NZ; ++ir2) {
            IFFF(ir1 + NR, ir2 + NR) = 100. * InteZ[ir1][ir2] / Inte;
        }
    }
    for (int ir1 = 0; ir1 < NZ; ++ir1) {
        for (int ir2 = 0; ir2 < NR; ++ir2) {
            IFFF(ir1 + NR, ir2) = 100. * InteLZ[ir1][ir2] / 2. / Inte;
            IFFF(ir2, ir1 + NR) = 100. * InteLZ[ir1][ir2] / 2. / Inte;
        }
    }
    //  IFFF.Print("f= %15.8g");
    std::cout << "FF L and Z " << FFL / Inte << " " << FFZ / Inte << std::endl;

    //  updateCache();
    // std::cout <<"sumW " << sumW <<std::endl;
    return IFFF;
}

#if 0
void RooDalitzAmplitude::updateCache() const
{

  //update cached resparam
  int ir(0);
  TIterator *coefIter = _resList->MakeIterator();
  while (RooArgList *Ires = (RooArgList *)coefIter->Next())
  {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    float m0 = 0;
    float g0 = 0;
    m0 = ((RooAbsReal &)ires[iressize - 5]).getVal();
    g0 = ((RooAbsReal &)ires[iressize - 4]).getVal();

    _resParCache[2 * ir + 0] = m0;
    _resParCache[2 * ir + 1] = g0;

    ir++;
  }
  delete coefIter;
  TIterator *coefIterZ = _resListZ->MakeIterator();
  while (RooArgList *Ires = (RooArgList *)coefIterZ->Next())
  {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    float m0 = 0;
    float g0 = 0;
    m0 = ((RooAbsReal &)ires[iressize - 5]).getVal();
    g0 = ((RooAbsReal &)ires[iressize - 4]).getVal();

    _resParCache[2 * ir + 0] = m0;
    _resParCache[2 * ir + 1] = g0;

    ir++;
  }
  delete coefIterZ;


        TIterator* coefIterX=_resListX->MakeIterator();
        while(RooArgList* Ires = (RooArgList*)coefIterX->Next()) {
          RooArgList ires = (*Ires);
          int iressize = ires.getSize();
          float m0 = 0;
          float g0 = 0;
          m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
          g0 = ((RooAbsReal&)ires[iressize-4]).getVal();

          _resParCache[2*ir+0] = m0;
          _resParCache[2*ir+1] = g0;

          ir++;
        }
        delete coefIterX;

}
#endif

void RooDalitzAmplitude::getInt(double *vint, bool small, float ylo, float yhi) const {
    CalCoupling();

    int nres = NR + NZ + NX;
    double a0[100];
    for (Int_t i = 0; i < 100; ++i) {
        a0[i] = 0;
    }
    int smcnum = _Nmc + _Nda; // PDLZ->size();//smcdata->GetEntries();

    TString lwvname[] = {"S01", "P01", "P03", "D03", "D05", "F05", "F07", "G07", "G09", "H09"};
    TString Zwvname[] = {"S01", "P01", "S03", "P03", "P05", "D05"};
    int nlwv[] = {1, 2, 4, 5, 7, 8, 10, 11, 13, 14};
    int nZwv[] = {2, 3, 6, 7, 11, 12};

    double val, sweight;
    int k;
    for (int i = _Nda; i < smcnum; i++) {
        if (i % 10000 == 0) {
            std::cout << "wmz debug i = " << i << "/" << smcnum << std::endl;
        }
        if (small && i % 10 != 0)
            continue; // for small only use 10% MC for calculation
        // mppi>2GeV
        // if(mppi<2.0) continue;
        Jpsihh_dlz &p = *(*PDLZ)[i];
        if (p.mppi < ylo || p.mppi > yhi)
            continue;
        //    filldlz(p, mppi, costheta, costheta1, costheta2, phi1, phi2, phi);
        val = GetAmp2s(p);
        sweight = (double)p.w;
        a0[0] += val * sweight;
        for (k = 1; k <= nres; ++k) {
            val = GetAmp2sForInt(p, k - 1);
            a0[k] += val * sweight;
        }
        k = nres + 1;
        for (int ii = 0; ii < 10; ++ii) {
            a0[k] += GetAmp2sForInt(p, nlwv[ii], 3) * sweight;
            k = k + 1;
        }
        for (int ii = 0; ii < 6; ++ii) {
            a0[k] += GetAmp2sForInt(p, nZwv[ii], 5) * sweight;
            k = k + 1;
        }
    }

    for (k = 1; k <= nres; ++k)
        vint[k - 1] = a0[k] / a0[0];
    k = nres;
    for (int ii = 0; ii < 16; ++ii)
        vint[k + ii] = a0[k + 1 + ii] / a0[0];
    //  std::cout << "Integration " << inte << std::endl;

    //  updateCache();
    // update cached resparam
}

// fit will use Re, Im as inputs
TComplex RooDalitzAmplitude::HelicityCoff(RooArgList &ires, Int_t ihel) const {

    return TComplex(((RooAbsReal &)ires[ihel * 2]).getVal(),
                    ((RooAbsReal &)ires[ihel * 2 + 1]).getVal());
}

// here all quantum numbers are 2 x
/*
TComplex RooDalitzAmplitude::PartWaveCoff(RooArgList ires, int J, int lambda2, int lambda3) const
{
  //|2*J_L - 2|<=2S<= 2*J_L+2 === odd 1,3,5,7...;
  //2L = 2*S-1, 2*S + 1;
  //s2 and s3 are two times of hel2, hel3
  //  int J = 2*spin;
  int ib(0);
  TComplex c(0);
  int s2(J), s3(2);//2xspin of L; jpsi
  int JB(1);
  int m1 = lambda2-lambda3;
  EvtCGCoefSingle c1(s2,s3);
  for(int S = abs(J-2); S<=J+2; S+=2) {
    for(int L = S - 1; L<= S + 1; L+=2) {
      TComplex M(((RooAbsReal&)ires[ib*2]).getVal(),((RooAbsReal&)ires[ib*2+1]).getVal());
      if(fabs(M.Rho2()<1e-10)) { ib++; continue;}
      float fkwTmp = (L+1.0)/(S+1.0);
      EvtCGCoefSingle c2(L,S);
      TComplex tmp=sqrt(fkwTmp)
  *c1.coef(S,m1,s2,s3,lambda2,-lambda3)
  *c2.coef(JB,m1,L,S,0,m1)*M;
      //std::cout << "Test CG spin L S m1 " << J << " " << L << " " << S << " " << m1<< " " <<
c1.coef(S,m1,s2,s3,lambda2,-lambda3)*c2.coef(JB,m1,L,S,0,m1) << std::endl; c += tmp; ib++;
    }
  }
  return c;
}
*/

// here all quantum numbers are 2 x
TComplex RooDalitzAmplitude::PartWaveCoff(RooArgList &ires, int J, int lambda2, int lambda3) const {
    //|2*J_L - 2|<=2S<= 2*J_L+2 === odd 1,3,5,7...;
    // 2L = 2*S-1, 2*S + 1;
    // s2 and s3 are two times of hel2, hel3
    //  int J = 2*spin;
    int ib(0);
    TComplex c(0);
    int s2(J), s3(2); // 2xspin of L; jpsi
    int JB(1);
    int m1 = lambda2 - lambda3;
    //  EvtCGCoefSingle c1(s2,s3);
    for (int S = abs(J - 2); S <= J + 2; S += 2) {
        for (int L = S - 1; L <= S + 1; L += 2) {
            TComplex M(((RooAbsReal &)ires[ib * 2]).getVal(),
                       ((RooAbsReal &)ires[ib * 2 + 1]).getVal());
            if ((M.Rho2() < 1e-10)) {
                ib++;
                continue;
            }
            float fkwTmp = (L + 1.0) / (JB + 1.0);
            //      EvtCGCoefSingle c2(L,S);
            //  EvtCGCoefSingle c1(s2,s3);
            //   std::cout << "begin " << S << " " << L << std::endl;
            float ccg(1.);
            switch (s2) {
            case 1: {
                ccg = CG1.coef(S, m1, s2, s3, lambda2, -lambda3);
                break;
            }
            case 3: {
                ccg = CG3.coef(S, m1, s2, s3, lambda2, -lambda3);
                break;
            }
            case 5: {
                ccg = CG5.coef(S, m1, s2, s3, lambda2, -lambda3);
                break;
            }
            case 7: {
                ccg = CG7.coef(S, m1, s2, s3, lambda2, -lambda3);
                break;
            }
            case 9: {
                ccg = CG9.coef(S, m1, s2, s3, lambda2, -lambda3);
                break;
            }
            default:
                std::cout << "CG wrong" << std::endl;
            }
            TComplex tmp = sqrt(fkwTmp) *
                           ccg
                           //*c1.coef(S,m1,s2,s3,lambda2,-lambda3)
                           //  *c2.coef(JB,m1,L,S,0,m1)*M;
                           * C2[(S - 1) / 2][(L - S + 1) / 2] * M;
            //        std::cout << "end" << std::endl;
            if (m1 < 0 && L > S)
                tmp = -tmp;
            // std::cout << "Test CG spin L S m1 " << J << " " << L << " " << S << " " << m1<< " "
            // << c1.coef(S,m1,s2,s3,lambda2,-lambda3)*c2.coef(JB,m1,L,S,0,m1) << std::endl;
            c += tmp;
            ib++;
        }
    }
    return c;
}

// here all quantum numbers are 2 x
TComplex RooDalitzAmplitude::PartWaveCoffZ(
    RooArgList &ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const {
    TComplex HB(0, 0);
    int SB = J; // 2xZ spin
    for (int LB = SB - 1; LB <= SB + 1; LB += 2) {
        TComplex tmp =
            TComplex(1.0, 0) * C2[(SB - 1) / 2][(LB - SB + 1) / 2] * sqrt((LB + 1.0) / 2.0);
        if (LB > SB) {
            TComplex M(((RooAbsReal &)ires[0]).getVal(), ((RooAbsReal &)ires[1]).getVal());
            if ((M.Rho2() < 1e-10)) {
                tmp = 0.0;
                continue;
            }
            tmp = tmp * M;
            if (lambdaZ < 0)
                tmp = -tmp;
        }
        HB += tmp;
    }

    //|2*J_L - 2|<=2S<= 2*J_L+2 === odd 1,3,5,7...;
    // 2L = 2*S-1, 2*S + 1;
    // s2 and s3 are two times of hel2, hel3
    //  int J = 2*spin;

    int parity = (int)((RooAbsReal &)ires[ires.getSize() - 1]).getVal();

    int ib(1);
    TComplex c(0);
    int m1 = lambdaPsi - lambdap;

    float ccg1(1.0);
    for (int S = 1; S <= 3; S += 2) {
        for (int L = abs(J - S); L <= J + S; L += 2) {
            //(-1)*(-1)^LR = P_Lz
            if ((pow(-1, (int)(L / 2) + 1) * parity) < 0)
                continue;
            // std::cout << "S L " << S << " " << L << std::endl;
            if (S < abs(m1)) {
                ib++;
                continue;
            }
            ccg1 = CG21.coef(S, m1, 2, 1, lambdaPsi, -lambdap);
            //  EvtCGCoefSingle c1(s2,s3);
            // std::cout << "ib " << ib << std::endl;
            if (ib >= 4)
                std::cout << "why Z parity" << std::endl;
            TComplex M(((RooAbsReal &)ires[ib * 2]).getVal(),
                       ((RooAbsReal &)ires[ib * 2 + 1]).getVal());
            // std::cout << "M " << M << std::endl;
            if ((M.Rho2() < 1e-10)) {
                ib++;
                continue;
            }
            float fkwTmp = (L + 1.0) / (J + 1.0); // S should be JB;

            //      EvtCGCoefSingle c2(L,S);
            //  EvtCGCoefSingle c1(s2,s3);
            //   std::cout << "begin " << S << " " << L << std::endl;
            float ccg(1.);
            if (J == 1) {
                ccg = C2[(S - 1) / 2][(L - S + 1) / 2];
                if (m1 < 0 && L > S)
                    ccg = -ccg;
            } else if (J == 3) {
                if (S == 1) {
                    if (L == 2) {
                        ccg = CG21.coef(J, m1, L, S, 0, m1);
                    } else if (L == 4) {
                        ccg = CG41.coef(J, m1, L, S, 0, m1);
                    } else {
                        std::cout << "why CG J==3 S==1 L" << std::endl;
                        ccg = 0.0;
                    }
                } else if (S == 3) {
                    switch (L) {
                    case 0: {
                        ccg = CG03.coef(J, m1, L, S, 0, m1);
                        break;
                    }
                    case 2: {
                        ccg = CG23.coef(J, m1, L, S, 0, m1);
                        break;
                    }
                    case 4: {
                        ccg = CG43.coef(J, m1, L, S, 0, m1);
                        break;
                    }
                    case 6: {
                        ccg = CG63.coef(J, m1, L, S, 0, m1);
                        break;
                    }

                    default:
                        std::cout << "CG wrong" << std::endl;
                    }
                } else {
                    std::cout << " why CG J==3 S?" << std::endl;
                    ccg = 0.0;
                }
            } else {
                EvtCGCoefSingle c2(L, S);
                ccg = c2.coef(J, m1, L, S, 0, m1);
            }

            TComplex tmp = sqrt(fkwTmp) *
                           ccg
                           //*c1.coef(S,m1,s2,s3,lambda2,-lambda3)
                           //  *c2.coef(JB,m1,L,S,0,m1)*M;
                           * ccg1 * M;
            //        std::cout << "end" << std::endl;
            //      if(m1<0&&L>S) tmp   = -tmp;
            // std::cout << "Test CG spin L S m1 " << J << " " << L << " " << S << " " << m1<< " "
            // << c1.coef(S,m1,s2,s3,lambda2,-lambda3)*c2.coef(JB,m1,L,S,0,m1) << std::endl; Misha's
            // two particle LS coupling ===
            //      tmp = tmp* pow(-1, (1-lambdap)/2);
            c += tmp;
            ib++;
        }
    }
    return c * HB;
}

// here all quantum numbers are 2 x
// coef(int J,int M,int j1,int j2,int m1,int m2)
TComplex RooDalitzAmplitude::PartWaveCoffX(
    RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const {
    int ib(4);
    // Coupling for Zc
    TComplex HZ(0, 0);
    int parity = (int)((RooAbsReal &)ires[ires.getSize() - 1]).getVal();
    // first () is 1. as one final state J=0
    int SZ = 2; // jpsi
    bool first(true);
    for (int LZ = J - SZ; LZ <= SZ + J; LZ += 2) {
        if (J == 0 && LZ != SZ)
            continue;
        if (parity * pow(-1, (int)(LZ / 2)) < 0)
            continue;
        double tmp1 = (LZ + 1.0) / (J + 1.0);
        //    std::cout << "zhanglm LZ "  <<  LZ << std::endl;
        //    TComplex tmp = TComplex(1.0,0)*C2[(SB-1)/2][(LB-SB+1)/2]*sqrt((LZ+1.0)/(J+1.0));
        double cg2(1.0);
        if (LZ == 0) {
            cg2 = CG02.coef(J, lambdaPsi, LZ, SZ, 0, lambdaPsi);
        } else if (LZ == 2) {
            cg2 = CG22.coef(J, lambdaPsi, LZ, SZ, 0, lambdaPsi);
        } else if (LZ == 4) {
            cg2 = CG42.coef(J, lambdaPsi, LZ, SZ, 0, lambdaPsi);
        } else {
            EvtCGCoefSingle ccgg2(LZ, SZ);
            cg2 = ccgg2.coef(J, lambdaPsi, LZ, SZ, 0, lambdaPsi);
        }
        if (first) {
            first = false;
            HZ += TComplex(1.0, 0) * sqrt(tmp1) * cg2;
        } else {
            TComplex M(((RooAbsReal &)ires[2 * ib]).getVal(),
                       ((RooAbsReal &)ires[2 * ib + 1]).getVal());
            if ((M.Rho2() < 1e-10)) {
                ib++;
                continue;
            }
            //      tmp = tmp * M;
            HZ += M * sqrt(tmp1) * cg2;
        }
    }
    //|2*J_L - 2|<=2S<= 2*J_L+2 === odd 1,3,5,7...;
    // 2L = 2*S-1, 2*S + 1;
    // s2 and s3 are two times of hel2, hel3
    //  int J = 2*spin;

    ib = 0;
    TComplex c(0);
    int m1 = lambdaZ - lambdap;

    // For Lb couplings
    // here S is SB, L is LB
    double ccg1(1.0);
    for (int S = J - 1; S <= J + 1; S += 2) {
        if (S < 0)
            continue;
        for (int L = S - 1; L <= S + 1; L += 2) {
            //(-1)*(-1)^LR = P_Lz
            // std::cout << "S L " << S << " " << L << std::endl;
            if (S < abs(m1))
                std::cout << "why lzhang S<m1" << std::endl;
            ccg1 = C2[(S - 1) / 2][(L - S + 1) / 2];
            if (m1 < 0 && L > S)
                ccg1 = -ccg1;
            //  EvtCGCoefSingle c1(s2,s3);
            // std::cout << "ib " << ib << std::endl;
            if (ib >= 4)
                std::cout << "why X parity" << std::endl;
            TComplex M(((RooAbsReal &)ires[ib * 2]).getVal(),
                       ((RooAbsReal &)ires[ib * 2 + 1]).getVal());
            // std::cout << "M " << M << std::endl;
            if ((M.Rho2() < 1e-10)) {
                ib++;
                continue;
            }
            double fkwTmp = (L + 1.0) / (2.0); // S should be JB;

            //      EvtCGCoefSingle c2(L,S);
            //  EvtCGCoefSingle c1(s2,s3);
            //   std::cout << "begin " << S << " " << L << std::endl;
            double ccg(1.);
            if (J == 2) {
                ccg = CG21.coef(S, m1, J, 1, lambdaZ, -lambdap);
            } else if (J == 4) {
                ccg = CG41.coef(S, m1, J, 1, lambdaZ, -lambdap);
            } else {
                EvtCGCoefSingle c2(J, 1);
                ccg = c2.coef(S, m1, J, 1, lambdaZ, -lambdap);
            }
            TComplex tmp = sqrt(fkwTmp) *
                           ccg
                           //*c1.coef(S,m1,s2,s3,lambda2,-lambda3)
                           //      *c2.coef(JB,m1,L,S,0,m1)*M;
                           * ccg1 * M;
            //        std::cout << "end" << std::endl;
            //      if(m1<0&&L>S) tmp   = -tmp;
            // std::cout << "Test CG spin L S m1 " << J << " " << L << " " << S << " " << m1<< " "
            // << c1.coef(S,m1,s2,s3,lambda2,-lambda3)*c2.coef(JB,m1,L,S,0,m1) << std::endl;
            c += tmp;
            ib++;
        }
    }
    return c * HZ;
}

// here all quantum numbers are 2 x: J = 2*spin of L*
TComplex RooDalitzAmplitude::HeliWaveCoff(TComplex *Hcpl, int J, int L, int S) const {
    //|2*J_L - 2|<=2S<= 2*J_L+2 === odd 1,3,5,7...;
    // 2L = 2*S-1, 2*S + 1;
    // s2 and s3 are two times of hel2, hel3
    //  int J = 2*spin;
    if (!(S >= abs(J - 2) && S <= J + 2)) {
        std::cout << "why " << S << " " << J << std::endl;
        return 0;
    }
    if (!(L >= S - 1 && L <= S + 1)) {
        std::cout << "why 2 " << std::endl;
        return 0;
    }
    TComplex c(0);
    int s2(J), s3(2); // 2xspin of L; jpsi
    int JB(1);
    int lambda2, lambda3;
    float fkwTmp = (L + 1.0) / (JB + 1.0);
    for (int m = 0; m < 6; ++m) {
        if (J == 1 && m >= 4) {
            continue;
        }
        TComplex M = Hcpl[m];
        //     std::cout <<"HHamp " << m << " " << M << std::endl;
        if ((M.Rho2() < 1e-10)) {
            continue;
        }
        lambda3 = 2 * Hel2[m];
        lambda2 = Hel1Two[m];

        int m1 = lambda2 - lambda3;

        float ccg(1.);
        switch (s2) {
        case 1: {
            ccg = CG1.coef(S, m1, s2, s3, lambda2, -lambda3);
            break;
        }
        case 3: {
            ccg = CG3.coef(S, m1, s2, s3, lambda2, -lambda3);
            break;
        }
        case 5: {
            ccg = CG5.coef(S, m1, s2, s3, lambda2, -lambda3);
            break;
        }
        case 7: {
            ccg = CG7.coef(S, m1, s2, s3, lambda2, -lambda3);
            break;
        }
        case 9: {
            ccg = CG9.coef(S, m1, s2, s3, lambda2, -lambda3);
            break;
        }
        default:
            std::cout << "CG wrong" << std::endl;
        }
        TComplex tmp = sqrt(fkwTmp) *
                       ccg
                       //*c1.coef(S,m1,s2,s3,lambda2,-lambda3)
                       //  *c2.coef(JB,m1,L,S,0,m1)*M;
                       * C2[(S - 1) / 2][(L - S + 1) / 2] * M;
        //        std::cout << "end" << std::endl;
        if (m1 < 0 && L > S)
            tmp = -tmp;
        // std::cout << "Test CG spin L S m1 " << J << " " << L << " " << S << " " << m1<< " " <<
        // c1.coef(S,m1,s2,s3,lambda2,-lambda3)*c2.coef(JB,m1,L,S,0,m1) << std::endl;
        c += tmp;
    }
    return c;
}

Float_t RooDalitzAmplitude::BTerm(Float_t Spin, Float_t mpp, Float_t mr) const {
    Float_t c(0);

    //  float pi=TMath::Pi();
    // float deg2rad = pi/180.;

    Float_t J = Spin;
    int LB = (int)(J - 1.5);
    if (LB < 0)
        LB = 0;

    float pB = getp(m_lb, m_jpsi, mpp);
    // for NR
    //   if(mr<-0.) return pow(pB/m_lb, LB);
    float pB0 = pB;
    // for NR
    if (mr < -0.) {
        float mmin = m_pi + m_p;
        float mmax = m_lb - m_jpsi;
        float mreff = (mmin + mmax) / 2.;
        pB0 = getp(m_lb, m_jpsi, mreff);
    }
    if (mr > 1e-10 && mr + m_jpsi < m_lb)
        pB0 = getp(m_lb, m_jpsi, mr);
    if (mr + m_jpsi > m_lb) {
        float mmin = m_pi + m_p;
        float mmax = m_lb - m_jpsi;
        float mreff =
            mmin + 0.5 * (mmax - mmin) * (1.0 + tanh((mr - (mmin + mmax) / 2.) / (mmax - mmin)));
        pB0 = getp(m_lb, m_jpsi, mreff);
    }

    c = (LINESHAPE_LBPLUSONE)
            ? F_BW(_FFB, LB + 1, pB, pB0) * pow(pB / m_lb, LB) * pow(m_lb / pB0, LB) * (pB / pB0)
            : F_BW(_FFB, LB, pB, pB0) * pow(pB / m_lb, LB) * pow(m_lb / pB0, LB);

    return c;
}

Float_t RooDalitzAmplitude::BTermZ(Float_t Spin, Float_t mpp, Float_t mr) const {
    Float_t c(0);

    //  float pi=TMath::Pi();
    // float deg2rad = pi/180.;

    Float_t J = Spin;
    int LB = (int)(J - 0.5);
    if (LB < 0)
        LB = 0;

    float pB = getp(m_lb, m_pi, mpp);
    float pB0 = pB;
    if (mr < -0.) {
        float mmin = m_jpsi + m_p;
        float mmax = m_lb - m_pi;
        float mreff = (mmin + mmax) / 2.;
        pB0 = getp(m_lb, m_pi, mreff);
    }
    if (mr > 1e-10 && mr + m_pi < m_lb)
        pB0 = getp(m_lb, m_pi, mr);

    c = (LINESHAPE_LBPLUSONE) ? F_BW(_FFB, LB + 1, pB, pB0) * pow(pB / m_lb, LB) * (pB / pB0)
                              : F_BW(_FFB, LB, pB, pB0) * pow(pB / m_lb, LB);

    return c;
}

Float_t RooDalitzAmplitude::BTermX(Float_t Spin, Float_t mpp, Float_t mr) const {
    Float_t c(0);

    //  float pi=TMath::Pi();
    // float deg2rad = pi/180.;

    Float_t J = Spin;
    int LB = (int)(J - 1.0);
    if (LB < 0)
        LB = 0;

    float pB = getp(m_lb, m_p, mpp);
    float pB0 = pB;
    if (mr < -0.)
        return pow(pB / m_lb, LB);
    if (mr > 1e-10 && mr + m_p < m_lb)
        pB0 = getp(m_lb, m_p, mr);

    //  float phi00 = ((RooAbsReal&)ires[ihel*2+1]).getVal()*deg2rad;
    c = F_BW(_FFB, LB, pB, pB0) * pow(pB / m_lb, LB);
    // if(h3<0) //lamda_3 <0 /\->pK strong decay???
    //

    return c;
}

////////////////////////////////////////////////
//   Breit Wigner Resonance
////////////////////////////////////////////////
void RooDalitzAmplitude::breit_wigner(
    float m, float gamma, float e2, float &r_ampl, float &i_ampl) const {
    float de2 = m * m - e2;
    float gamma_m = gamma * m;
    float d = (de2 * de2 + gamma_m * gamma_m);
    r_ampl = de2 / d;
    i_ampl = gamma_m / d;
}
/////////////////////////////////////////////
// Blatt-Weisskopf form factors
/////////////////////////////////////////////
Float_t RooDalitzAmplitude::F_BW(float r, int L, float p, float p0) const {
    float z = pow(r * p, 2);
    float z0 = pow(r * p0, 2);
    if (L == 0)
        return 1.0;
    if (L == 1)
        return sqrt((1. + z0) / (1. + z));
    if (L == 2)
        return sqrt((z0 * z0 + 3 * z0 + 9.) / (z * z + 3 * z + 9.));
    if (L == 3)
        return sqrt((z0 * z0 * z0 + 6 * z0 * z0 + 45 * z0 + 225) /
                    (z * z * z + 6 * z * z + 45 * z + 225));
    if (L == 4)
        return sqrt((pow(z0, 4) + 10 * pow(z0, 3) + 135 * z0 * z0 + 1575 * z0 + 11025) /
                    (pow(z, 4) + 10 * pow(z, 3) + 135 * z * z + 1575 * z + 11025));
    if (L == 5)
        return sqrt(
            (pow(z0, 5) + 15 * pow(z0, 4) + 315 * pow(z0, 3) + 6300 * pow(z0, 2) + 99225 * z0 +
             893025) /
            (pow(z, 5) + 15 * pow(z, 4) + 315 * pow(z, 3) + 6300 * pow(z, 2) + 99225 * z + 893025));

    return 1.0;
} //////////////////////////////////////////////////

Float_t RooDalitzAmplitude::F_BW2(float r, int L, float p2, float p20) const {
    float z = r * r * p2;
    float z0 = r * r * fabs(p20);
    if (L == 0)
        return 1.0;
    if (L == 1)
        return ((1. + z0) / (1. + z));
    if (L == 2)
        return ((z0 * z0 + 3 * z0 + 9.) / (z * z + 3 * z + 9.));
    if (L == 3)
        return ((z0 * z0 * z0 + 6 * z0 * z0 + 45 * z0 + 225) /
                (z * z * z + 6 * z * z + 45 * z + 225));
    if (L == 4)
        return ((pow(z0, 4) + 10 * pow(z0, 3) + 135 * z0 * z0 + 1575 * z0 + 11025) /
                (pow(z, 4) + 10 * pow(z, 3) + 135 * z * z + 1575 * z + 11025));
    if (L == 5)
        return (
            (pow(z0, 5) + 15 * pow(z0, 4) + 315 * pow(z0, 3) + 6300 * pow(z0, 2) + 99225 * z0 +
             893025) /
            (pow(z, 5) + 15 * pow(z, 4) + 315 * pow(z, 3) + 6300 * pow(z, 2) + 99225 * z + 893025));

    return 1.0;
} //////////////////////////////////////////////////

TComplex RooDalitzAmplitude::F_BW2_complexMass(float r, int L, TComplex p2, TComplex p20) const {
    TComplex z = r * r * p2;
    TComplex z0 = r * r * p20;
    if (L == 0)
        return 1.0;
    if (L == 1)
        return ((1. + z0) / (1. + z));
    if (L == 2)
        return ((z0 * z0 + 3 * z0 + 9.) / (z * z + 3 * z + 9.));
    if (L == 3)
        return ((z0 * z0 * z0 + 6 * z0 * z0 + 45 * z0 + 225) /
                (z * z * z + 6 * z * z + 45 * z + 225));
    if (L == 4)
        return ((z0 * z0 * z0 * z0 + 10 * z0 * z0 * z0 + 135 * z0 * z0 + 1575 * z0 + 11025) /
                (z * z * z * z + 10 * z * z * z + 135 * z * z + 1575 * z + 11025));
    if (L == 5)
        return ((z0 * z0 * z0 * z0 * z0 + 15 * (z0 * z0 * z0 * z0) + 315 * (z0 * z0 * z0) +
                 6300 * (z0 * z0) + 99225 * z0 + 893025) /
                ((z * z * z * z * z) + 15 * (z * z * z * z) + 315 * (z * z * z) + 6300 * (z * z) +
                 99225 * z + 893025));

    return TComplex(1.0, 0.);
} //////////////////////////////////////////////////

#if 0
void RooDalitzAmplitude::ModelIndependentWave(float *ampxxx, float x, float & Rea,float & Ima) const
{
  Rea=Ima=0.0;
//ms  input mass i.e. m(J/psi p) in this case
//Rea,Ima  real and imaginary parts of the amplitude

  // get binning and number of interpolation points

  const int nbin = NUMSP;

  if( nbin <=0 )return;

  float m2min = 4.23;//1.43;//((RooAbsReal&)res24[3]).getVal();
  float m2max = 4.63;//5.03;//2.53;//((RooAbsReal&)res24[4]).getVal();

  //I defined equidistant binning in mass squared. In principle, using mass itself for binning should be fine too and perhaps better since we  tend to show mass, not mass squared in the fit displays.
  //As you can see number of bins and range of the parameterization could be easily changed (set to zero outside the range).


  //     returning zero amplitude beyond limits is a special feature of MIZWave (to allow local implementations)

  if( x<m2min )return;
  if( x>m2max )return;


  //if( ((RooAbsReal&)res24[5]).getVal()<0.0 )noamp=true;

  //This is a switch between independent interpolation of real and imaginary (noamp=true) and interpolation which brings in also an interpolation in magnitude (see the code below).


  int npoint = 4;
  // int npoint = int( fabs(((RooAbsReal&)res24[5]).getVal())+0.1 );
  // if( npoint <2 )npoint=2;
  // if( npoint >10 )npoint=10;
  if( npoint >nbin )npoint=nbin;

  //I use spline interpolation between the bin centers, but locally. npoint is the number of bins used in the spline. I used NPOINT=4, which means cubic spline.

  const float binw=(m2max-m2min)/nbin;
  // get required points

  float p_re[10],p_im[10];

  // C convention: ipoint = 0,...,nbin-1

  int ipoint = (x - m2min)/binw;
  ipoint = ipoint + 1 -npoint/2;
  if( ipoint<0 )ipoint=0;
  if( ipoint+npoint > nbin )ipoint=nbin-npoint;


   for(int i=0;i<npoint;++i){
     int j=i+ipoint;
      p_re[i]= ampxxx[j*2];
      //((RooAbsReal&)res19[2*j  ]).getVal();
      p_im[i]= ampxxx[j*2+1];
  //((RooAbsReal&)res19[2*j+1]).getVal();
//      p_amp[i] = sqrt( pow(p_re[i],2)+pow(p_im[i],2) );
  }

  //The code above copies bins to be used in the interpolation to local vectors.

  float sumre(0.0);
  float sumim(0.0);

  // legrange cardinal polynomial: npoint interpolation (for npoint=2 straight line)

  for(int i=0;i<npoint;++i){
    float xi=m2min + binw*(i+ipoint+0.5);

    float product(1.0);
    for(int j=0;j<npoint;++j){
      if( j==i )continue;
      float xj=m2min + binw*(j+ipoint+0.5);
      product *= (x-xj)/(xi-xj);
    }

//    sumamp += product*p_amp[i];
    sumre += product*p_re[i];
    sumim += product*p_im[i];

  }


  //The above is the spline interpolation of the magnitude (called sumamp), real and imaginary parts.


    Rea=sumre;
    Ima=sumim;


}
#endif

cnum RooDalitzAmplitude::get_b(cnum alpha, cnum p23) const {
    cnum unit(1, 0);
    cnum unit2(2, 0);
    cnum unit4(4, 0);
    cnum p12(m_lb, 0);
    cnum p13(m_pi, 0);

    cnum m2(m_chic1, 0);
    cnum m3(m_p, 0);
    cnum ii(0, 1);

    cnum value =
        unit +
        unit / p23 / p23 * (alpha * (p12 * p12 - p13 * p13 - p23 * p23) + m3 * m3 - m2 * m2) -
        0.001 * ii;

    //   printf("Test get_b value_real:%f  value_imag:%f \n",  value);

    return value;
}

cnum RooDalitzAmplitude::get_c(cnum alpha, cnum p23, float m_r, float gamma) const {
    cnum unit(1, 0);
    cnum unit2(2, 0);
    cnum unit4(4, 0);
    cnum p12(m_lb, 0);
    cnum p13(m_pi, 0);

    cnum m1(m_r, -1 * gamma / 2.);
    cnum m2(m_chic1, 0);
    cnum m3(m_p, 0);

    cnum value = unit / p23 / p23 *
                 (m3 * m3 + alpha * (m1 * m1 - m3 * m3) - alpha * (unit - alpha) * p13 * p13);
    return value;
}

cnum RooDalitzAmplitude::this_func(float alpha1, float p23_real, float m_r, float gamma) const {
    cnum unit(1, 0);
    cnum unit2(2, 0);
    cnum unit4(4, 0);
    cnum p12(m_lb, 0);
    cnum p13(m_pi, 0);

    cnum m2(m_chic1, 0);
    cnum m3(m_p, 0);

    cnum alpha(alpha1, 0);
    cnum p23(p23_real, 0);
    cnum sqrt_value =
        sqrt(unit4 * get_c(alpha, p23, m_r, gamma) - get_b(alpha, p23) * get_b(alpha, p23));
    cnum value = unit / sqrt_value *
                 (atan(get_b(alpha, p23) / sqrt_value) -
                  atan((get_b(alpha, p23) + unit2 * (alpha - unit)) / sqrt_value));

    return value;
}

void RooDalitzAmplitude::get_cusp_ampli(
    float m_r, float gamma, float p23, float &r_ampl, float &i_ampl) const {
    cnum integral_value = cnum(0, 0);
    int bins = 100;
    float delta_x_real = 1. / bins;
    cnum delta_x(delta_x_real, 0);
    for (int i = 0; i < bins; i++) {
        float center_x = i * delta_x_real + delta_x_real / 2;
        integral_value = integral_value + delta_x * this_func(center_x, p23, m_r, gamma);
    }
    cnum value = (1. / p23 / p23) * integral_value;
    //   printf("Test get_cusp_ampli m_r:%f  gamma_r:%f  mpp:%f  r_ampl:%f   i_ampl:%f \n ", m_r,
    //   gamma, p23, value.real(), value.imag());

    r_ampl = value.real();
    i_ampl = value.imag();
}

/////////////////////////////////////////////////
//
// CUSP Amplitude
/////////////////////////////////////////////////
bool RooDalitzAmplitude::GetCusp_AMP(
    float m_r, float gamma_r, float mpp, float &ampl_r, float &ampl_i) const {
    ampl_r = 1;
    ampl_i = 0;

    float bw_r(0), bw_i(0);
    // float gamma = gamma_r;

    // how to do here? has problem for threshold resonances//careful???
    //   if(m_r>m1_0+m2_0)   gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;

    get_cusp_ampli(m_r, gamma_r, mpp, bw_r, bw_i);
    // breit_wigner(m_r, gamma, m2pp, bw_r, bw_i);

    // charged mpp->mr
    //   float factor = FR*pow(pR/mpp,LR);
    ampl_r = bw_r;
    ampl_i = bw_i;

    return true;
}

//
// Breit Wigner Amplitude
/////////////////////////////////////////////////
bool RooDalitzAmplitude::BW_AMP(
    float m_r, float gamma_r, float mpp, int LR, float &ampl_r, float &ampl_i) const {
    ampl_r = 0;
    ampl_i = 0;
    float m2pp = mpp * mpp;
    //  if(J>2) return false;
    // if(abs(helz)>1) return false;
    // if(J==0&&abs(helz)!=0) return true;
    //  int LB = 1;
    // int LR = (J-0.5);
    // if(J==1) {
    //  LB = 0; //changed by LM
    //} else if(J==2) {
    //  LB = 1; //changed by LM
    //}
    // float pB = getpB(mpp);
    float pR = getp(mpp, m_p, m_pi);
    // For NR
    float pR0 = pR;
    if (m_r < -0.) // NR
    {
        //  ampl_r = pow(pR,LR);
        //  ampl_i = 0;
        //  return true;
        float mmin = m_pi + m_p;
        float mmax = m_lb - m_jpsi;
        float mreff = (mmin + mmax) / 2.;
        pR0 = getp(mreff, m_p, m_pi);
    }
    if (m_r > m_p + m_pi) {
        pR0 = getp(m_r, m_p, m_pi); // sqrt(m_r*m_r-4*m2_pi)/2.;
    }
    if (m_r <= m_p + m_pi && m_r > 1e-10) {
        float mmin = m_pi + m_p;
        float mmax = m_lb - m_jpsi;
        float mreff =
            mmin + 0.5 * (mmax - mmin) * (1.0 + tanh((m_r - (mmin + mmax) / 2.) / (mmax - mmin)));
        pR0 = getp(mreff, m_p, m_pi);
    }
    // float FB = F_BW(_FFB,LB,pB,pB0);
    float FR = F_BW(_FFR, LR, pR, pR0);
    if (m_r < -0.) // NR
    {
        ampl_r = pow(pR / pR0, LR) * FR;
        ampl_i = 0;
        return true;
    }
    float bw_r(0), bw_i(0);
    float gamma = gamma_r;
    // if(with_dep!=0) gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
    if (m_r > m_p + m_pi) {
        gamma = gamma_r * pow((pR / pR0), 2 * LR + 1) * (m_r / mpp) * FR * FR;
    } else if (m_r < 1.43 && m_r > 0) {
        float msig = 1.18937;    // 1.192642;
        float mpi0 = 0.13957018; // 0.1349766;
        float pRSigPi = getp(mpp, msig, mpi0);

        // wehre LR = 0;
        gamma = 0.0;
        pR0 = getp(m_r, msig, mpi0);
        FR = 1.0;
        gamma += gamma_r * pow((pR / pR0), 2 * LR + 1) * (m_r / mpp) * FR * FR;
        FR = 1.0;
        gamma += 0.0505 * pow((pRSigPi / pR0), 2 * LR + 1) * (m_r / mpp) * FR * FR;
    }

    breit_wigner(m_r, gamma, m2pp, bw_r, bw_i);

    // charged 4/17 mpp->mr
    //   float factor = FR*pow(pR/mpp,LR);
    //   float factor = FR*pow(pR/m_r,LR);
    float kr = sqrt(m_r * m_r + gamma_r * gamma_r); // new
    float ksqrt = 0.948850 * m_r * sqrt(gamma_r * kr / sqrt(m_r * (m_r + kr)));
    float factor = FR * pow(pR / pR0, LR) * ksqrt;
    ampl_r = factor * bw_r;
    ampl_i = factor * bw_i;
    return true;
}

// For Flatte
bool RooDalitzAmplitude::BW_AMP(
    float m_r, float gamma_r, float mpp, int LR, float &ampl_r, float &ampl_i, float br1) const {
    ampl_r = 0;
    ampl_i = 0;
    float m2pp = mpp * mpp;
    //  if(J>2) return false;
    // if(abs(helz)>1) return false;
    // if(J==0&&abs(helz)!=0) return true;
    //  int LB = 1;
    // int LR = (J-0.5);
    // if(J==1) {
    //  LB = 0; //changed by LM
    //} else if(J==2) {
    //  LB = 1; //changed by LM
    //}
    // float pB = getpB(mpp);
    float pR = getp(mpp, m_p, m_pi);
    // For NR

    float pR0 = pR;
    if (m_r > m_p + m_pi)
        pR0 = getp(m_r, m_p, m_pi); // sqrt(m_r*m_r-4*m2_pi)/2.;

    // float FB = F_BW(_FFB,LB,pB,pB0);
    // take FR = 1.0;
    float FR = 1.0;
    //  std::cout << "G " << gamma_r * m_r / pR0 << std::endl;
    float bw_r(0), bw_i(0);
    float gamma = gamma_r;
    // if(with_dep!=0) gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
    gamma = gamma_r * pow((pR / pR0), 2 * LR + 1) * (m_r / mpp) * FR * FR * br1;
    // Lambda*Eta
    float mN = 1.115683;   // 1.192642;
    float mEta = 0.547862; // 0.1349766;
    float pRNEta = getp(mpp, mN, mEta);
    float pRNEta0 = getp(m_r, mN, mEta);
    float gammaNEta = pow((pRNEta / pRNEta0), 2 * LR + 1) * (m_r / mpp) * (1 - br1) * gamma_r;
    float de2 = m_r * m_r - m2pp;
    float gamma_m = gamma * m_r;
    if (mpp < mN + mEta) {
        de2 += gammaNEta * m_r;
    } else {
        gamma_m += gammaNEta * m_r;
    }
    // wehre LR = 0;
    float d = (de2 * de2 + gamma_m * gamma_m);
    bw_r = de2 / d;
    bw_i = gamma_m / d;

    float factor = FR * pow(pR / m_r, LR);
    ampl_r = factor * bw_r;
    ampl_i = factor * bw_i;
    return true;
}

bool RooDalitzAmplitude::BW_AMPZ(
    float m_r, float gamma_r, float mpp, int LR, float &ampl_r, float &ampl_i) const {
    ampl_r = 0;
    ampl_i = 0;
    float m2pp = mpp * mpp;
    //  if(J>2) return false;
    // if(abs(helz)>1) return false;
    // if(J==0&&abs(helz)!=0) return true;
    //  int LB = 1;
    // int LR = (J-0.5);
    // if(J==1) {
    //  LB = 0; //changed by LM
    //} else if(J==2) {
    //  LB = 1; //changed by LM
    //}
    // float pB = getpB(mpp);
    float pR = getp(mpp, m_p, m_jpsi);
    float pR0 = pR;
    if (m_r > m_p + m_jpsi)
        pR0 = getp(m_r, m_p, m_jpsi); // sqrt(m_r*m_r-4*m2_pi)/2.;

    // float FB = F_BW(_FFB,LB,pB,pB0);
    float FR = F_BW(_FFR, LR, pR, pR0);

    float bw_r(0), bw_i(0);
    float gamma = gamma_r;
    // if(with_dep!=0) gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
    if (m_r > m_p + m_jpsi)
        gamma = gamma_r * pow((pR / pR0), 2 * LR + 1) * (m_r / mpp) * FR * FR;
    breit_wigner(m_r, gamma, m2pp, bw_r, bw_i);
    // charged mpp->mr
    //   float factor = FR*pow(pR/mpp,LR);
    //   float factor = FR*pow(pR/m_r,LR);
    float kr = sqrt(m_r * m_r + gamma_r * gamma_r); // new
    float ksqrt = 0.948850 * m_r * sqrt(gamma_r * kr / sqrt(m_r * (m_r + kr)));
    float factor = FR * pow(pR / pR0, LR) * ksqrt;
    ampl_r = factor * bw_r;
    ampl_i = factor * bw_i;
    return true;
}

bool RooDalitzAmplitude::BW_AMPZSMR(float m_r,
                                    float gamma_r,
                                    float mpp,
                                    int LR,
                                    float &ampl_r,
                                    float &ampl_i) const // out-of-date not used
{
    // std::cout << "here we are " << std::endl;
    //   float NN(10000.);
    float mres = _mres0 + mpp * (_mres1 + mpp * _mres2);
#ifdef RESPLUS
    mres = mres * 1.1;
#endif
#ifdef RESMINUS
    mres = mres * 0.9;
#endif
    float aa;
    //  float ph;
    float min = m_jpsi + m_p;
    float max = m_lb - m_pi;
    //  float min(2.*m_pi), max(m_bs-m_jpsi);
    float mbin = (max - min) / NN;

    float bw_i, bw_r;
    //  float xph;//phase

    float dxmax, smpp, dmpp, xmpp, w;

    //  mpp = min + mbin *((float)x + 0.5);
    smpp = mres;
    //+/- 5 * resolution region;
    dxmax = (int)(5. * smpp / mbin);
    smpp = smpp * sqrt(2.);
    float sum(0), sumcos(0), sumsin(0);
    for (int dx = -dxmax; dx <= dxmax; ++dx) {
        dmpp = mbin * (float)dx;
        xmpp = dmpp + mpp;
        if (xmpp >= min && xmpp <= max) { // in the range;
            dmpp = -pow((dmpp / smpp), 2);
            if (dmpp > -9.) {
                // resolutoin gaus.
                w = exp(dmpp);
                BW_AMPZ(m_r, gamma_r, xmpp, LR, bw_r, bw_i);
                aa = bw_r * bw_r + bw_i * bw_i;
                //  ph = atan2(bw_i,bw_r);
                //  sumsin += w*sqrt(aa)*sin(ph);
                //  sumcos += w*sqrt(aa)*cos(ph);
                sum += w * aa;
                sumsin += w * bw_i; // sqrt(aa)*sin(ph);
                sumcos += w * bw_r; // sqrt(aa)*cos(ph);
            }
        }
    }
    float Y = sqrt(sum * (mbin / mres) / sqrt(2. * 3.14159265));
    float Z = sqrt(sumsin * sumsin + sumcos * sumcos);
    ampl_r = sumcos / Z * Y;
    ampl_i = sumsin / Z * Y;
    return true;
}

bool RooDalitzAmplitude::BW_AMPX(
    float m_r, float gamma_r, float mpp, int LR, float &ampl_r, float &ampl_i) const {
    ampl_r = 0;
    ampl_i = 0;
    float m2pp = mpp * mpp;
    float pR = getp(mpp, m_pi, m_jpsi);
    float pR0 = pR;
    if (m_r > m_pi + m_jpsi)
        pR0 = getp(m_r, m_pi, m_jpsi); // sqrt(m_r*m_r-4*m2_pi)/2.;

    // float FB = F_BW(_FFB,LB,pB,pB0);
    float FR = F_BW(_FFR, LR, pR, pR0);

    float bw_r(0), bw_i(0);
    float gamma = gamma_r;
    // if(with_dep!=0) gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
    if (m_r > m_pi + m_jpsi)
        gamma = gamma_r * pow((pR / pR0), 2 * LR + 1) * (m_r / mpp) * FR * FR;
    breit_wigner(m_r, gamma, m2pp, bw_r, bw_i);
    // charged mpp->mr
    //   float factor = FR*pow(pR/mpp,LR);
    //   float factor = FR*pow(pR/m_r,LR);
    float kr = sqrt(m_r * m_r + gamma_r * gamma_r); // new
    float ksqrt = 0.948850 * m_r * sqrt(gamma_r * kr / sqrt(m_r * (m_r + kr)));
    float factor = FR * pow(pR / pR0, LR) * ksqrt;
    ampl_r = factor * bw_r;
    ampl_i = factor * bw_i;
    return true;
}

//*** ToDo: only S-wave is considered, no FF, Only for 1/2-, 3/2- now
#if 0
bool RooDalitzAmplitude::KMatrix(float mpp, int J_r, int P_r, std::vector<float> &g_alpha, std::vector<float> &f_scat, std::vector<TComplex> &Mtr) const //only for Pc
{
  float s = mpp * mpp;
  //consider maximum four pole.
  int Npole(0);
  std::vector<float> ms(Npmax + 1, 1); //Mulply of (M^2-s)//loop//ininal to 1

  float denorm(1);
  float m0, g0;
  int S, type, parity, LR;

  int ikm(1); //how many km terms, should be Npole(pole part)+Nchannel(fs)
  for (int ir = NR; ir < NR + NZ; ++ir)
  {
    S = (int)(_paraList[ir * nset + SPIN]);
    type = (int)(_paraList[ir * nset + TYPE]);
    parity = (int)(_paraList[ir * nset + PARITY]);
    if (type == KMATRIX && S == J_r && parity == P_r)
    {
      m0 = _paraList[ir * nset + MASS];
      denorm = 1.0;
      if (m0 > 0)
      {
        denorm = (m0 * m0 - s);
        if (fabs(denorm) < 1e-3)
          denorm = 1e-3;
        Npole++;
        ms[0] *= denorm;
        for (int ip = 1; ip <= Npmax; ++ip)
        {
          if (ip == ikm)
            continue;
          ms[ip] *= denorm;
        }
        ikm++;
      }
    }
  }
  //  std::cout << "Number of pole g4 fs4 " << Npole << " " << g_alpha[4] << " " << f_scat[4] << std::endl;;
  std::vector<float> mg; //Npole x NC
  ikm = 0;
  for (int i = 0; i < Npole; ++i)
  {
    for (int j = 0; j < NKMC; ++j)
    {
      mg.push_back(g_alpha[ikm++] * ms[i + 1]);
    }
  }
  //  std::cout << "g_alpha[0], f_scat[0] " << g_alpha[0] << " " << f_scat[0] << std::endl;
  float fs[NKMC][NKMC], kma[NKMC][NKMC];
  ikm = 0;
  for (int i = 0; i < NKMC; ++i)
  {
    for (int j = 0; j < NKMC; ++j)
    {
      fs[i][j] = f_scat[ikm++] * ms[0]; //here scatter term is fab constant
    }
  }

  for (int i = 0; i < NKMC; ++i)
  {
    for (int j = i; j < NKMC; ++j)
    {
      kma[i][j] = fs[i][j];
      for (int k = 0; k < Npole; ++k)
      {
        kma[i][j] += g_alpha[k * NKMC + i] * mg[k * NKMC + j];
      }
      kma[j][i] = kma[i][j];
    }
  }

  TComplex rho[NKMC]; //do calculation here======needed
  for (int i = 0; i < NKMC - 1; ++i)
    rho[i] = getrho(s, Km1[i], Km2[i]);
  if (1 == J_r && P_r == -1)
  {
    rho[NKMC - 1] = getrho(s, Km1[3], Km2[3]);
    //std::cout << "one Channel " << Km1[3] << "--" << Km2[3] << std::endl;
  }
  else if (3 == J_r)
  {
    rho[NKMC - 1] = getrho(s, Km1[4], Km2[4]);
    //  std::cout << "one Channel " << Km1[4] << "--" << Km2[4] << std::endl;
  }

  TComplex KK[NKMC][NKMC];
  for (int i = 0; i < NKMC; i++)
  {
    for (int j = 0; j < NKMC; j++)
    {
      KK[i][j] = -TComplex(0., 1.) * rho[j] * double(kma[i][j]);
      if (i == j)
        KK[i][j] += double(ms[0]);
    }
  }
  SMatrixNN A, IB;
  for (int i = 0; i < NKMC; i++)
  {
    for (int j = 0; j < NKMC; j++)
    {
      IB(i, j) = KK[i][j].Re();
      A(i, j) = -KK[i][j].Im();
    }
  }
  int ifail;
  SMatrixNN IIB = IB.Inverse(ifail);
  if (ifail)
    std::cout << "inverse matrix failed 1" << std::endl;
  SMatrixNN RR = (IB + A * IIB * A);
  SMatrixNN IRR = RR.Inverse(ifail);
  if (ifail)
  {
    std::cout << "inverse matrix failed 2 mjpsip " << sqrt(s) << std::endl;
    std::cout << RR << std::endl;
    std::cout << IRR << std::endl;
    /*    float RRnew[NKMC][NKMC],IRRnew[NKMC][NKMC];
    for(int i=0; i<NKMC; i++) {
      for(int j=0; j<NKMC; j++) {
        RRnew[i][j]=RR(i,j);
      }
    }
    invert4x4(*(*(&RRnew)),*(*(&IRRnew)));
    for(int i=0; i<NKMC; i++) {
      for(int j=0; j<NKMC; j++) {
        std::cout << IRRnew[i][j] << " "  ;
      }
      std::cout << std::endl;
    }    */
  }
  SMatrixNN IM = IIB * A * IRR;
  TComplex T[NKMC];

  //first raw for Jpsi p
  Mtr.clear();
  Mtr.resize(NKMC + Npole, 0);
  for (int i = 0; i < NKMC; ++i)
  {
    T[i] = TComplex(IRR(0, i), IM(0, i));
    //Mtr.push_back(0);
  }
  for (int ip = 0; ip < Npole; ++ip)
  {
    for (int i = 0; i < NKMC; ++i)
    {
      Mtr[ip] += T[i] * double(mg[ip * NKMC + i]);
    }
  }
  for (int i = 0; i < NKMC; ++i)
  {
    Mtr[Npole + i] = T[i] * double(ms[0]);
  }

  //  std::cout << "Mtr[0] " << Mtr[0] << std::endl;
  return true;
}
#endif

//*** ToDo: only S-wave is considered, no FF, Only for 1/2-, 3/2- now
bool RooDalitzAmplitude::KMatrix(float mpp,
                                 int J_r,
                                 int P_r,
                                 std::vector<float> &g_alpha,
                                 std::vector<float> &f_scat,
                                 std::vector<TComplex> &Mtr) const // only for Pc
{
    float s = mpp * mpp;
    // consider maximum four pole.
    int Npole(0);
    std::vector<float> ms(Npmax + 1, 1); // Mulply of (M^2-s)//loop//ininal to 1

    float denorm(1);
    float m0, g0;
    int S, type, parity, LR;

    int ikm(1); // how many km terms, should be Npole(pole part)+Nchannel(fs)
    for (int ir = NR; ir < NR + NZ; ++ir) {
        S = (int)(_paraList[ir * nset + SPIN]);
        type = (int)(_paraList[ir * nset + TYPE]);
        parity = (int)(_paraList[ir * nset + PARITY]);
        if (type == KMATRIX && S == J_r && parity == P_r) {
            m0 = _paraList[ir * nset + MASS];
            denorm = 1.0;
            if (m0 > 0) {
                denorm = (m0 * m0 - s);
                if (fabs(denorm) < 1e-3)
                    denorm = 1e-3;
                Npole++;
                ms[0] *= denorm;
                for (int ip = 1; ip <= Npmax; ++ip) {
                    if (ip == ikm)
                        continue;
                    ms[ip] *= denorm;
                }
                ikm++;
            }
        }
    }
    int Lna(0);
    //  std::cout << "Number of pole g4 fs4 " << Npole << " " << g_alpha[4] << " " << f_scat[4] <<
    //  std::endl;;
    std::vector<float> mg; // Npole x NC
    ikm = 0;
    for (int i = 0; i < Npole; ++i) {
        for (int j = 0; j < NKMC; ++j) {
            mg.push_back(g_alpha[ikm++] * ms[i + 1]);
        }
    }
    //  std::cout << "g_alpha[0], f_scat[0] " << g_alpha[0] << " " << f_scat[0] << std::endl;
    float fs[NKMC][NKMC], kma[NKMC][NKMC];
    ikm = 0;
    for (int i = 0; i < NKMC; ++i) {
        for (int j = 0; j < NKMC; ++j) {
            fs[i][j] = f_scat[ikm++] * ms[0]; // here scatter term is fab constant
        }
    }

    for (int i = 0; i < NKMC; ++i) {
        for (int j = i; j < NKMC; ++j) {
            kma[i][j] = fs[i][j];
            for (int k = 0; k < Npole; ++k) {
                kma[i][j] += g_alpha[k * NKMC + i] * mg[k * NKMC + j];
            }
            kma[j][i] = kma[i][j];
        }
    }
    TComplex rho[NKMC]; // do calculation here======needed
    if (P_r == -1) {
        rho[0] = getrho(s, Km1[0], Km2[0]);
        if (1 == J_r) {
#ifdef ComplexMassSwave
            rho[1] = getrho_complexMass(s, TComplex(Km1[1], 0.), TComplex(Km2[1], Sigmac_width));
            rho[2] = getrho_complexMass(s, TComplex(Km1[2], 0.), TComplex(Km2[2], Sigmacst_width));
            rho[3] = getrho_complexMass(s, TComplex(Km1[3], 0.), TComplex(Km2[3], Sigmac_width));
#else
            rho[1] = getrho(s, Km1[1], Km2[1]);
            rho[2] = getrho(s, Km1[2], Km2[2]);
            rho[3] = getrho(s, Km1[3], Km2[3]);
#endif
            // std::cout << "one Channel " << Km1[3] << "--" << Km2[3] << std::endl;
        } else if (3 == J_r) {
#ifdef ComplexMassSwave
            rho[1] = getrho_complexMass(s, TComplex(Km1[1], 0.), TComplex(Km2[1], Sigmac_width));
            rho[2] = getrho_complexMass(s, TComplex(Km1[2], 0.), TComplex(Km2[2], Sigmacst_width));
            rho[3] = getrho_complexMass(s, TComplex(Km1[4], 0.), TComplex(Km2[4], Sigmacst_width));
#else
            rho[1] = getrho(s, Km1[1], Km2[1]);
            rho[2] = getrho(s, Km1[2], Km2[2]);
            rho[3] = getrho(s, Km1[4], Km2[4]);
#endif
            //  std::cout << "one Channel " << Km1[4] << "--" << Km2[4] << std::endl;
        }
    } else {
        for (int i = 0; i < 2; ++i)
            rho[i] = getrho(s, Km1[i], Km2[i], 1);
        for (int i = 2; i < NKMC; ++i)
            rho[i] = getrho(s, Km1[i + 1], Km2[i + 1], 1);
        Lna = 1;
    }
    TComplex KK[NKMC][NKMC];
    for (int i = 0; i < NKMC; i++) {
        for (int j = 0; j < NKMC; j++) {
            KK[i][j] = -TComplex(0., 1.) * rho[j] * double(kma[i][j]);
            if (i == j)
                KK[i][j] += double(ms[0]);
        }
    }
    SMatrixNN A, IB;
    for (int i = 0; i < NKMC; i++) {
        for (int j = 0; j < NKMC; j++) {
            IB(i, j) = KK[i][j].Re();
            A(i, j) = -KK[i][j].Im();
        }
    }
    int ifail;
    SMatrixNN IIB = IB.Inverse(ifail);
    if (ifail)
        std::cout << "inverse matrix failed 1" << std::endl;
    SMatrixNN RR = (IB + A * IIB * A);
    SMatrixNN IRR = RR.Inverse(ifail);
    if (ifail) {
        std::cout << "inverse matrix failed 2 mjpsip " << sqrt(s) << std::endl;
        std::cout << RR << std::endl;
        std::cout << IRR << std::endl;
        /*    float RRnew[NKMC][NKMC],IRRnew[NKMC][NKMC];
            for(int i=0; i<NKMC; i++) {
              for(int j=0; j<NKMC; j++) {
                RRnew[i][j]=RR(i,j);
              }
            }
            invert4x4(*(*(&RRnew)),*(*(&IRRnew)));
            for(int i=0; i<NKMC; i++) {
              for(int j=0; j<NKMC; j++) {
                std::cout << IRRnew[i][j] << " "  ;
              }
              std::cout << std::endl;
            }    */
    }
    SMatrixNN IM = IIB * A * IRR;
    TComplex T[NKMC];

    // first raw for Jpsi p
    Mtr.clear();
    Mtr.resize(NKMC + Npole, 0);
    for (int i = 0; i < NKMC; ++i) {
        T[i] = TComplex(IRR(0, i), IM(0, i));
        // Mtr.push_back(0);
    }
    float na = 1.0f;
    if (Lna >= 1)
        na = getFBW2(s, Km1[0], Km2[0], Lna);
    for (int ip = 0; ip < Npole; ++ip) {
        for (int i = 0; i < NKMC; ++i) {
            Mtr[ip] += T[i] * double(mg[ip * NKMC + i]);
        }
        Mtr[ip] *= double(na);
    }
    for (int i = 0; i < NKMC; ++i) {
        Mtr[Npole + i] = T[i] * double(ms[0] * na);
    }

    //  std::cout << "Mtr[0] " << Mtr[0] << std::endl;
    return true;
}

bool RooDalitzAmplitude::Revised_KMAMP(
    float mpp, int nr, int irst, int ired, float &ampl_r, float &ampl_i, bool isPcChain) const {
    float m2pp = mpp * mpp;
    float m1, m2, m3;
    float m1_0, m2_0, m3_0;
    //  switch(iType) {
    //  case 0: //k*
    m1 = m_p;
    m2 = m_pi;
    m3 = m_jpsi;
    m1_0 = m_p;
    m2_0 = m_pi;
    m3_0 = m_jpsi;
    if (isPcChain) {
        m1 = m_jpsi;
        m2 = m_p;
        m3 = m_pi;
        m1_0 = m_jpsi;
        m2_0 = m_p;
        m3_0 = m_pi;
    }
    //    break;
    //  }

    int L_r, J_r, P_r, type_r;
    float m_r, gamma_r;
    m_r = _paraList[nr * nset + MASS];
    gamma_r = _paraList[nr * nset + WIDTH];
    J_r = (int)(_paraList[nr * nset + SPIN]);
    L_r = (int)(_paraList[nr * nset + LRESON]);
    type_r = (int)(_paraList[nr * nset + TYPE]);
    P_r = (int)(_paraList[nr * nset + PARITY]);
    float totG(0);
    float fsc(0);
    float denorm(1);
    float m0, g0;
    int S, type, parity, LR;
    if (m_r > 0)
        denorm = (m_r * m_r - m2pp);
    for (int ir = irst; ir < ired; ++ir) {
        m0 = _paraList[ir * nset + MASS];
        g0 = _paraList[ir * nset + WIDTH];
        S = (int)(_paraList[ir * nset + SPIN]);
        LR = (int)(_paraList[ir * nset + LRESON]);
        type = (int)(_paraList[ir * nset + TYPE]);
        parity = (int)(_paraList[ir * nset + PARITY]);
        if (type == type_r && S == J_r && parity == P_r) {
            if (ir == nr)
                continue;
            totG += KMatrixTerm(m0, g0, mpp, LR, fsc) * denorm;
        }
    }
    float pR = getp(mpp, m1, m2);
    float pR0, mreff;
    if (m_r > m1_0 + m2_0) {
        mreff = m_r;
    } else if (m_r >= 0) {
        float mmin = m1_0 + m2_0;
        float mmax = m_lb - m3_0;
        mreff =
            mmin + 0.5 * (mmax - mmin) * (1.0 + tanh((m_r - (mmin + mmax) / 2.) / (mmax - mmin)));
    } else { // NR
        mreff = (m1_0 + m2_0 + m_lb - m3) / 2.0;
    }
    pR0 = getp(mreff, m1_0, m2_0);
    float FR = F_BW(_FFR, L_r, pR, pR0);
    float factor = FR * pow((pR / pR0), L_r);
    float d2, dx, dy; // = 1.+term*term;
    // for NR no more factor in the bracket {}
    if (m_r > 0) {
        float gamma = gamma_r;
        if (m_r > m1_0 + m2_0)
            gamma = gamma_r * pow((pR / pR0), 2 * L_r + 1) * (m_r / mpp) * FR * FR;
        if (m_r < m1_0 + m2_0) { // Only validate for 1405 !!
            float msig = 1.18937;
            float mpi0 = 0.13957018;
            float pRSigPi = getp(mpp, msig, mpi0);
            // wehre LR = 0;
            gamma = 0.0;
            pR0 = getp(m_r, msig, mpi0);
            FR = 1.0;
            gamma += gamma_r * pow((pR / pR0), 2 * L_r + 1) * (m_r / mpp) * FR * FR;
            FR = 1.0;
            gamma += 0.0505 * pow((pRSigPi / pR0), 2 * L_r + 1) * (m_r / mpp) * FR * FR;
            // Additional f22 term for denorm
            denorm = denorm -
                     fsc * 0.0505 * pow((pRSigPi / pR0), 2 * L_r + 1) * (m_r / mpp) * FR * FR * m_r;
        }
        totG += m_r * gamma;
        float kr = sqrt(m_r * m_r + gamma_r * gamma_r);
        factor = factor * 0.948850 * m_r * sqrt(gamma_r * kr / sqrt(m_r * (m_r + kr)));
    } else { // For NR
             //     fsc = gamma_r;
        totG += gamma_r * pow((pR / pR0), 2 * L_r + 1) * (m_r / mpp) * FR *
                FR; // KMatrixTerm(m_r, gamma_r, mpp, L_r, fsc);
                    //     factor = factor * gamma_r; //here to be delete//zhanglm
    }
    d2 = denorm * denorm + totG * totG;
    //  dx = denorm + fsc*totG;
    //  dy = totG - fsc*denorm;
    dx = denorm;
    dy = totG;
    ampl_r = dx / d2 * factor;
    ampl_i = dy / d2 * factor;
    return true;
}

float RooDalitzAmplitude::KMatrixTerm(
    float m_r, float gamma_r, float mpp, int LR, float &fsc) const {

    float m2pp = mpp * mpp;
    float m1, m2, m3;
    float m1_0, m2_0, m3_0;
    //  switch(iType) {
    //  case 0: //L*
    m1 = m_p;
    m2 = m_pi;
    m3 = m_jpsi;
    m1_0 = m_p;
    m2_0 = m_pi;
    m3_0 = m_jpsi;
    //    break;
    //
    //  }
    float pR = getp(mpp, m1, m2);
    float pR0, mreff;
    if (m_r > m1_0 + m2_0) {
        mreff = m_r;
    } else if (m_r >= 0) {
        float mmin = m1_0 + m2_0;
        float mmax = m_lb - m3_0;
        mreff =
            mmin + 0.5 * (mmax - mmin) * (1.0 + tanh((m_r - (mmin + mmax) / 2.) / (mmax - mmin)));
    } else { // NR
        mreff = (m1_0 + m2_0 + m_lb - m3) / 2.0;
    }
    pR0 = getp(mreff, m1_0, m2_0);
    float FR = F_BW(_FFR, LR, pR, pR0);
    ;
    float gamma = gamma_r;
    // if(m_r>m1_0+m2_0)
    gamma = gamma_r * pow((pR / pR0), 2 * LR + 1) * (m_r / mpp) * FR * FR;
    if (m_r < 0) {
        // changed:: 2020.12.27
        if (fabs(fsc) < 1e-10)
            fsc = gamma;
        return fsc; // gamma_r as fsc;
    }
    // if(iType==1&&m_r<4.18) gamma = gamma_r;
    if (fabs(m_r * m_r - m2pp) < 1e-10) {
        return 0;
    }
    return m_r * gamma / (m_r * m_r - m2pp);
}

Float_t RooDalitzAmplitude::getp(float M, float m1, float m2) const {
    float M2 = M * M;
    //  if(M<m1+m2) std::cout << "why M<m1+m2" << std::endl;
    // return sqrt((M2-pow(m1+m2,2))*(M2-pow(m1-m2,2)))/2./M;
    return sqrt(fabs((M2 - pow(m1 + m2, 2)) * (M2 - pow(m1 - m2, 2)))) / 2. / M;
}

TComplex RooDalitzAmplitude::getrho(float M2, float m1, float m2, int L) const {
    TComplex rho2 = (M2 - pow(m1 + m2, 2)) * (M2 - pow(m1 - m2, 2));
    return TComplex::Sqrt(rho2) * (1. / M2) * double(getFBW2(M2, m1, m2, L));
}

TComplex RooDalitzAmplitude::getrho_complexMass(float M2, TComplex m1, TComplex m2, int L) const {
    TComplex rho2 = (M2 - (m1 + m2) * (m1 + m2)) * (M2 - (m1 - m2) * (m1 - m2));
    if (fabs(rho2.Im() / rho2.Re()) < 0.001)
        rho2 = TComplex(rho2.Re(), fabs(rho2.Im()));
    return TComplex::Sqrt(rho2) * (1. / M2) * (getFBW2_complexMass(M2, m1, m2, L));
}

Float_t RooDalitzAmplitude::getFBW2(float M2, float m1, float m2, int L) const {
    if (L == 0)
        return 1.0;
    float p2 = (M2 - pow(m1 + m2, 2)) * (M2 - pow(m1 - m2, 2)) / M2 / 4.;
    float M20 = 5.0 * 5.0;
    float p20 = (M20 - pow(m1 + m2, 2)) * (M20 - pow(m1 - m2, 2)) / M20 / 4.;
    return pow(p2 / p20, L) * F_BW2(_FFB, L, p2, p20);
}

TComplex RooDalitzAmplitude::getFBW2_complexMass(float M2, TComplex m1, TComplex m2, int L) const {
    if (L == 0)
        return TComplex(1.0, 0.);
    TComplex p2 = (M2 - (m1 + m2) * (m1 + m2)) * (M2 - (m1 - m2) * (m1 - m2)) / M2 / 4.;
    float M20 = 5.0 * 5.0;
    TComplex p20 = (M20 - (m1 + m2) * (m1 + m2)) * (M20 - (m1 - m2) * (m1 - m2)) / M20 / 4.;
    if (L == 1)
        return p2 / p20 * F_BW2_complexMass(_FFB, L, p2, p20);
    if (L == 2)
        return p2 / p20 * p2 / p20 * F_BW2_complexMass(_FFB, L, p2, p20);
    if (L == 3)
        return p2 / p20 * p2 / p20 * p2 / p20 * F_BW2_complexMass(_FFB, L, p2, p20);
    if (L == 4)
        return p2 / p20 * p2 / p20 * p2 / p20 * p2 / p20 * F_BW2_complexMass(_FFB, L, p2, p20);
    std::cout << "getFBW2_complexMass bug in CPU sector. I cannot handle L>4" << std::endl;
    return TComplex(-9999., 100000.);
    //  return pow(p2/p20, L) * F_BW2_complexMass(_FFB, L, p2, p20) ;
}

// void RooDalitzAmplitude::filldlz(Jpsihh_dlz &dlz, Double_t xmppi, Double_t xcostheta,
//                  Double_t xcostheta1, Double_t xcostheta2,
//                  Double_t xphi1, Double_t xphi2,
//                  Double_t xcosthetaB, Double_t xcosthetaZ, Double_t xcosthetaPsi,
//                  Double_t xphiZ, Double_t xphiPsi, Double_t xphiMu,
//                  Double_t xcosthetap, Double_t xalphaMu,
//                  Double_t xmjpsip,
//                  Double_t sw) const

void RooDalitzAmplitude::filldlz(Jpsihh_dlz &dlz,
                                 Double_t xmppi,
                                 Double_t xcostheta,
                                 Double_t xcostheta1,
                                 Double_t xcostheta2,
                                 Double_t xphi1,
                                 Double_t xphi2,
                                 Double_t xcosthetaB,
                                 Double_t xcosthetaZ,
                                 Double_t xcosthetaPsi,
                                 Double_t xphiZ,
                                 Double_t xphiPsi,
                                 Double_t xphiMu,
                                 Double_t xcosthetap,
                                 Double_t xalphaMu,
                                 Double_t xmjpsip,
                                 Double_t xcosthetaB_X,
                                 Double_t xcosthetaX_X,
                                 Double_t xcosthetaPsi_X,
                                 Double_t xphiX_X,
                                 Double_t xphiPsi_X,
                                 Double_t xphiMu_X,
                                 Double_t xcosthetap_X,
                                 Double_t xalphaMu_X,
                                 Double_t xmjpsipi,
                                 Double_t sw) const {
    dlz.mppi = xmppi;
    dlz.mjpsip = xmjpsip;
    dlz.mjpsipi = xmjpsipi;
    float theta = acos(xcostheta);
    float theta1 = acos(xcostheta1);
    float theta2 = acos(xcostheta2);

    float thetaB = acos(xcosthetaB);
    float thetaZ = acos(xcosthetaZ);
    float thetaPsi = acos(xcosthetaPsi);
    float thetap = acos(xcosthetap);
    dlz.w = sw;

    float thetaB_X = acos(xcosthetaB_X);
    float thetaX_X = acos(xcosthetaX_X);
    float thetaPsi_X = acos(xcosthetaPsi_X);
    float thetap_X = acos(xcosthetap_X);

    //  int nres = NR+NZ;

    float hel0, hel3;
    int delhelmu;
    float hel1, hel2;
    int S2;
    float S;
    TComplex AIndep;

    // fill mass and L* indepdent angular terms (except for dJ_lL,lp)
    for (int i = 0; i <= 1; ++i) { // del
        delhelmu = (i == 0) ? -1 : 1;
        for (int j = 0; j <= 1; ++j) { // hel0
            hel0 = (j == 0) ? -0.5 : 0.5;
            for (int m = 0; m < 6; ++m) {
                hel1 = (float)Hel1Two[m] / 2.;
                hel2 = Hel2[m];

                AIndep = MEangPart(hel0, delhelmu, hel1, hel2, xphi1, xphi2, theta, theta2);
                dlz.ARe[i][j][m] = AIndep.Re();
                dlz.AIm[i][j][m] = AIndep.Im();
            }
        }
    }
    // fill dfunction for L*
    for (int s = 0; s < 5; ++s) {
        S2 = 2 * s + 1;
        S = ((float)S2) / 2.;
        for (int k = 0; k <= 1; ++k) { // hel3= proton
            hel3 = (k == 0) ? -0.5 : 0.5;

            // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
            for (int m = 0; m < 6; ++m) {
                if (fabs(S - 0.5) < 1e-10 && m >= 4) {
                    dlz.DL[s][k][m] = 0;
                    continue;
                }
                hel1 = (float)Hel1Two[m] / 2.;
                // hel2 = Hel2[m];

                dlz.DL[s][k][m] = dfun(theta1, S, hel1, hel3);
            }
        }
    }

    float help, helZ;

    // Rj BW here
    for (int i = 0; i <= 1; ++i) { // delmu
        delhelmu = (i == 0) ? -1 : 1;
        for (int j = 0; j <= 1; ++j) { // hel0
            hel0 = (j == 0) ? -0.5 : 0.5;

            // there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2,
            // help=+/-1/2
            int m(0);
            for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                for (int ihz = 0; ihz <= 1; ++ihz) {
                    helZ = (ihz == 0) ? -0.5 : 0.5;
                    for (int ihp = 0; ihp <= 1; ++ihp) {
                        help = (ihp == 0) ? -0.5 : 0.5;
                        //      if(fabs((float)helpsi-help)>S) continue;
                        AIndep = MEangZPart(hel0,
                                            delhelmu,
                                            helZ,
                                            helpsi,
                                            xphiZ,
                                            xphiMu,
                                            xphiPsi,
                                            xalphaMu,
                                            thetaB,
                                            thetaPsi);
                        dlz.AZRe[i][j][m] = AIndep.Re();
                        dlz.AZIm[i][j][m] = AIndep.Im();
                        m++;
                    }
                }
            }
        }
    }

    for (int s = 0; s < 4; ++s) {
        S2 = 2 * s + 1;
        S = ((float)S2) / 2.;
        for (int k = 0; k <= 1; ++k) { // hel3 proton
            hel3 = (k == 0) ? -0.5 : 0.5;
            // there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2,
            // help=+/-1/2
            int m(0);

            for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                for (int ihz = 0; ihz <= 1; ++ihz) {
                    helZ = (ihz == 0) ? -0.5 : 0.5;
                    for (int ihp = 0; ihp <= 1; ++ihp) {
                        help = (ihp == 0) ? -0.5 : 0.5;
                        if (fabs((float)helpsi - help) > S) {
                            dlz.DZ[s][k][m] = 0;
                            m++;
                            continue;
                        }
                        dlz.DZ[s][k][m] = dfunhalf(thetap,
                                                   (int)(help * 2.),
                                                   (int)(hel3 * 2.)) * // hel3 = hel_p in /\*
                                          dfun(thetaZ, S, helZ, (float)helpsi - help);
                        m++;
                    }
                }
            }
        }
    }

    //      Zcs chain
    for (int i = 0; i <= 1; ++i) { // delmu
        delhelmu = (i == 0) ? -1 : 1;
        for (int j = 0; j <= 1; ++j) { // hel0
            hel0 = (j == 0) ? -0.5 : 0.5;

            int m(0);
            for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                //              if(abs(helpsi)>S) continue;
                for (int ihp = 0; ihp <= 1; ++ihp) { // In Lb rest frame
                    help = (ihp == 0) ? -0.5 : 0.5;
                    for (int ihz = 0; ihz <= 1; ++ihz) {
                        helZ = (ihz == 0) ? help - 0.5 : help + 0.5;
                        //                  if(fabs(helZ)>S) continue;
                        AIndep =
                            MEangXPart(hel0,
                                       delhelmu,
                                       helZ,
                                       helpsi,
                                       help,
                                       xphiX_X,
                                       xphiMu_X,
                                       xphiPsi_X,
                                       xalphaMu_X,
                                       thetaB_X,
                                       thetaPsi_X); // hel0,delhelmu, helZ, helpsi, xphiZ, xphiMu,
                                                    // xphiPsi, xalphaMu, thetaB, thetaPsi);
                        dlz.AXRe[i][j][m] = AIndep.Re();
                        dlz.AXIm[i][j][m] = AIndep.Im();
                        m++;
                    }
                }
            }
        }
    }

    for (int s = 0; s < 4; ++s) {
        S2 = 2 * s;
        S = ((float)S2) / 2.;
        for (int k = 0; k <= 1; ++k) { // hel3 proton
            hel3 = (k == 0) ? -0.5 : 0.5;
            // there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2,
            // help=+/-1/2
            int m(0);

            for (int helpsi = -1; helpsi <= 1; ++helpsi) {
                if (abs(helpsi) > S)
                    continue;
                for (int ihp = 0; ihp <= 1; ++ihp) {
                    help = (ihp == 0) ? -0.5 : 0.5;
                    for (int ihz = 0; ihz <= 1; ++ihz) {
                        helZ = (ihz == 0) ? help - 0.5 : help + 0.5;
                        if (fabs(helZ) > S)
                            continue;
                        //                    if(fabs((float)helpsi-help)>S) { dlz.DZ[s][k][m]=0;
                        //                    m++; continue; }
                        dlz.DX[s][k][m] = dfunhalf(thetap_X,
                                                   (int)(help * 2.),
                                                   (int)(hel3 * 2.)) * // hel3 = hel_p in /\*
                                          dfun(thetaX_X, S, helZ, (float)(-1 * helpsi));
                        m++;
                    }
                }
            }
        }
    }
}

//****** The following is added by chenchen to calculate SUM********/

RooAbsReal *RooDalitzAmplitude::createSUM(RooAbsData &data,
                                          const RooCmdArg &arg1,
                                          const RooCmdArg &arg2,
                                          const RooCmdArg &arg3,
                                          const RooCmdArg &arg4,
                                          const RooCmdArg &arg5,
                                          const RooCmdArg &arg6,
                                          const RooCmdArg &arg7,
                                          const RooCmdArg &arg8) {
    // Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an
    // unbinned likelihood is constructed. If the dataset is binned, a binned likelihood is
    // constructed.
    //
    // The following named arguments are supported
    //
    // ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables
    // Extended(Bool_t flag)           -- Add extended likelihood term, off by default
    // Range(const char* name)         -- Fit only data inside range with given name
    // Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named "fit" is
    // created on the fly on all observables.
    //                                    Multiple comma separated range names can be specified.
    // SumCoefRange(const char* name)  -- Set the range in which to interpret the coefficients of
    // RooAddPdf components NumCPU(int num, int strat)      -- Parallelize NLL calculation on num
    // CPUs
    //
    //                                    Strategy 0 = RooFit::BulkPartition (Default) --> Divide
    //                                    events in N equal chunks Strategy 1 = RooFit::Interleave
    //                                    --> Process event i%N in process N. Recommended for binned
    //                                    data with
    //                                                 a substantial number of zero-bins, which will
    //                                                 be distributed across processes more
    //                                                 equitably in this strategy
    //                                    Strategy 2 = RooFit::SimComponents --> Process each
    //                                    component likelihood of a RooSimultaneous fully in a
    //                                    single process
    //                                                 and distribute components over processes.
    //                                                 This approach can be benificial if
    //                                                 normalization calculation time dominates the
    //                                                 total computation time of a component (since
    //                                                 the normalization calculation must be
    //                                                 performed in each process in strategies 0
    //                                                 and 1. However beware that if the
    //                                                 RooSimultaneous components do not share many
    //                                                 parameters this strategy is inefficient: as
    //                                                 most minuit-induced likelihood calculations
    //                                                 involve changing a single parameter, only 1
    //                                                 of the N processes will be active most of the
    //                                                 time if RooSimultaneous components do not
    //                                                 share many parameters
    //                                    Strategy 3 = RooFit::Hybrid --> Follow strategy 0 for all
    //                                    RooSimultaneous components, except those with less than
    //                                                 30 dataset entries, for which strategy 2 is
    //                                                 followed.
    //
    // Optimize(Bool_t flag)           -- Activate constant term optimization (on by default)
    // SplitRange(Bool_t flag)         -- Use separate fit ranges in a simultaneous fit. Actual
    // range name for each
    //                                    subsample is assumed to by rangeName_{indexState} where
    //                                    indexState is the state of the master index category of
    //                                    the simultaneous fit
    // Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint
    // terms, only apply constraints to given subset of parameters ExternalConstraints(const
    // RooArgSet& ) -- Include given external constraints to likelihood GlobalObservables(const
    // RooArgSet&) -- Define the set of normalization observables to be used for the constraint
    // terms.
    //                                        If none are specified the constrained parameters are
    //                                        used
    // GlobalObservablesTag(const char* tagName) -- Define the set of normalization observables to
    // be used for the constraint terms by a string attribute
    //                                              associated with pdf observables that match the
    //                                              given tagName
    // Verbose(Bool_t flag)           -- Constrols RooFit informational messages in likelihood
    // construction CloneData(Bool flag)           -- Use clone of dataset in SUM (default is true)
    // Offset(Bool_t)                  -- Offset likelihood by initial value (so that starting value
    // of FCN in minuit is zero). This
    //                                    can improve numeric stability in simultaneously fits with
    //                                    components with large likelihood values
    //
    //

    RooLinkedList l;
    l.Add((TObject *)&arg1);
    l.Add((TObject *)&arg2);
    l.Add((TObject *)&arg3);
    l.Add((TObject *)&arg4);
    l.Add((TObject *)&arg5);
    l.Add((TObject *)&arg6);
    l.Add((TObject *)&arg7);
    l.Add((TObject *)&arg8);
    return createSUM(data, l);
}

//_____________________________________________________________________________
RooAbsReal *RooDalitzAmplitude::createSUM(RooAbsData &data, const RooLinkedList &cmdList) {
    // Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an
    // unbinned likelihood is constructed. If the dataset is binned, a binned likelihood is
    // constructed.
    //
    // See RooAbsPdf::createSUM(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3,
    // RooCmdArg arg4,
    //                                    RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg
    //                                    arg8)
    //
    // for documentation of options

    // Select the pdf-specific commands
    RooCmdConfig pc(Form("RooAbsPdf::createSUM(%s)", GetName()));

    pc.defineString("rangeName", "RangeWithName", 0, "", kTRUE);
    pc.defineString("addCoefRange", "SumCoefRange", 0, "");
    pc.defineString("globstag", "GlobalObservablesTag", 0, "");
    pc.defineDouble("rangeLo", "Range", 0, -999.);
    pc.defineDouble("rangeHi", "Range", 1, -999.);
    pc.defineInt("splitRange", "SplitRange", 0, 0);
    pc.defineInt("ext", "Extended", 0, 2);
    pc.defineInt("numcpu", "NumCPU", 0, 1);
    pc.defineInt("interleave", "NumCPU", 1, 0);
    pc.defineInt("verbose", "Verbose", 0, 0);
    pc.defineInt("optConst", "Optimize", 0, 0);
    pc.defineInt("cloneData", "CloneData", 2, 0);
    pc.defineSet("projDepSet", "ProjectedObservables", 0, 0);
    pc.defineSet("cPars", "Constrain", 0, 0);
    pc.defineSet("glObs", "GlobalObservables", 0, 0);
    pc.defineInt("constrAll", "Constrained", 0, 0);
    pc.defineInt("doOffset", "OffsetLikelihood", 0, 0);
    pc.defineSet("extCons", "ExternalConstraints", 0, 0);
    pc.defineMutex("Range", "RangeWithName");
    pc.defineMutex("Constrain", "Constrained");
    pc.defineMutex("GlobalObservables", "GlobalObservablesTag");

    // Process and check varargs
    pc.process(cmdList);
    if (!pc.ok(kTRUE)) {
        return 0;
    }

    // Decode command line arguments
    const char *rangeName = pc.getString("rangeName", 0, kTRUE);
    const char *addCoefRangeName = pc.getString("addCoefRange", 0, kTRUE);
    const char *globsTag = pc.getString("globstag", 0, kTRUE);
    Int_t ext = pc.getInt("ext");
    Int_t numcpu = pc.getInt("numcpu");
    RooFit::MPSplit interl = (RooFit::MPSplit)pc.getInt("interleave");

    Int_t splitr = pc.getInt("splitRange");
    Bool_t verbose = pc.getInt("verbose");
    Int_t optConst = pc.getInt("optConst");
    Int_t cloneData = pc.getInt("cloneData");
    Int_t doOffset = pc.getInt("doOffset");

    // If no explicit cloneData command is specified, cloneData is set to true if optimization is
    // activated
    if (cloneData == 2) {
        cloneData = optConst;
    }

    RooArgSet *cPars = pc.getSet("cPars");
    RooArgSet *glObs = pc.getSet("glObs");
    if (pc.hasProcessed("GlobalObservablesTag")) {
        if (glObs)
            delete glObs;
        RooArgSet *allVars = getVariables();
        glObs = (RooArgSet *)allVars->selectByAttrib(globsTag, kTRUE);
        //    coutI(Minimization) << "User-defined specification of global observables definition
        //    with tag named '" <<  globsTag << "'" << endl ;
        delete allVars;
    } else if (!pc.hasProcessed("GlobalObservables")) {

        // Neither GlobalObservables nor GlobalObservablesTag has been processed - try if a default
        // tag is defined in the head node Check if head not specifies default global observable tag
        const char *defGlobObsTag = getStringAttribute("DefaultGlobalObservablesTag");
        if (defGlobObsTag) {
            coutI(Minimization) << "p.d.f. provides built-in specification of global observables "
                                   "definition with tag named '"
                                << defGlobObsTag << "'" << std::endl;
            if (glObs)
                delete glObs;
            RooArgSet *allVars = getVariables();
            glObs = (RooArgSet *)allVars->selectByAttrib(defGlobObsTag, kTRUE);
        }
    }

    Bool_t doStripDisconnected = kFALSE;

    // If no explicit list of parameters to be constrained is specified apply default algorithm
    // All terms of RooProdPdfs that do not contain observables and share a parameters with one or
    // more terms that do contain observables are added as constraints.
    if (!cPars) {
        cPars = getParameters(data, kFALSE);
        doStripDisconnected = kTRUE;
    }
    const RooArgSet *extCons = pc.getSet("extCons");

    // Process automatic extended option
    if (ext == 2) {
        ext = ((extendMode() == CanBeExtended || extendMode() == MustBeExtended)) ? 1 : 0;
        if (ext) {
            coutI(Minimization) << "p.d.f. provides expected number of events, including extended "
                                   "term in likelihood."
                                << std::endl;
        }
    }

    if (pc.hasProcessed("Range")) {
        Double_t rangeLo = pc.getDouble("rangeLo");
        Double_t rangeHi = pc.getDouble("rangeHi");

        // Create range with name 'fit' with above limits on all observables
        RooArgSet *obs = getObservables(&data);
        TIterator *iter = obs->createIterator();
        RooAbsArg *arg;
        while ((arg = (RooAbsArg *)iter->Next())) {
            RooRealVar *rrv = dynamic_cast<RooRealVar *>(arg);
            if (rrv)
                rrv->setRange("fit", rangeLo, rangeHi);
        }
        // Set range name to be fitted to "fit"
        rangeName = "fit";
    }

    RooArgSet projDeps;
    RooArgSet *tmp = pc.getSet("projDepSet");
    if (tmp) {
        projDeps.add(*tmp);
    }

    // Construct SUM
    RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::CollectErrors);
    RooAbsReal *nll;
    std::string baseName = Form("sum_%s_%s", GetName(), data.GetName());
    if (!rangeName || strchr(rangeName, ',') == 0) {
        // Simple case: default range, or single restricted range
        // cout<<"FK: Data test 1: "<<data.sumEntries()<<std::std::endl;

        nll = new RooSUMVar(baseName.c_str(),
                            "sum(likelihood)",
                            *this,
                            data,
                            projDeps,
                            ext,
                            rangeName,
                            addCoefRangeName,
                            numcpu,
                            interl,
                            verbose,
                            splitr,
                            cloneData);
    } else {
        // Composite case: multiple ranges
        RooArgList nllList;
        const size_t bufSize = strlen(rangeName) + 1;
        char *buf = new char[bufSize];
        strlcpy(buf, rangeName, bufSize);
        char *token = strtok(buf, ",");
        while (token) {
            RooAbsReal *nllComp = new RooSUMVar(Form("%s_%s", baseName.c_str(), token),
                                                "-log(likelihood)",
                                                *this,
                                                data,
                                                projDeps,
                                                ext,
                                                token,
                                                addCoefRangeName,
                                                numcpu,
                                                interl,
                                                verbose,
                                                splitr,
                                                cloneData);
            nllList.add(*nllComp);
            token = strtok(0, ",");
        }
        delete[] buf;
        nll = new RooAddition(baseName.c_str(), "sum(likelihood)", nllList, kTRUE);
    }
    RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::PrintErrors);

    // Collect internal and external constraint specifications
    RooArgSet allConstraints;
    if (cPars && cPars->getSize() > 0) {
        RooArgSet *constraints = getAllConstraints(*data.get(), *cPars, doStripDisconnected);
        allConstraints.add(*constraints);
        delete constraints;
    }
    if (extCons) {
        allConstraints.add(*extCons);
    }

    /*  // Include constraints, if any, in likelihood
  RooAbsReal* nllCons(0) ;
  if (allConstraints.getSize()>0 && cPars) {

    coutI(Minimization) << " Including the following contraint terms in minimization: " <<
  allConstraints << std::endl ; if (glObs) { coutI(Minimization) << "The following global
  observables have been defined: " << *glObs << std::endl ;
    }
    nllCons = new RooConstraintSum(Form("%s_constr",baseName.c_str()),"nllCons",allConstraints,glObs
  ? *glObs : *cPars) ; nllCons->setOperMode(ADirty) ; RooAbsReal* orignll = nll ;

    nll = new
  RooAddition(Form("%s_with_constr",baseName.c_str()),"nllWithCons",RooArgSet(*nll,*nllCons)) ;
    nll->addOwnedComponents(RooArgSet(*orignll,*nllCons)) ;
  }

  */
    if (optConst) {
        nll->constOptimizeTestStatistic(RooAbsArg::Activate, optConst > 1);
    }

    if (doStripDisconnected) {
        delete cPars;
    }

    if (doOffset) {
        nll->enableOffsetting(kTRUE);
    }

    return nll;
}
