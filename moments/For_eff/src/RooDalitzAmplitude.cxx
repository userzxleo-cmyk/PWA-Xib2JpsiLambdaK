/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 
#include "RooTDalitz/RooDalitzAmplitude.h"
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "TMatrixD.h"
#include "TIterator.h"
#include "RooRandom.h"
#include "TTree.h"
#include "TFile.h"
#include "RooFit.h"
#include "RooMsgService.h" 
#include "TClass.h"
#include "Riostream.h"
#include "TObjString.h"
#include "TPaveText.h"
#include "TList.h"
#include "TH1.h"
#include "TH2.h"
#include "TMatrixD.h"
#include "TMatrixDSym.h"
#include "RooAbsPdf.h"
#include "RooDataSet.h"
#include "RooArgSet.h"
#include "RooArgProxy.h"
#include "RooRealProxy.h"
#include "RooRealVar.h"
#include "RooGenContext.h"
#include "RooBinnedGenContext.h"
#include "RooPlot.h"
#include "RooCurve.h"
#include "RooNLLVar.h"
#include "RooTDalitz/RooSUMVar.h"
#include "RooMinuit.h"
#include "RooCategory.h"
#include "RooNameReg.h"
#include "RooCmdConfig.h"
#include "RooGlobalFunc.h"
#include "RooAddition.h"
#include "RooRandom.h"
#include "RooNumIntConfig.h"
#include "RooProjectedPdf.h"
#include "RooInt.h"
#include "RooCustomizer.h"
#include "RooConstraintSum.h"
#include "RooParamBinning.h"
#include "RooNumCdf.h"
#include "RooFitResult.h"
#include "RooNumGenConfig.h"
#include "RooCachedReal.h"
#include "RooXYChi2Var.h"
#include "RooChi2Var.h"
#include "RooMinimizer.h"
#include "RooRealIntegral.h"
#include "Math/CholeskyDecomp.h"
#include <string>

#define PAW

//For integration
//TComplex AA[2][2][2][MYRN][MYRN][6][6];
//TComplex AAZ[2][2][2][MYZN][MYZN][12][12];
//TComplex ABZ[2][2][2][MYZN][MYRN][12][6];
TComplex amp[MYRN][2][2][2][6];
TComplex ampZ[MYZN][2][2][2][12];
//Double_t sumW;

//ClassImp(RooDalitzAmplitude) 

//CG (1,1,L,S,0,1) S=1,3,5,7,9,11, L= S-1, S+1
Double_t C2[6][2] = {
1.0000000000000000e+00,
-5.7735026918962584e-01,
-5.7735026918962573e-01,
4.4721359549995765e-01,
4.4721359549995754e-01,
-3.7796447300922748e-01,
-3.7796447300922759e-01,
3.3333333333333659e-01,
3.3333333333332898e-01,
-3.0151134457775197e-01,
-3.0151134457772666e-01,
2.7735009811269257e-01};


//ClassImp(RooDalitzAmplitude) 

Int_t Hel1Two[] = {1,1,-1,-1,3,-3};
Int_t Hel2[] = {1,0,0,-1,1,-1};
Double_t _FFR(3.0);
Double_t _FFB(3.0);
RooDalitzAmplitude::RooDalitzAmplitude(const char *name, 
				       const char *title, 
				       RooArgList& values,
				       TList* resList,
				       TList* resListZ,
				       const TString mcdata,
				       RooDataSet &data,
				       bool isPP,
				       bool isCach) :
  RooAbsPdf(name,title), 
  _values("values","values",this),
  _resList(resList),
  _resListZ(resListZ),
  resParams("resParams", "Parameters for resonaces", this),
  _isPP(isPP),
  _isCach(isCach),
  CG1(1,2),
  CG3(3,2),
  CG5(5,2),
  CG7(7,2),
  CG9(9,2),
  CG21(2,1),
  CG41(4,1),
  CG03(0,3),
  CG23(2,3),
  CG43(4,3),
  CG63(6,3),
  m_random(0),
   mKp_min(0.0), mKp_max(0.0),
     mc_nBinX(50), mc_nBinY(50),
     mc_cos_wBinY(0), mc_phi_wBinY(0), mc_wBinX(0),
     mc_npoint(4),
     bkg_nBinX(10), bkg_nBinY(10),
     bkg_cos_wBinY(0), bkg_phi_wBinY(0), bkg_wBinX(0),
     bkg_npoint(4)  
  // MCDATA(mcdata)
{ 
  m_random.SetSeed();
  //TChain  //TChain
  char cname[20];
  char swname[20];
  sprintf(cname,"h1");
  sprintf(swname,"sw");
  int mcflat(0);
  if(mcdata.Contains("MCFlatAcc")) {
    sprintf(cname,"MyTuple");
    sprintf(swname,"nsig_sw");
    mcflat = 1;
  }

  TChain *smcdata = new TChain(cname);
  smcdata->Add(mcdata);

  m_lb = 5.6195;
  m_k = 0.493677;
  m_p = 0.938272046;
  m_jpsi = 3.096916;
  TIterator* coefIter1 = values.createIterator();
  RooAbsArg* coef;
  
  while( (coef = (RooAbsArg*)coefIter1->Next()) ){
    if( !dynamic_cast<RooAbsReal*>(coef) ){
      assert(0);
    }
    _values.add(*coef);
  }

  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    //for (int i=0; i<nres; i++) {
    //RooDalitzResonance *res = (RooDalitzResonance*)_resList->At( ires );
    
    //     RooArgList *ires = (RooArgList*)_resList->At( i );
    RooArgList ires = (*Ires);
    for(int i=0; i<ires.getSize()-3; ++i) resParams.add(ires[i]);
  }

  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    //for (int i=0; i<nres; i++) {
    //RooDalitzResonance *res = (RooDalitzResonance*)_resList->At( ires );
    
    //     RooArgList *ires = (RooArgList*)_resList->At( i );
    RooArgList ires = (*Ires);
    resParams.add(ires[0]);
    resParams.add(ires[1]);
    resParams.add(ires[2]);
    resParams.add(ires[3]);
    resParams.add(ires[4]);
    resParams.add(ires[5]);
    resParams.add(ires[6]);
    resParams.add(ires[7]);
    resParams.add(ires[8]);
    resParams.add(ires[9]);    
  }

  NR = _resList->GetSize();
  NZ = _resListZ->GetSize();
  int nres = NR+NZ;
  std::cout << "Number of Resonances " << nres << std::endl;
  //each set to 2 parms.
  int ncached = 2*nres;
  _resParCache = new Double_t[ncached];
  for (int i=0; i<ncached; i++) _resParCache[i]=0;

  assert(nres<=MYRN+MYZN);

  double costheta, costheta1,costheta2,phi1,phi2;
  double mkp,sw, mjpsip;
  double phiZ;
  double phiMu;
  double phiPsi;
  double alphaMu;
  double costhetaB;
  double costhetaPsi;
  double costhetaZ;
  double costhetap;

  smcdata->SetBranchAddress("mkp", &mkp);
  smcdata->SetBranchAddress("mjpsip", &mjpsip);
  smcdata->SetBranchAddress("cosTheta_Lb", &costheta);
  smcdata->SetBranchAddress("cosTheta_L", &costheta1);
  smcdata->SetBranchAddress("cosTheta_Jpsi", &costheta2);
//  
  smcdata->SetBranchAddress("phiK", &phi1);
  smcdata->SetBranchAddress("phiMu", &phi2);
  smcdata->SetBranchAddress("Z_cosTheta_Lb", &costhetaB);
  smcdata->SetBranchAddress("Z_cosTheta_Z", &costhetaZ);
  smcdata->SetBranchAddress("Z_cosTheta_Jpsi", &costhetaPsi);
  smcdata->SetBranchAddress("Z_phiZ", &phiZ);
  smcdata->SetBranchAddress("Z_phiJpsi", &phiPsi);
  smcdata->SetBranchAddress("Z_phiMu", &phiMu);
  smcdata->SetBranchAddress("cosTheta_p", &costhetap);
  smcdata->SetBranchAddress("alpha_Mu", &alphaMu);
  int hassw = smcdata->SetBranchAddress(swname, &sw);
  std::cout << "hassw " << hassw << std::endl;
  int smcnum = smcdata->GetEntries();
  if(mcflat==1) smcnum = 1000000;
  sumW = 0.0;
//  pdlz->reserve(smcnum);
//  pdlz = new std::vector<Jpsihh_dlz>();
//  PDLZ = new std::vector<Jpsihh_dlz>();
  pdlz = std::make_shared<std::vector<Jpsihh_dlz>>();
  PDLZ = std::make_shared<std::vector<Jpsihh_dlz>>();  
  for(int imc=0; imc<smcnum; imc++) {
    smcdata->GetEntry(imc);
    //mkp>2GeV
    if(mcflat==1) sw = 1.0;
    if(!kine_limits(mkp)) continue;
   if(!kine_limitsZ(mjpsip)) continue;
    Jpsihh_dlz xdlz;// = new Jpsihh_dlz();
    filldlz(xdlz, mkp, costheta, costheta1, costheta2, phi1, phi2,
	    costhetaB,costhetaZ,costhetaPsi,phiZ,phiPsi,phiMu,costhetap,alphaMu,
	    mjpsip,
	    sw);
    sumW += sw;
    pdlz->push_back(xdlz);
  }
  
  std::cout << "INT MC size " << pdlz->size() << " " << pdlz->capacity() << std::endl;
  
  delete coefIter;
  delete coefIterZ;
  delete coefIter1;
  RooArgSet *row;  
  smcnum = data.numEntries();
//  PDLZ->reserve(smcnum);
  if(_isCach) {
  for(int i=0; i<smcnum; ++i) {
    row = (RooArgSet *)data.get(i);
    Jpsihh_dlz xdlz;// = new Jpsihh_dlz();
    //row->Print("V");
    mkp = ((RooAbsReal*)row->find("mkp"))->getVal();
    // if(!kine_limits(mkp)) { std::cout << "why " << std::endl;}
    
    costheta =  ((RooAbsReal*)row->find("cosTheta_Lb"))->getVal();
    costheta1 = ((RooAbsReal*)row->find("cosTheta_L"))->getVal();
    costheta2 = ((RooAbsReal*)row->find("cosTheta_Jpsi"))->getVal();
    phi1 = ((RooAbsReal*)row->find("phiK"))->getVal();
    phi2 = ((RooAbsReal*)row->find("phiMu"))->getVal();
    costhetaB = ((RooAbsReal*)row->find("Z_cosTheta_Lb"))->getVal();
    costhetaZ = ((RooAbsReal*)row->find("Z_cosTheta_Z"))->getVal();
    costhetaPsi = ((RooAbsReal*)row->find("Z_cosTheta_Jpsi"))->getVal();
    phiZ = ((RooAbsReal*)row->find("Z_phiZ"))->getVal();
    phiPsi = ((RooAbsReal*)row->find("Z_phiJpsi"))->getVal();
    phiMu = ((RooAbsReal*)row->find("Z_phiMu"))->getVal();
    costhetap = ((RooAbsReal*)row->find("cosTheta_p"))->getVal();
    alphaMu = ((RooAbsReal*)row->find("alpha_Mu"))->getVal();
    mjpsip = ((RooAbsReal*)row->find("mjpsip"))->getVal();
//    std::cout << i << " " << ((RooAbsReal*)row->find("index"))->getVal() << std::endl;
    //if(!kine_limitsZ(mjpsip) ) {std::cout << "why mjpsip" << std::endl;}
    //   double phi =  ((RooAbsReal&)row[6]).getVal();
//    std::cout << "to fill " << std::endl;
    filldlz(xdlz, mkp, costheta, costheta1, costheta2, phi1, phi2,
	    costhetaB,costhetaZ,costhetaPsi,phiZ,phiPsi,phiMu,costhetap,alphaMu,
	    mjpsip);
    PDLZ->push_back(xdlz);
  }
  } else {
    PDLZ->reserve(0);
  }
  std::cout << "Data size " << PDLZ->size() << " " << PDLZ->capacity() << std::endl;
  smcdata->Delete();
//  delete row;
  analyticalIntegral(7);
  //  IntegralMethod1();  
} 


RooDalitzAmplitude::RooDalitzAmplitude(const RooDalitzAmplitude& other, const char* name) :  
  RooAbsPdf(other,name), 
  _values("values",this,other._values),
  _resList(other._resList),
  _resListZ(other._resListZ),
  resParams("resParams", this, other.resParams),
  _isPP(other._isPP), _isCach(other._isCach),

  CG1(other.CG1),
  CG3(other.CG3),
  CG5(other.CG5),
  CG7(other.CG7),
  CG9(other.CG9),
  CG21(other.CG21),
  CG41(other.CG41),
  CG03(other.CG03),
  CG23(other.CG23),
  CG43(other.CG43),
  CG63(other.CG63),
  AA(other.AA),
  AAZ(other.AAZ),
  ABZ(other.ABZ),
//  amp(other.amp),
//  ampZ(other.ampZ),
  pdlz(other.pdlz),
  PDLZ(other.PDLZ),  
  m_random(other.m_random),
     mKp_min(other.mKp_min), mKp_max(other.mKp_max),
     mc_nBinX(other.mc_nBinX), mc_nBinY(other.mc_nBinY),
     mc_cos_wBinY(other.mc_cos_wBinY), mc_phi_wBinY(other.mc_phi_wBinY), mc_wBinX(other.mc_wBinX),
     mc_npoint(other.mc_npoint),
     bkg_nBinX(other.bkg_nBinX), bkg_nBinY(other.bkg_nBinY),
     bkg_cos_wBinY(other.bkg_cos_wBinY), bkg_phi_wBinY(other.bkg_phi_wBinY), bkg_wBinX(other.bkg_wBinX),
  bkg_npoint(other.bkg_npoint),
  mceff_cosLb(other.mceff_cosLb), mceff_cosL(other.mceff_cosL), mceff_cosJpsi(other.mceff_cosJpsi),
  mceff_phiMu(other.mceff_phiMu), mceff_phiK(other.mceff_phiK),
  bkgeff_cosLb(other.bkgeff_cosLb), bkgeff_cosL(other.bkgeff_cosL), bkgeff_cosJpsi(other.bkgeff_cosJpsi),
  bkgeff_phiMu(other.bkgeff_phiMu), bkgeff_phiK(other.bkgeff_phiK),     
  NR(other.NR), NZ(other.NZ),
  sumW(other.sumW),
  m_lb(other.m_lb), m_k(other.m_k),
  m_p(other.m_p), m_jpsi(other.m_jpsi)    
 { 
  int n= pdlz->size();
  std::cout << "new pdlz size " << n << std::endl;
//  pdlz = other.pdlz;
//  PDLZ = other.PDLZ;
   
     //TChain
   //smcdata = new TChain("mctree");
   // smcdata->Add(MCDATA);
   _resParCache = other._resParCache;
 } 



Bool_t RooDalitzAmplitude::kine_limits(double mpp) const
{
  if(mpp<m_k+m_p) return false;
  if(mpp>m_lb-m_jpsi) return false;
  return true;
}

Bool_t RooDalitzAmplitude::kine_limitsZ(double mjpsip) const
{
   if((mjpsip<m_jpsi+m_p) || (m_lb<mjpsip+m_k) ) return false;
   return true;
}

Double_t RooDalitzAmplitude::evaluate() const 
{ 

  int  index = (int)((RooAbsReal&)_values[_values.getSize()-1]).getVal();
  double inttt(-1);
  if(_norm) inttt = _norm->getVal();
//  std::cout << "zhanglm int of index " << index << " " << inttt << std::endl;
//  if(index==0) std::cout << "index " << std::endl;
  double TA1(0);
  if(_isCach&&index<PDLZ->size()) {
    Jpsihh_dlz &p = (*PDLZ)[index];
    double mkp = p.mkp;
    double mjpsip = p.mjpsip;    
    double mkp1 = ((RooAbsReal&)_values[0]).getVal();
    double mjpsip1 = ((RooAbsReal&)_values[14]).getVal();
    if(fabs(mkp-mkp1)<1e-20 && fabs(mjpsip1-mjpsip)<1e-20) {
      if(!kine_limits(mkp)) { std::cout << "why " << std::endl;return 0.0;}
      if(!kine_limitsZ(mjpsip) ) {std::cout << "why mjpsip" << std::endl;return 0.0;}
      TA1 =  GetAmp2s(p,1);
//  std::cout << "lzhang evaluate() for index " << index << std::endl;      
      return TA1;
    }
  }
//  std::cout << " no match " << std::endl;
  Jpsihh_dlz *xdlz1 = new Jpsihh_dlz();
  double mkp = ((RooAbsReal&)_values[0]).getVal();
  if(!kine_limits(mkp)) { std::cout << "why " << std::endl;return 0.0;}
  
  double costheta =  ((RooAbsReal&)_values[1]).getVal();
  double costheta1 = ((RooAbsReal&)_values[2]).getVal();
  double costheta2 = ((RooAbsReal&)_values[3]).getVal();
  double phi1 = ((RooAbsReal&)_values[4]).getVal();
  double phi2 = ((RooAbsReal&)_values[5]).getVal();
  double costhetaB = ((RooAbsReal&)_values[6]).getVal();
  double costhetaZ = ((RooAbsReal&)_values[7]).getVal();
  double costhetaPsi = ((RooAbsReal&)_values[8]).getVal();
  double phiZ = ((RooAbsReal&)_values[9]).getVal();
  double phiPsi = ((RooAbsReal&)_values[10]).getVal();
  double phiMu = ((RooAbsReal&)_values[11]).getVal();
  double costhetap = ((RooAbsReal&)_values[12]).getVal();
  double alphaMu = ((RooAbsReal&)_values[13]).getVal();
  double mjpsip = ((RooAbsReal&)_values[14]).getVal();
  if(!kine_limitsZ(mjpsip) ) {std::cout << "why mjpsip" << std::endl;return 0.0;}
  //   double phi =  ((RooAbsReal&)_values[6]).getVal();
  filldlz(*xdlz1, mkp, costheta, costheta1, costheta2, phi1, phi2,
	  costhetaB,costhetaZ,costhetaPsi,phiZ,phiPsi,phiMu,costhetap,alphaMu,
	  mjpsip);
  //   std::cout << "test1 " <<xdlz1.defed << std::endl;
  double TA =  GetAmp2s(*xdlz1);
//   std::cout << "test2 " << TA << " "<< TA1 << std::endl;
  delete xdlz1;

  return TA;
  // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
  //   return 1.0 ; 
} 


void RooDalitzAmplitude::genToy(const char *name, bool verbose) const 
{ 
//  char filename[100];
//  sprintf("toy%s.root",name);
  CalCoupling();   
  TFile *file = new TFile(TString::Format("toy%s.root",name).Data(),"recreate");
  TTree *tree = new TTree("tree","toy");
  double costheta, costheta1,costheta2,phi1,phi2,phi;
  double mkp,sw,w;
  double wl[MYRN+1], wz[MYZN+1];
  double mjpsip;
  double phiZ;
  double phiMu;
  double phiPsi;
  double alphaMu;
  double costhetaB;
  double costhetaPsi;
  double costhetaZ;
  double costhetap;
  tree->Branch("mkp", &mkp, "mkp/D");
  tree->Branch("mjpsip", &mjpsip, "mjpsip/D");  
  tree->Branch("costheta", &costheta, "costheta/D");
  tree->Branch("costheta1", &costheta1, "costheta1/D");
  tree->Branch("costheta2", &costheta2, "costheta2/D");
//  tree->Branch("phi", &phi, "phi/D");
  tree->Branch("phi1", &phi1, "phi1/D");
  tree->Branch("phi2", &phi2, "phi2/D");
  tree->Branch("Z_cosTheta_Lb", &costhetaB, "Z_cosTheta_Lb/D");
  tree->Branch("Z_cosTheta_Z", &costhetaZ, "Z_cosTheta_Z/D");
  tree->Branch("Z_cosTheta_Jpsi", &costhetaPsi, "Z_cosTheta_Jpsi/D");
  tree->Branch("Z_phiZ", &phiZ, "Z_phiZ/D");
  tree->Branch("Z_phiJpsi", &phiPsi, "Z_phiJpsi/D" );
  tree->Branch("Z_phiMu", &phiMu, "Z_phiMu/D");
  tree->Branch("cosTheta_p", &costhetap, "cosTheta_p/D" );
  tree->Branch("alpha_Mu", &alphaMu, "alpha_Mu/D");
  tree->Branch("w", &w, "w/D");
  tree->Branch("wL", &wl[0], "wL/D");
  tree->Branch("wZ", &wz[0], "wZ/D");
  if(verbose) {
    for(int ii=0; ii<NR; ++ii) 
      tree->Branch(TString("w")+TString((_resList->At(ii))->GetName()), &wl[ii+1], TString("w")+TString((_resList->At(ii))->GetName())+TString("/D"));
    for(int ii=0; ii<NZ; ++ii) 
      tree->Branch(TString("w")+TString((_resListZ->At(ii))->GetName()), &wz[ii+1], TString("w")+TString((_resListZ->At(ii))->GetName())+TString("/D"));   
  }
  int smcnum = pdlz->size();//smcdata->GetEntries();
  double inte(0.);
  for(int i=0; i<smcnum; i++) {
    
    //mkp>2GeV
    //if(mkp<2.0) continue;
    Jpsihh_dlz &p = (*pdlz)[i];
    
    //    filldlz(p, mkp, costheta, costheta1, costheta2, phi1, phi2, phi);
    double val =  GetAmp2s(p,1);    
    mkp = p.mkp; 
    mjpsip = p.mjpsip;
    costheta = cos(p.theta);
    costheta1 = cos(p.theta1);
    costheta2 = cos(p.theta2);
    phi1 = p.phi1;
    phi2 = p.phi2;
    phiZ = p.phiZ;
    phiMu = p.phiMu;
    phiPsi = p.phiPsi;
    alphaMu = p.alphaMu;
    costhetaB = cos(p.thetaB);
    costhetaPsi = cos(p.thetaPsi);
    costhetaZ = cos(p.thetaZ);
    costhetap = cos(p.thetap);
    //  dlz.phi = xphi;
    
    double sweight = p.w;
    w= val*sweight;
//    w = val;
    //calculcate each wi
    wl[0] = GetAmp2sForInt(p,-1,1) * sweight;
    wz[0] = GetAmp2sForInt(p,-1,2) * sweight;
    if(verbose) {    
      for(int ii=0; ii<NR; ++ii) 
        wl[ii+1] = GetAmp2sForInt(p,ii) * sweight;
      for(int ii=0; ii<NZ; ++ii) 
        wz[ii+1] = GetAmp2sForInt(p,ii+NR) * sweight;
    }
    tree->Fill();
  }
  tree->Write();
  file->Close();
  
}

void RooDalitzAmplitude::genToyNoACC(const char *name) const 
{ 
//  char filename[100];
//  sprintf("toy%s.root",name);

/*  TFile *file = new TFile(TString::Format("toynoacc%s.root",name).Data(),"recreate");
  TTree *tree = new TTree("tree","toy");
  double costheta, costheta1,costheta2,phi1,phi2,phi;
  double mkp,sw,w;
  double mjpsip;
  tree->Branch("mkp", &mkp, "mkp/D");
//  tree->Branch("mjpsip", &mjpsip, "mjpsip/D");  
  tree->Branch("costheta", &costheta, "costheta/D");
  tree->Branch("costheta1", &costheta1, "costheta1/D");
  tree->Branch("costheta2", &costheta2, "costheta2/D");
//  tree->Branch("phi", &phi, "phi/D");
  tree->Branch("phi1", &phi1, "phi1/D");
  tree->Branch("phi2", &phi2, "phi2/D");
  tree->Branch("w", &w, "w/D");



  double vrnd[6];
  double mmin = m_k+m_p;
  double mmax = m_lb-m_jpsi;

  for(int i=0; i<1e6; ++i) {
    if(i%100000==0) std::cout <<"Generate .... " << i << std::endl;
    RooRandom::uniform(6, vrnd);
    //   if(!kine_limits(mkp)) return 0.0;
    costheta = (1.+1.)*vrnd[0]-1.; 
    costheta1 = (1.+1.)*vrnd[1]-1.; 
    costheta2 = (1.+1.)*vrnd[2]-1.; 
    phi1 = ((1.+1.)*vrnd[3]-1.)*TMath::Pi(); 
    phi2 = ((1.+1.)*vrnd[4]-1.)*TMath::Pi(); 
//    phi =  ((1.+1.)*vrnd[5]-1.)*TMath::Pi(); 
    mkp = (mmax-mmin)*vrnd[5]+mmin;
    Jpsihh_dlz *xdlz = new Jpsihh_dlz();

    filldlz(*xdlz, mkp, costheta, costheta1, costheta2, phi1, phi2);
    w =  GetAmp2s(*xdlz)*getp(m_lb, m_jpsi, mkp)*getp(mkp, m_p, m_k);
    tree->Fill();
    delete xdlz;
  }
  
  tree->Write();
  file->Close();
*/  
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   //   return 1.0 ; 
 } 


 Int_t RooDalitzAmplitude::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES

   // if (matchArgs(allVars,analVars,x)) return 1 ; 
  std::cout<<"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"<<std::endl;
   std::cout<<"Requested integration over these variables: "<<std::endl;
   allVars.Print("V");
   std::cout<<"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"<<std::endl<<std::endl;
   /* 
   RooArgSet List;
   List.add();
   List.add();
   List.add();
   List.add();
   List.add();
   List.add();
   List.add();
   */
   if( matchArgs(allVars, analVars, _values) ) 
  
   return 7;
   return 0 ; 
 } 


Double_t RooDalitzAmplitude::IntegralMethod1() const
{

  int smcnum = pdlz->size();//smcdata->GetEntries();
  std::cout << "MC inte size " << smcnum << std::endl;
  double inte(0.);
//  sumW = 0.;
  for(int i=0; i<smcnum; i++) {
    //mkp>2GeV
    //if(mkp<2.0) continue;
    Jpsihh_dlz &p = (*pdlz)[i];
    double sweight = p.w;
//    sumW += sweight;
    //    filldlz(p, mkp, costheta, costheta1, costheta2, phi1, phi2, phi);
    double val =  GetAmp2s(p,1);    

    inte += val*sweight;
  }
  inte = inte/sumW;
//  std::cout.precision(10);
  std::cout << "Integration1, " << inte << std::endl;  
  
//  printf("Integration1, %10.6f\n",inte);
//  int smcnum = pdlz->size();//smcdata->GetEntries();

  //sum over MC
  TComplex tctmp;
  for(int i=0;i<2; ++i) {
    for(int j=0; j<2; ++j) {
      for(int k=0; k<2; ++k) {
	for(int ir1=0; ir1<NR; ++ir1) {
	  for(int ir2=0; ir2<NR; ++ir2) { 
	    for(int m1=0; m1<6; ++m1) {
	      for(int m2=0; m2<6; ++m2) {
		AA[i][j][k][ir1][ir2][m1][m2]=TComplex(0.,0.);
	      }
	    }
	  }
	}
      }
    }
  }
//  std::cout << "Step 1 " << std::endl;
 for(int imc=0; imc<smcnum; imc++) {
   Jpsihh_dlz &p = (*pdlz)[imc];  
   double sweight = p.w;
    //if(mkp<2.0) continue;
   
   for(int i=0;i<2; ++i) {
     for(int j=0; j<2; ++j) {
       for(int k=0; k<2; ++k) { 
	 for(int ir1=0; ir1<NR; ++ir1) {
	   for(int m1=0; m1<6; ++m1) {
	     TComplex tp1 = TComplex(p.ARe[ir1][i][j][k][m1],-p.AIm[ir1][i][j][k][m1]);
	     for(int ir2=0; ir2<NR; ++ir2) {
	       for(int m2=0; m2<6; ++m2) {
		 TComplex tp2 = TComplex(p.ARe[ir2][i][j][k][m2],p.AIm[ir2][i][j][k][m2]);
		 tctmp =  tp1*tp2;
		 AA[i][j][k][ir1][ir2][m1][m2] += tctmp*sweight;
	       }
	     }
	   }
	 }
       }
     }
   }
 }

  //sum over MC for Z
//  TComplex tctmp;
  for(int i=0;i<2; ++i) {
    for(int j=0; j<2; ++j) {
      for(int k=0; k<2; ++k) {
	for(int ir1=0; ir1<NZ; ++ir1) {
	  for(int ir2=0; ir2<NZ; ++ir2) { 
	    for(int m1=0; m1<12; ++m1) {
	      for(int m2=0; m2<12; ++m2) {
		AAZ[i][j][k][ir1][ir2][m1][m2]=TComplex(0.,0.);
	      }
	    }
	  }
	}
      }
    }
  }
//  std::cout << "Step 1 " << std::endl;
 for(int imc=0; imc<smcnum; imc++) {
   Jpsihh_dlz &p = (*pdlz)[imc];  
   double sweight = p.w;
    //mkp>2GeV
    //if(mkp<2.0) continue;
   
   for(int i=0;i<2; ++i) {
     for(int j=0; j<2; ++j) {
       for(int k=0; k<2; ++k) { 
	 for(int ir1=0; ir1<NZ; ++ir1) {
	   for(int m1=0; m1<12; ++m1) {
	     TComplex tp1 = TComplex(p.AZRe[ir1][i][j][k][m1],-p.AZIm[ir1][i][j][k][m1]);
	     for(int ir2=0; ir2<NZ; ++ir2) {
	       for(int m2=0; m2<12; ++m2) {
		 TComplex tp2 = TComplex(p.AZRe[ir2][i][j][k][m2],p.AZIm[ir2][i][j][k][m2]);
		 tctmp =  tp1*tp2;
		 AAZ[i][j][k][ir1][ir2][m1][m2] += tctmp*sweight;
	       }
	     }
	   }
	 }
       }
     }
   }
 }

  for(int i=0;i<2; ++i) {
    for(int j=0; j<2; ++j) {
      for(int k=0; k<2; ++k) {
	for(int ir1=0; ir1<NZ; ++ir1) {
	  for(int ir2=0; ir2<NR; ++ir2) { 
	    for(int m1=0; m1<12; ++m1) {
	      for(int m2=0; m2<6; ++m2) {
		ABZ[i][j][k][ir1][ir2][m1][m2]=TComplex(0.,0.);
	      }
	    }
	  }
	}
      }
    }
  }
//  std::cout << "Step 1 " << std::endl;
 for(int imc=0; imc<smcnum; imc++) {
   Jpsihh_dlz &p = (*pdlz)[imc];  
   double sweight = p.w;
    //mkp>2GeV
    //if(mkp<2.0) continue;
   
   for(int i=0;i<2; ++i) {
     for(int j=0; j<2; ++j) {
       for(int k=0; k<2; ++k) { 
	 for(int ir1=0; ir1<NZ; ++ir1) {
	   for(int m1=0; m1<12; ++m1) {
	     TComplex tp1 = TComplex(p.AZRe[ir1][i][j][k][m1],-p.AZIm[ir1][i][j][k][m1]);
	     for(int ir2=0; ir2<NR; ++ir2) {
	       for(int m2=0; m2<6; ++m2) {
		 TComplex tp2 = TComplex(p.ARe[ir2][i][j][k][m2],p.AIm[ir2][i][j][k][m2]);
		 tctmp =  tp1*tp2;
		 ABZ[i][j][k][ir1][ir2][m1][m2] += tctmp*sweight;
	       }
	     }
	   }
	 }
       }
     }
   }
 }
 return inte; 
}

Double_t RooDalitzAmplitude::analyticalIntegral(Int_t code, const char* rangeName) const  
{ 
  
  // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
  // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
  // BOUNDARIES FOR EACH OBSERVABLE x
  
  // assert(code==1) ; 
  // return (x.max(rangeName)-x.min(rangeName)) ; 
  
  switch(code) {
  case 7:
    break;
  default: assert(0);
  }
  //  return 1.0;
  
  //  double costheta, costheta1,costheta2,phi1,phi2,phi;
  //double mkp,sw;
  // std::cout << "zhanglm Integral " << std::endl;
  //if parameters are updated, recache it.
  Double_t Inte = 0;  
  CalCoupling();   
  
  if(!_isPP) {
    if(checkchange())   {
      Inte = IntegralMethod1();
    } else {
    
      TComplex a1,a2;
      for(int i=0;i<=1; ++i) {//del
	for(int j=0; j<=1; ++j) { //hel0
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int ir1=0; ir1<NR;++ir1) {
	      for(int m1=0; m1<6; ++m1) {
		a1 = TComplex::Conjugate(amp[ir1][i][j][k][m1]);
		if((a1.Rho2())<1e-10) continue;
		for(int ir2=0; ir2<NR;++ir2) {
		  for(int m2=0; m2<6; ++m2) {
		    a2 = amp[ir2][i][j][k][m2];
		    Inte += (a1*a2* AA[i][j][k][ir1][ir2][m1][m2]).Re() ;
		    //      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		    
		  }
		}
	      }
	    }
	  }
	}
      }
      //  nres = NZ;  
      
      for(int i=0;i<=1; ++i) {//del
	for(int j=0; j<=1; ++j) { //hel0
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int ir1=0; ir1<NZ;++ir1) {
	      for(int m1=0; m1<12; ++m1) {
		a1 = TComplex::Conjugate(ampZ[ir1][i][j][k][m1]);
		if((a1.Rho2())<1e-10) continue;
		for(int ir2=0; ir2<NZ;++ir2) {
		  for(int m2=0; m2<12; ++m2) {
		    a2 = ampZ[ir2][i][j][k][m2];
		    Inte += (a1*a2* AAZ[i][j][k][ir1][ir2][m1][m2]).Re() ;
		    //      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		    
		  }
		}
	      }
	    }
	  }
	}
      }
      
      for(int i=0;i<=1; ++i) {//del
	for(int j=0; j<=1; ++j) { //hel0
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int ir1=0; ir1<NZ;++ir1) {
	      for(int m1=0; m1<12; ++m1) {
		a1 = TComplex::Conjugate(ampZ[ir1][i][j][k][m1]);
		if((a1.Rho2())<1e-10) continue;
		for(int ir2=0; ir2<NR;++ir2) {
		  for(int m2=0; m2<6; ++m2) {
		    a2 = amp[ir2][i][j][k][m2];
		    Inte += 2.*(a1*a2* ABZ[i][j][k][ir1][ir2][m1][m2]).Re() ;
		    //      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		    
		  }
		}
	      }
	    }
	  }
	}
      }
      
      //std::cout <<"sumW " << sumW <<std::endl;
      Inte = Inte/sumW;
    }
  }
  else {Inte = 1.0;  }
  //  std::cout.precision(10);
  //  std::cout << "Integration2, " << Inte << std::endl;  
  
  //update cached resparam
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    
    if((fabs(_resParCache[2*ir+0]-m0)>1e-20)
       || (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      ResetDef(ir);
    }
    
    _resParCache[2*ir+0] = m0;
    _resParCache[2*ir+1] = g0;
    
    ir++;
  }
  
  delete coefIter;
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    
    if((fabs(_resParCache[2*ir+0]-m0)>1e-20)
       || (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      ResetDef(ir);
    }
    _resParCache[2*ir+0] = m0;
    _resParCache[2*ir+1] = g0;
    
    ir++;
  }
  delete coefIterZ;
  
  return Inte; 
} 

bool RooDalitzAmplitude::checkchange() const
{
  //update cached resparam
  int ir(NR);
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    
    if((fabs(_resParCache[2*ir+0]-m0)>1e-20)
       || (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      delete coefIterZ;
      return true;
    }
    ir++;
  }
  delete coefIterZ;
  
  ir = 0; 
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    
    if((fabs(_resParCache[2*ir+0]-m0)>1e-20)
       || (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      delete coefIter;
      return true;
    }
    
    ir++;
  }
  
  delete coefIter;
  return false;
} 
void RooDalitzAmplitude::ResetDef(int ir) const
{
  if(!_isCach) return;
  int smcnum = PDLZ->size();//smcdata->GetEntries();

  for(int i=0; i<smcnum; i++) {
    //mkp>2GeV
    //if(mkp<2.0) continue;
    Jpsihh_dlz &p = (*PDLZ)[i];
    p.defed[ir] = false;
  }

}


 Int_t RooDalitzAmplitude::getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t /*staticInitOK*/) const 
 { 
   // LIST HERE OVER WHICH VARIABLES INTERNAL GENERATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE GENERATOR CONFIGURATION BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES. IF THE FLAG staticInitOK IS TRUE THEN IT IS SAFE TO PRECALCULATE 
   // INTERMEDIATE QUANTITIES IN initGenerator(), IF IT IS NOT SET THEN YOU SHOULD NOT ADVERTISE
   // ANY GENERATOR METHOD THAT RELIES ON PRECALCULATIONS IN initGenerator()

   // if (matchArgs(directVars,generateVars,x)) return 1 ;   
   return 0 ; 
 } 



 void RooDalitzAmplitude::generateEvent(Int_t code) 
 { 
   // GENERATE SET OF OBSERVABLES DEFINED BY RETURN CODE ASSIGNED BY getGenerator()
   // RETURN THE GENERATED VALUES BY ASSIGNING THEM TO THE PROXY DATA MEMBERS THAT
   // REPRESENT THE CHOSEN OBSERVABLES

   // assert(code==1) ; 
   // x = 0 ; 
   return; 
 } 

inline Double_t dfunhalf(Double_t beta, Int_t am, Int_t an) {
  //d1/2_{1/2,1/2}=d1/2_{-1/2,-1/2}=cos(theta/2);
  //d1/2_{1/2,-1/2}=-sin(theta/2)=-d1/2{-1/2,1/2};
  //std::cout << " am an " << am << " " << an << std::endl;
  if((am==1&&an==1) || (am==-1&&an==-1)) return TMath::Cos(0.5*beta);
  if(am==1&&an==-1) return -TMath::Sin(0.5*beta);
  if(am==-1&&an==1) return TMath::Sin(0.5*beta);
  std::cout << "dfunhalf why " << am << " " << an << std::endl;
  return 0.0;
}

inline Double_t dfunone(Double_t beta, Int_t am, Int_t an) {
  if((am==1&&an==1)||(am==-1&&an==-1)) return (TMath::Cos(beta)+1.0)/2.;
  if((am==1&&an==-1)||(am==-1&&an==1)) return (-TMath::Cos(beta)+1.0)/2.;
  if(am==0&&an==1) return TMath::Sin(beta)*7.07106781186547461715e-01;
  if(am==0&&an==-1) return -TMath::Sin(beta)*7.07106781186547461715e-01;
  std::cout << "dfunone why " << am << " " << an << std::endl;
  return 0.0;
}

inline Double_t dfun(Double_t beta, Double_t aj, Double_t am, Double_t an ) {
   //beta in rad;
   // Calculates the beta-term
   //                         d j mn (beta)
   // in the matrix element of the finite rotation operator
   // (Wigner's D-function), according to formula 4.3.1(3) in
   // D.A. Varshalovich, A.N. Moskalev, and V.K. Khersonskii,
   // Quantum Theory of Angular Momentum, World Scientific,
   // Singapore 1988.
   // CERNLIB DDJMNB function translated from Fortran to C++ by Rene Brun

  Double_t pi = 3.141592653589793116;
  Double_t pi2 = 6.283185307179586232;
  //   Double_t beta = beta_rad;
  const Double_t f = 0.5;//8.72664625997164788e-3;   
  const Double_t fcl[51] = { 0 ,0,
			     6.93147180559945309e-1 ,1.79175946922805500e00,
			     3.17805383034794562e00 ,4.78749174278204599e00,
			     6.57925121201010100e00 ,8.52516136106541430e00,
			     1.06046029027452502e01 ,1.28018274800814696e01,
			     1.51044125730755153e01 ,1.75023078458738858e01,
			     1.99872144956618861e01 ,2.25521638531234229e01,
			     2.51912211827386815e01 ,2.78992713838408916e01,
			     3.06718601060806728e01 ,3.35050734501368889e01,
			     3.63954452080330536e01 ,3.93398841871994940e01,
			     4.23356164607534850e01 ,4.53801388984769080e01,
			     4.84711813518352239e01 ,5.16066755677643736e01,
			     5.47847293981123192e01 ,5.80036052229805199e01,
			     6.12617017610020020e01 ,6.45575386270063311e01,
			     6.78897431371815350e01 ,7.12570389671680090e01,
			     7.46582363488301644e01 ,7.80922235533153106e01,
			     8.15579594561150372e01 ,8.50544670175815174e01,
			     8.85808275421976788e01 ,9.21361756036870925e01,
			     9.57196945421432025e01 ,9.93306124547874269e01,
			     1.02968198614513813e02 ,1.06631760260643459e02,
			     1.10320639714757395e02 ,1.14034211781461703e02,
			     1.17771881399745072e02 ,1.21533081515438634e02,
			     1.25317271149356895e02 ,1.29123933639127215e02,
			     1.32952575035616310e02 ,1.36802722637326368e02,
			     1.40673923648234259e02 ,1.44565743946344886e02,
			     1.48477766951773032e02};
  
  Int_t jpm = TMath::Nint(aj+am);
  Int_t jpn = TMath::Nint(aj+an);
  Int_t jmm = TMath::Nint(aj-am);
  
  
  Int_t jmn = TMath::Nint(aj-an);
  Int_t mpn = TMath::Nint(am+an);
  
  Double_t r = 0;
  if (jpm < 0 || jpn < 0 || jmm < 0 || jmn < 0
      
      || aj < 0 || aj > 25 || beta < 0 || beta > pi2) {
    printf("WignerD: Illegal argument(s) aj=%g, am=%g, an=%g, beta=%g\n",aj,am,an,beta);
  } else if (fabs(beta)<1e-10) {
    if (jpm == jpn) r = 1;
  } else if (fabs(beta-pi)<1e-10) {
    if (jpm == jmn) {
      r = 1;
      if (TMath::Abs(jpm)%2 == 1) r = -1;
    }
  } else if (fabs(beta-pi2)<1e-10) {
    if (jpm == jpn) {
      r = 1;
      if (TMath::Abs(mpn)%2 == 1) r = -1;
    }
  } else {
    Double_t b  = f*beta;
    Double_t s  = TMath::Log(TMath::Sin(b));
    Double_t c  = TMath::Log(TMath::Abs(TMath::Cos(b)));
    Double_t rt = 0.5*(fcl[jpm]+fcl[jmm]+fcl[jpn]+fcl[jmn]);
    Int_t k0    = TMath::Max(0,mpn);
    Int_t kq    = k0+jpm;
    if (beta > pi) kq += mpn;
    Double_t q  = 1;
    if (kq%2 == 1) q = -1;
    kq = k0+k0;
    Double_t cx = kq-mpn;
    Double_t sx = jpm+jpn-kq;
    for (Int_t k=k0;k<=TMath::Min(jpm,jpn);k++) {
      r  += q*TMath::Exp(rt-fcl[k]-fcl[jpm-k]-fcl[jpn-k]-fcl[k-mpn]+ cx*c+sx*s);
      cx += 2;
      sx -= 2;
      q   = -q;
    }
    
    
  }
  return r;
}
 
//angluar depdent part for /\*
TComplex RooDalitzAmplitude::MEang(double hel0, double hel3, int delhelmu,
				   double J, double hel1, int hel2, Jpsihh_dlz &dlz) const
{
  double phi1 = dlz.phi1;
  double phi2 = dlz.phi2;
  double phi = 0.0;
  double theta = dlz.theta;
  double theta1 = dlz.theta1;
  double theta2 = dlz.theta2;
  
  double partphi = hel1*phi1+hel2*phi2;//+(hel2-hel1)*phi;
  //  return TComplex(1,partphi,1)*dfun(theta,0.5,hel0,hel1-hel2)
  //*dfun(theta1,J,hel1,hel3)*dfun(theta2,1.,hel2,delhelmu);
  
  return TComplex(1,partphi,1)*dfunhalf(theta,(int)(hel0*2.),(int)((hel1-hel2)*2.))
    *dfun(theta1,J,hel1,hel3)*dfunone(theta2,hel2,delhelmu);
  
//  std::cout << dfun(theta1,J,hel1,hel3)  <<std::endl;
  //return meang;
}

//angluar depdent part for Z
TComplex RooDalitzAmplitude::MEangZ(double helB, double hel3, int delhelmu,
				    double JZ, double helZ, int helpsi, double help, Jpsihh_dlz &dlz) const
{
  if(JZ<fabs((double)helpsi-help)) return 0.0;
  double phiZ = dlz.phiZ;
  double phiMu = dlz.phiMu;
  double phiPsi = dlz.phiPsi;
  double alphaMu = dlz.alphaMu;
  double thetaB = dlz.thetaB;
  double thetaPsi = dlz.thetaPsi;
  double thetaZ = dlz.thetaZ;
  double thetap = dlz.thetap;

  double partphi = helB*phiZ+helpsi*phiMu+helZ*phiPsi+delhelmu*alphaMu;
  return TComplex(1,partphi,1)*dfunone(thetaPsi,helpsi,delhelmu) *
    dfunhalf(thetaB,(int)(helB*2.),(int)(helZ*2.)) *
    dfunhalf(thetap,(int)(help*2.),(int)(hel3*2.)) *//hel3 = hel_p in /\*
    dfun(thetaZ,JZ,helZ,(double)helpsi-help);
  
  // return TComplex(1,partphi,1)*dfunhalf(theta,(int)(hel0*2.),(int)((hel1-hel2)*2.))
  // *dfun(theta1,J,hel1,hel3)*dfunone(theta2,hel2,delhelmu);
  

//  std::cout << dfun(theta1,J,hel1,hel3)  <<std::endl;
  //return meang;
}


void RooDalitzAmplitude::CalCoupling() const
{
//  std::cout << "update coupling " << std::endl;
  TComplex ampCoff;  
  double hel0, hel3;
  int delhelmu;
  double S, hel1, hel2;
  int S2,LR;
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    int iressize = ires.getSize();
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = (int)(S-0.5);
    //(-1)*(-1)^LR = P_Ln
    if((pow(-1,LR+1)*parity)<0) LR += 1;

    double paritypart;
    for(int i=0;i<=1; ++i) {//delmu
      delhelmu = (i==0) ? -1: 1;
      for(int j=0; j<=1; ++j) { //hel0
	hel0 = (j==0) ? -0.5: 0.5;
	for(int k=0; k<=1; ++k) { //hel3 proton
	  hel3 = (k==0) ? -0.5: 0.5;
	  paritypart = 1.; // parity conservation of /\n decay 
	  if(hel3<0)   paritypart = pow(-1.,(int)(S-1.5))*parity;
	  // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	  for(int m=0; m<6; ++m) {
	    //	    amp[ir][i][j][k][m] = 0.0;
	    if(fabs(S-0.5)<1e-10&&m>=4) {
	      continue;
	    }
	    hel1 = (double)Hel1Two[m]/2.;
	    hel2 = Hel2[m];
	    //	      std::cout << "defined .. " << std::endl;
#ifdef PAW 
	    ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2*2)*paritypart;
#else
	    ampCoff = HelicityCoff(ires,m)*paritypart;
#endif
	    amp[ir][i][j][k][m] = ampCoff *TComplex((double)((RooAbsReal&)ires[iressize-7]).getVal(), (double)((RooAbsReal&)ires[iressize-6]).getVal());
	  }
	}
      }
    }
    ir++;
  }
  delete coefIter;
  
  int irZ(0);
  double help, helZ;
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = TMath::Max((int)(S-1.5),0);
    //(-1)*(-1)^LR = P_Lz
    if((pow(-1,LR+1)*parity)<0) LR += 1;
    
    //Rj BW here
    for(int i=0;i<=1; ++i) {//delmu
      delhelmu = (i==0) ? -1: 1;
      for(int j=0; j<=1; ++j) { //hel0
	hel0 = (j==0) ? -0.5: 0.5;
	for(int k=0; k<=1; ++k) { //hel3 proton
	  hel3 = (k==0) ? -0.5: 0.5;
	  
	  //there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2, help=+/-1/2
	  int m(0);
	  for(int helpsi = -1; helpsi <=1; ++helpsi) {
	    for(int ihz = 0; ihz<=1; ++ihz) {
	      helZ = (ihz==0) ? -0.5: 0.5;
	      for(int ihp = 0; ihp<=1; ++ihp) {
		help = (ihp==0) ? -0.5: 0.5;
		if(fabs((double)helpsi-help)>S) continue;
		ampCoff = PartWaveCoffZ(ires, S2, (int)(helZ*2.), (int)(helpsi*2.), (int)(help*2.));	
//		std::cout << "amp Z " << ampCoff << std::endl;
//		std::cout << "m " << m<<std::endl;
		ampZ[irZ][i][j][k][m] = ampCoff;
		m++;
	      }
	    }
	  }
	}
      }
    }
    irZ++;
  }
  delete coefIterZ;
}

Double_t RooDalitzAmplitude::GetAmp2s(Jpsihh_dlz &dlz, int isintcal) const
{
  TComplex H[2][2][2];//delhelmu=+/-1,hel0=+/-1/2,hel3=+/-1/2
  for(int i=0;i<=1; ++i) {
    for(int j=0; j<=1; ++j) {
      for(int k=0; k<=1; ++k) {
	H[i][j][k] = TComplex(0,0);
      }
    }
  }
  
  double re_i, im_i;
  double hel0, hel3;
  int delhelmu;
  double S, hel1, hel2;
  double mkp(dlz.mkp);
  int S2,LR;
  
  TComplex ampCoff, AIndep;
  double Bterm;
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    int iressize = ires.getSize();
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = (int)(S-0.5);
    //(-1)*(-1)^LR = P_Ln
    if((pow(-1,LR+1)*parity)<0) LR += 1;
    
    double paritypart;
    bool notdefined = !(dlz.defed[ir]);
    //    notdefined = 1;
    if( notdefined
	//check if need to update cached amplitude if mass or widht changes
	|| (fabs(_resParCache[2*ir+0]-m0)>1e-20)
	|| (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      if(TString(Ires->GetName()).Contains("Flatte")) {
//        std::cout << "Flatte " << Ires->GetName() << std::endl; 
        BW_AMP(m0,g0,mkp,LR,re_i, im_i, 2.5);
      } else {
        BW_AMP(m0,g0,mkp,LR,re_i, im_i);
      }      
      Bterm = BTerm(S, mkp, m0);
      
      for(int i=0;i<=1; ++i) {//del
	delhelmu = (i==0) ? -1: 1;
	for(int j=0; j<=1; ++j) { //hel0 lambda_b0
	  hel0 = (j==0) ? -0.5: 0.5;
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    hel3 = (k==0) ? -0.5: 0.5;
	    paritypart = 1.; // parity conservation of /\n decay 
	    if(hel3<0)   paritypart = pow(-1.,(int)(S-1.5))*parity;
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int m=0; m<6; ++m) { // 
	      dlz.ARe[ir][i][j][k][m] = 0.0;
	      dlz.AIm[ir][i][j][k][m] = 0.0;
	      //amp[ir][i][j][k][m] = 0.0;
	      if(fabs(S-0.5)<1e-10&&m>=4) {
		//	dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		continue;
	      }
	      hel1 = (double)Hel1Two[m]/2.;
	      hel2 = Hel2[m];
	      /*
		#ifdef PAW 
		ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2*2)*paritypart;
		#else
		ampCoff = HelicityCoff(ires,m)*paritypart;
		#endif
	      */
	      ampCoff = amp[ir][i][j][k][m];
	      if((ampCoff.Rho2())<1e-10 && isintcal==0) continue;	      
	      
	      AIndep = TComplex(re_i, im_i) * Bterm *MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);
	      dlz.ARe[ir][i][j][k][m] = AIndep.Re();
	      dlz.AIm[ir][i][j][k][m] = AIndep.Im();
	      H[i][j][k] += ampCoff * AIndep;
	      if(m==0) dlz.defed[ir] = true;
	    }
	  }
	}
      }
    } else{
      
      for(int i=0;i<=1; ++i) {//delmu
	delhelmu = (i==0) ? -1: 1;
	for(int j=0; j<=1; ++j) { //hel0
	  hel0 = (j==0) ? -0.5: 0.5;
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    hel3 = (k==0) ? -0.5: 0.5;
	    paritypart = 1.; // parity conservation of /\n decay 
	    if(hel3<0)   paritypart = pow(-1.,(int)(S-1.5))*parity;
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int m=0; m<6; ++m) {
	      //amp[ir][i][j][k][m] = 0.0;
	      if(fabs(S-0.5)<1e-10&&m>=4) {
		continue;
	      }
	      hel1 = (double)Hel1Two[m]/2.;
	      hel2 = Hel2[m];
//	    	      std::cout << "defined .. " << std::endl;
	      /*#ifdef PAW 
		ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2*2)*paritypart;
		#else
		ampCoff = HelicityCoff(ires,m)*paritypart;
		#endif
	      */
	      ampCoff = amp[ir][i][j][k][m];
	      
	      if((ampCoff.Rho2())<1e-10) continue;
	      //	      AIndep = 
	      H[i][j][k] += ampCoff * TComplex(dlz.ARe[ir][i][j][k][m], dlz.AIm[ir][i][j][k][m]);//TComplex(re_i, im_i) * Bterm *MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);;
	      //H[i][j][k] += ampCoff*BTerm(S,mkp,m0,hel3, parity)*TComplex(re_i, im_i)*MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);
	    }
	  }
	}  
      }
      
    }
    ir++;
  }
  
  //Pc part
  int irZ(0);
  double help, helZ;
  double mjpsip(dlz.mjpsip);
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = TMath::Max((int)(S-1.5),0);
    //(-1)*(-1)^LR = P_Lz
    if((pow(-1,LR+1)*parity)<0) LR += 1;
    
    bool notdefined = !(dlz.defed[ir]);
    if( notdefined
	//check if need to update cached amplitude if mass or widht changes
	|| (fabs(_resParCache[2*ir+0]-m0)>1e-20)
	|| (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      
/*      if(g0<0.1) {
         Double_t min(4.45-0.04*1.5),max(4.45+0.04*1.5);
         const int nbin(6);
         double wbin = -(min*min-max*max)/(nbin);
         for(int i=0; i<nbin; ++i) {
        double MJpsiP = sqrt(min*min+(i+0.5)*wbin);
//        MJpsiP = 4.45;
        BW_AMPZ(m0,g0,MJpsiP,LR,re_i, im_i);
        Bterm = BTermZ(S, MJpsiP, m0);        
//        std::cout << MJpsiP << " " << re_i*Bterm*100. << " " << im_i*Bterm *100.<< std::endl; 
//        TComplex aaa(re_i*Bterm*100.,im_i*Bterm*100.);
//        std::cout << MJpsiP << " " << aaa.Rho2() << " " << aaa.Theta() << std::endl;
        }
      }
      */
      BW_AMPZ(m0,g0,mjpsip,LR,re_i, im_i);
      Bterm = BTermZ(S, mjpsip, m0);
      
      //Rj BW here
      for(int i=0;i<=1; ++i) {//delmu
	delhelmu = (i==0) ? -1: 1;
	for(int j=0; j<=1; ++j) { //hel0
	  hel0 = (j==0) ? -0.5: 0.5;
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    hel3 = (k==0) ? -0.5: 0.5;
	    //there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2, help=+/-1/2
	    int m(0);
	    for(m=0; m<12; ++m) {
	      dlz.AZRe[irZ][i][j][k][m] = 0.0;
	      dlz.AZIm[irZ][i][j][k][m] = 0.0;
	    }
	    m=0;
	    for(int helpsi = -1; helpsi <=1; ++helpsi) {
	      for(int ihz = 0; ihz<=1; ++ihz) {
		helZ = (ihz==0) ? -0.5: 0.5;
		for(int ihp = 0; ihp<=1; ++ihp) {
		  help = (ihp==0) ? -0.5: 0.5;
		  if(fabs((double)helpsi-help)>S) continue;
		  ampCoff = ampZ[irZ][i][j][k][m];
		  //ampCoff = PartWaveCoffZ(ires, S2, (int)(helZ*2.), (int)(helpsi*2.), (int)(help*2.));	
		  //		std::cout << "helpsi helZ help co " << helpsi << " " << helZ << " " << help << " " << ampCoff << std::endl;	
		  if((ampCoff.Rho2())<1e-10 && isintcal==0) { m++; continue;	}      		
		  AIndep = TComplex(re_i, im_i) * Bterm * MEangZ(hel0, hel3, delhelmu, S, helZ, helpsi, help, dlz);
		  dlz.AZRe[irZ][i][j][k][m] = AIndep.Re();
		  dlz.AZIm[irZ][i][j][k][m] = AIndep.Im();
		  
		  //		std::cout << "helZ helpsi help amp " << helZ << " " << helpsi << " " << help << " " << ampCoff << std::endl;
		  //	TComplex RooDalitzAmplitude::PartWaveCoffZ(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const
		  H[i][j][k] += ampCoff * AIndep;
		  if(m==0) dlz.defed[ir] = true;		
		  m++;
		}
	      }
	    }
	  }
	}
      }
    } else {
      //Rj BW here
      for(int i=0;i<=1; ++i) {//delmu
	delhelmu = (i==0) ? -1: 1;
	for(int j=0; j<=1; ++j) { //hel0
	  hel0 = (j==0) ? -0.5: 0.5;
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    hel3 = (k==0) ? -0.5: 0.5;
	    
	    //there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2, help=+/-1/2
	    int m(0);
	    for(int helpsi = -1; helpsi <=1; ++helpsi) {
	      for(int ihz = 0; ihz<=1; ++ihz) {
		helZ = (ihz==0) ? -0.5: 0.5;
		for(int ihp = 0; ihp<=1; ++ihp) {
		  help = (ihp==0) ? -0.5: 0.5;
		  if(fabs((double)helpsi-help)>S) continue;
		  ampCoff = ampZ[irZ][i][j][k][m];
		  
		  //		ampCoff = PartWaveCoffZ(ires, S2, (int)(helZ*2.), (int)(helpsi*2.), (int)(help*2.));		
		  if((ampCoff.Rho2())<1e-10) { m++; continue;	}      		
		  //		AIndep = TComplex(re_i, im_i) * Bterm * MEangZ(hel0, hel3, delhelmu, S, helZ, helpsi, help, dlz);
		  //dlz.AZRe[irZ][i][j][k][m] = AIndep.Re();
		  //		dlz.AZIm[irZ][i][j][k][m] = AIndep.Im();
		  
		  //		std::cout << "helZ helpsi help amp " << helZ << " " << helpsi << " " << help << " " << ampCoff << std::endl;
		  //	TComplex RooDalitzAmplitude::PartWaveCoffZ(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const
		  H[i][j][k] += ampCoff * TComplex(dlz.AZRe[irZ][i][j][k][m],dlz.AZIm[irZ][i][j][k][m]);//AIndep;
		  m++;
		}
	      }
	    }
	  }
	}
      }
    }
    ir++;
    irZ++;
  }
  double totalA = H[0][0][0].Rho2() + H[0][0][1].Rho2()
    + H[0][1][0].Rho2() + H[0][1][1].Rho2()
    + H[1][0][0].Rho2() + H[1][0][1].Rho2()
    + H[1][1][0].Rho2() + H[1][1][1].Rho2();
  
  delete coefIter;  
  delete coefIterZ;    
  return totalA;  
}

//group = 0 for each component, = 1 Lambda = 2 Z
Double_t RooDalitzAmplitude::GetAmp2sForInt(Jpsihh_dlz &dlz, int index, int group) const
{
  int isintcal(1);
  TComplex H[2][2][2];//delhelmu=+/-1,hel0=+/-1/2,hel3=+/-1/2
  for(int i=0;i<=1; ++i) {
    for(int j=0; j<=1; ++j) {
      for(int k=0; k<=1; ++k) {
	H[i][j][k] = TComplex(0,0);
      }
    }
  }
  
  double re_i, im_i;
  double hel0, hel3;
  int delhelmu;
  double S, hel1, hel2;
  double mkp(dlz.mkp);
  int S2,LR;
  
  TComplex ampCoff, AIndep;
  double Bterm;
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    if((group!=1)&&!(group==0&&ir==index)) {ir++; continue;}
    int iressize = ires.getSize();
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = (int)(S-0.5);
    //(-1)*(-1)^LR = P_Ln
    if((pow(-1,LR+1)*parity)<0) LR += 1;
    
    double paritypart;
    //bool notdefined = !(dlz.defed[ir]);
    //    notdefined = 1;
    
    for(int i=0;i<=1; ++i) {//delmu
      delhelmu = (i==0) ? -1: 1;
      for(int j=0; j<=1; ++j) { //hel0
	hel0 = (j==0) ? -0.5: 0.5;
	for(int k=0; k<=1; ++k) { //hel3 proton
	  hel3 = (k==0) ? -0.5: 0.5;
	  paritypart = 1.; // parity conservation of /\n decay 
	  if(hel3<0)   paritypart = pow(-1.,(int)(S-1.5))*parity;
	  // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	  for(int m=0; m<6; ++m) {
	    //amp[ir][i][j][k][m] = 0.0;
	    if(fabs(S-0.5)<1e-10&&m>=4) {
	      continue;
	    }
	    hel1 = (double)Hel1Two[m]/2.;
	    hel2 = Hel2[m];
	    //	      std::cout << "defined .. " << std::endl;
	    /*#ifdef PAW 
	      ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2*2)*paritypart;
	      #else
	      ampCoff = HelicityCoff(ires,m)*paritypart;
	      #endif
	    */
	    ampCoff = amp[ir][i][j][k][m];
	    
	    if((ampCoff.Rho2())<1e-10) continue;
	    //	      AIndep = 
	    H[i][j][k] += ampCoff * TComplex(dlz.ARe[ir][i][j][k][m], dlz.AIm[ir][i][j][k][m]);//TComplex(re_i, im_i) * Bterm *MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);;
	    //H[i][j][k] += ampCoff*BTerm(S,mkp,m0,hel3, parity)*TComplex(re_i, im_i)*MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);
	  }
	}
      }  
    }
    
    ir++;
  }
  
  //Z part
  int irZ(0);
  double help, helZ;
  double mjpsip(dlz.mjpsip);
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    if((group!=2)&&!(group==0&&ir==index)) {ir++; irZ++; continue;}    
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = TMath::Max((int)(S-1.5),0);
    //(-1)*(-1)^LR = P_Lz
    if((pow(-1,LR+1)*parity)<0) LR += 1;    
    
    //Rj BW here
    for(int i=0;i<=1; ++i) {//delmu
      delhelmu = (i==0) ? -1: 1;
      for(int j=0; j<=1; ++j) { //hel0
	hel0 = (j==0) ? -0.5: 0.5;
	for(int k=0; k<=1; ++k) { //hel3 proton
	  hel3 = (k==0) ? -0.5: 0.5;
	  
	  //there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2, help=+/-1/2
	  int m(0);
	  for(int helpsi = -1; helpsi <=1; ++helpsi) {
	    for(int ihz = 0; ihz<=1; ++ihz) {
	      helZ = (ihz==0) ? -0.5: 0.5;
	      for(int ihp = 0; ihp<=1; ++ihp) {
		help = (ihp==0) ? -0.5: 0.5;
		if(fabs((double)helpsi-help)>S) continue;
                ampCoff = ampZ[irZ][i][j][k][m];
		
		//		ampCoff = PartWaveCoffZ(ires, S2, (int)(helZ*2.), (int)(helpsi*2.), (int)(help*2.));		
		if((ampCoff.Rho2())<1e-10) { m++; continue;	}      		
		//	
		H[i][j][k] += ampCoff * TComplex(dlz.AZRe[irZ][i][j][k][m],dlz.AZIm[irZ][i][j][k][m]);//AIndep;
		m++;
	      }
	    }
	  }
	}
      }
      
    }
    ir++;
    irZ++;
  }

  
  
  double totalA = H[0][0][0].Rho2() + H[0][0][1].Rho2()
                + H[0][1][0].Rho2() + H[0][1][1].Rho2()
                + H[1][0][0].Rho2() + H[1][0][1].Rho2()
                + H[1][1][0].Rho2() + H[1][1][1].Rho2();

  delete coefIter;  
  delete coefIterZ;  

  return totalA;  
}

/*
Double_t RooDalitzAmplitude::GetAmp2sForInt(Jpsihh_dlz &dlz, int index) const
{
  int isintcal(1);
  TComplex H[2][2][2];//delhelmu=+/-1,hel0=+/-1/2,hel3=+/-1/2
  for(int i=0;i<=1; ++i) {
    for(int j=0; j<=1; ++j) {
      for(int k=0; k<=1; ++k) {
	H[i][j][k] = TComplex(0,0);
      }
    }
  }
  
  double re_i, im_i;
  double hel0, hel3;
  int delhelmu;
  double S, hel1, hel2;
  double mkp(dlz.mkp);
  int S2,LR;
  
  TComplex ampCoff, AIndep;
  double Bterm;
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    if(ir!=index) {ir++; continue;}
    int iressize = ires.getSize();
    
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = (int)(S-0.5);
    //(-1)*(-1)^LR = P_Ln
    if((pow(-1,LR+1)*parity)<0) LR += 1;
    
    double paritypart;
    //    bool notdefined = !(dlz.defed[ir]);
    //    notdefined = 1;
//    if( notdefined
	//check if need to update cached amplitude if mass or widht changes
//	|| (fabs(_resParCache[2*ir+0]-m0)>1e-20)
//	|| (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
    if(0) {  
      BW_AMP(m0,g0,mkp,LR,re_i, im_i);
      Bterm = BTerm(S, mkp, m0);

      for(int i=0;i<=1; ++i) {//del
	delhelmu = (i==0) ? -1: 1;
	for(int j=0; j<=1; ++j) { //hel0
	  hel0 = (j==0) ? -0.5: 0.5;
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    hel3 = (k==0) ? -0.5: 0.5;
	    paritypart = 1.; // parity conservation of /\n decay 
	    if(hel3<0)   paritypart = pow(-1.,(int)(S-1.5))*parity;
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int m=0; m<6; ++m) {
	      dlz.ARe[ir][i][j][k][m] = 0.0;
	      dlz.AIm[ir][i][j][k][m] = 0.0;
	      if(fabs(S-0.5)<1e-10&&m>=4) {
		//	dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		continue;
	      }
	      hel1 = (double)Hel1Two[m]/2.;
	      hel2 = Hel2[m];

#ifdef PAW 
	      ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2*2)*paritypart;
#else
	      ampCoff = HelicityCoff(ires,m)*paritypart;
#endif
	       if((ampCoff.Rho2())<1e-10 && isintcal==0) continue;	      
	      
	      AIndep = TComplex(re_i, im_i) * Bterm *MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);
	      dlz.ARe[ir][i][j][k][m] = AIndep.Re();
	      dlz.AIm[ir][i][j][k][m] = AIndep.Im();
	      H[i][j][k] += ampCoff * AIndep;
	      if(m==0) dlz.defed[ir] = true;
	    }
	  }
	}
      }
    } else{
      
      for(int i=0;i<=1; ++i) {//delmu
	delhelmu = (i==0) ? -1: 1;
	for(int j=0; j<=1; ++j) { //hel0
	  hel0 = (j==0) ? -0.5: 0.5;
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    hel3 = (k==0) ? -0.5: 0.5;
	    paritypart = 1.; // parity conservation of /\n decay 
	    if(hel3<0)   paritypart = pow(-1.,(int)(S-1.5))*parity;
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int m=0; m<6; ++m) {
	      if(fabs(S-0.5)<1e-10&&m>=4) {
		continue;
	      }
	      hel1 = (double)Hel1Two[m]/2.;
	      hel2 = Hel2[m];
	      //	      std::cout << "defined .. " << std::endl;
#ifdef PAW 
	      ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2*2)*paritypart;
#else
	      ampCoff = HelicityCoff(ires,m)*paritypart;
#endif
	      if((ampCoff.Rho2())<1e-10) continue;
	      //	      AIndep = 
	      H[i][j][k] += ampCoff * TComplex(dlz.ARe[ir][i][j][k][m], dlz.AIm[ir][i][j][k][m]);//TComplex(re_i, im_i) * Bterm *MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);;
	      //H[i][j][k] += ampCoff*BTerm(S,mkp,m0,hel3, parity)*TComplex(re_i, im_i)*MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);
	    }
	  }
	}  
      }
      
    }
    ir++;
  }

  //Z part
  int irZ(0);
  double help, helZ;
  double mjpsip(dlz.mjpsip);
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    if(ir!=index) {ir++; irZ++; continue;}    
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = TMath::Max((int)(S-1.5),0);
    //(-1)*(-1)^LR = P_Lz
    if((pow(-1,LR+1)*parity)<0) LR += 1;
    
    // bool notdefined = !(dlz.defed[ir]);
//    if( notdefined
	//check if need to update cached amplitude if mass or widht changes
//	|| (fabs(_resParCache[2*ir+0]-m0)>1e-20)
	//|| (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
    if(0) {  
    BW_AMPZ(m0,g0,mjpsip,LR,re_i, im_i);
    Bterm = BTermZ(S, mjpsip, m0);

    //Rj BW here
    for(int i=0;i<=1; ++i) {//delmu
      delhelmu = (i==0) ? -1: 1;
      for(int j=0; j<=1; ++j) { //hel0
	hel0 = (j==0) ? -0.5: 0.5;
	for(int k=0; k<=1; ++k) { //hel3 proton
	  hel3 = (k==0) ? -0.5: 0.5;
	  
	  //there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2, help=+/-1/2
	  int m(0);
	  for(int helpsi = -1; helpsi <=1; ++helpsi) {
	    for(int ihz = 0; ihz<=1; ++ihz) {
	      helZ = (ihz==0) ? -0.5: 0.5;
	      for(int ihp = 0; ihp<=1; ++ihp) {
		help = (ihp==0) ? -0.5: 0.5;
		if(fabs((double)helpsi-help)>S) continue;
		ampCoff = PartWaveCoffZ(ires, S2, (int)(helZ*2.), (int)(helpsi*2.), (int)(help*2.));		
	       if((ampCoff.Rho2())<1e-10 && isintcal==0) { m++; continue;	}      		
		AIndep = TComplex(re_i, im_i) * Bterm * MEangZ(hel0, hel3, delhelmu, S, helZ, helpsi, help, dlz);
		dlz.AZRe[irZ][i][j][k][m] = AIndep.Re();
		dlz.AZIm[irZ][i][j][k][m] = AIndep.Im();

		//		std::cout << "helZ helpsi help amp " << helZ << " " << helpsi << " " << help << " " << ampCoff << std::endl;
		//	TComplex RooDalitzAmplitude::PartWaveCoffZ(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const
		H[i][j][k] += ampCoff * AIndep;
      	      if(m==0) dlz.defed[ir] = true;		
		m++;
	      }
	    }
	  }
	}
      }
    }
  } else {
      //Rj BW here
    for(int i=0;i<=1; ++i) {//delmu
      delhelmu = (i==0) ? -1: 1;
      for(int j=0; j<=1; ++j) { //hel0
	hel0 = (j==0) ? -0.5: 0.5;
	for(int k=0; k<=1; ++k) { //hel3 proton
	  hel3 = (k==0) ? -0.5: 0.5;
	  
	  //there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2, help=+/-1/2
	  int m(0);
	  for(int helpsi = -1; helpsi <=1; ++helpsi) {
	    for(int ihz = 0; ihz<=1; ++ihz) {
	      helZ = (ihz==0) ? -0.5: 0.5;
	      for(int ihp = 0; ihp<=1; ++ihp) {
		help = (ihp==0) ? -0.5: 0.5;
		if(fabs((double)helpsi-help)>S) continue;
		ampCoff = PartWaveCoffZ(ires, S2, (int)(helZ*2.), (int)(helpsi*2.), (int)(help*2.));		
	       if((ampCoff.Rho2())<1e-10) { m++; continue;	}      		
//		AIndep = TComplex(re_i, im_i) * Bterm * MEangZ(hel0, hel3, delhelmu, S, helZ, helpsi, help, dlz);
		//dlz.AZRe[irZ][i][j][k][m] = AIndep.Re();
//		dlz.AZIm[irZ][i][j][k][m] = AIndep.Im();

		//		std::cout << "helZ helpsi help amp " << helZ << " " << helpsi << " " << help << " " << ampCoff << std::endl;
		//	TComplex RooDalitzAmplitude::PartWaveCoffZ(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const
		H[i][j][k] += ampCoff * TComplex(dlz.AZRe[irZ][i][j][k][m],dlz.AZIm[irZ][i][j][k][m]);//AIndep;
		m++;
	      }
	    }
	  }
	}
      }
    }
  }
  ir++;
  irZ++;
  }
  double totalA = H[0][0][0].Rho2() + H[0][0][1].Rho2()
                + H[0][1][0].Rho2() + H[0][1][1].Rho2()
                + H[1][0][0].Rho2() + H[1][0][1].Rho2()
                + H[1][1][0].Rho2() + H[1][1][1].Rho2();

  delete coefIter;  
  delete coefIterZ;  

  return totalA;  
}
*/

TMatrixD RooDalitzAmplitude::getIFandFF() const
{

  CalCoupling();
//  analyticalIntegral(7);
  IntegralMethod1();
  Double_t Inte(0);
  Double_t FFL(0), FFZ(0);
  Double_t InteL[NR][NR], InteZ[NZ][NZ], InteLZ[NZ][NR];
//  Double_t IFFF[NR+NZ][NR+NZ];
  TMatrixD IFFF(NR+NZ,NR+NZ);

  for(int ir1=0;ir1<NR; ++ir1) {
    for(int ir2=0; ir2<NR; ++ir2) {
      InteL[ir1][ir2] = 0.0;
    }
  }
  for(int ir1=0;ir1<NZ; ++ir1) {
    for(int ir2=0; ir2<NR; ++ir2) {
      InteLZ[ir1][ir2] = 0.0;
    }
  }
  for(int ir1=0;ir1<NZ; ++ir1) {
    for(int ir2=0; ir2<NZ; ++ir2) {
      InteZ[ir1][ir2] = 0.0;
    }
  }

  TComplex a1,a2;
  for(int i=0;i<=1; ++i) {//del
    for(int j=0; j<=1; ++j) { //hel0
      for(int k=0; k<=1; ++k) { //hel3 proton
	// [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	for(int ir1=0; ir1<NR;++ir1) {
	  for(int m1=0; m1<6; ++m1) {
	    a1 = TComplex::Conjugate(amp[ir1][i][j][k][m1]);
	    if((a1.Rho2())<1e-10) continue;
	    for(int ir2=0; ir2<NR;++ir2) {
	      for(int m2=0; m2<6; ++m2) {
		a2 = amp[ir2][i][j][k][m2];
		double tmp = (a1*a2* AA[i][j][k][ir1][ir2][m1][m2]).Re() ;
		InteL[ir1][ir2] += tmp;
		Inte += tmp;
		FFL += tmp;
		//      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		
	      }
	    }
	  }
	}
      }
    }
  }
  //  nres = NZ;  
  
  for(int i=0;i<=1; ++i) {//del
    for(int j=0; j<=1; ++j) { //hel0
      for(int k=0; k<=1; ++k) { //hel3 proton
	// [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	for(int ir1=0; ir1<NZ;++ir1) {
	  for(int m1=0; m1<12; ++m1) {
	    a1 = TComplex::Conjugate(ampZ[ir1][i][j][k][m1]);
	    if((a1.Rho2())<1e-10) continue;
	    for(int ir2=0; ir2<NZ;++ir2) {
	      for(int m2=0; m2<12; ++m2) {
		a2 = ampZ[ir2][i][j][k][m2];
		double tmp = (a1*a2* AAZ[i][j][k][ir1][ir2][m1][m2]).Re() ;
		InteZ[ir1][ir2] += tmp;
		//      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		Inte += tmp;
		FFZ += tmp;
	      }
	    }
	  }
	}
      }
    }
  }
  
  for(int i=0;i<=1; ++i) {//del
    for(int j=0; j<=1; ++j) { //hel0
      for(int k=0; k<=1; ++k) { //hel3 proton
	// [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	for(int ir1=0; ir1<NZ;++ir1) {
	  for(int m1=0; m1<12; ++m1) {
	    a1 = TComplex::Conjugate(ampZ[ir1][i][j][k][m1]);
	    if((a1.Rho2())<1e-10) continue;
	    for(int ir2=0; ir2<NR;++ir2) {
	      for(int m2=0; m2<6; ++m2) {
		a2 = amp[ir2][i][j][k][m2];
		double tmp = 2.*(a1*a2* ABZ[i][j][k][ir1][ir2][m1][m2]).Re() ;
		InteLZ[ir1][ir2] += tmp;
		//      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		Inte += tmp;
	      }
	    }
	  }
	}
      }
    }
  }

  for(int ir1=0;ir1<NR; ++ir1) {
    for(int ir2=0; ir2<NR; ++ir2) {
      IFFF(ir1,ir2) = 100.*InteL[ir1][ir2]/Inte;
    }
  }
  for(int ir1=0;ir1<NZ; ++ir1) {
    for(int ir2=0; ir2<NZ; ++ir2) {
      IFFF(ir1+NR,ir2+NR) = 100.*InteZ[ir1][ir2]/Inte;
    }
  }
  for(int ir1=0;ir1<NZ; ++ir1) {
    for(int ir2=0; ir2<NR; ++ir2) {
      IFFF(ir1+NR,ir2) = 100.*InteLZ[ir1][ir2]/2./Inte;
      IFFF(ir2,ir1+NR) = 100.*InteLZ[ir1][ir2]/2./Inte;      
    }
  }    
//  IFFF.Print("f= %15.8g");
  std::cout <<"FF L and Z " << FFL/Inte << " " << FFZ/Inte << std::endl;

  updateCache();  
  //std::cout <<"sumW " << sumW <<std::endl;   
  return IFFF;
}

void RooDalitzAmplitude::updateCache() const
{

  //update cached resparam
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    
    _resParCache[2*ir+0] = m0;
    _resParCache[2*ir+1] = g0;
    
    ir++;
  }
  delete coefIter;
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-5]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    
    _resParCache[2*ir+0] = m0;
    _resParCache[2*ir+1] = g0;
    
    ir++;
  }
  delete coefIterZ;
  

}

void RooDalitzAmplitude::getInt(double *vint, double ylo, double yhi) const
{
  CalCoupling();
  
  int nres = NR+NZ;
  double a0[20];
  for(Int_t i=0; i<20; ++i) {
    a0[i] = 0;
  }
  int smcnum = pdlz->size();//smcdata->GetEntries();
  
  double val, sweight;

  for(int i=0; i<smcnum; i++) {
    
    //mkp>2GeV
    //if(mkp<2.0) continue;
    Jpsihh_dlz &p = (*pdlz)[i];
    if(p.mkp<ylo||p.mkp>yhi) continue;
    //    filldlz(p, mkp, costheta, costheta1, costheta2, phi1, phi2, phi);
    val =  GetAmp2s(p,1);    
    sweight = p.w;
    a0[0] += val*sweight;
    for(int k = 1; k<=nres; ++k) {
      val = GetAmp2sForInt(p,k-1);
      a0[k] += val*sweight;
    }
  }
  
  
  for(int k=1; k<=nres;++k) vint[k-1] = a0[k]/a0[0];

  //  std::cout << "Integration " << inte << std::endl;
  
  updateCache();
  //update cached resparam

} 

  


//fit will use Re, Im as inputs
TComplex RooDalitzAmplitude::HelicityCoff(RooArgList ires, Int_t ihel) const
{
   
  return TComplex(((RooAbsReal&)ires[ihel*2]).getVal(),((RooAbsReal&)ires[ihel*2+1]).getVal());
  
}

//here all quantum numbers are 2 x
/* 
TComplex RooDalitzAmplitude::PartWaveCoff(RooArgList ires, int J, int lambda2, int lambda3) const
{
  //|2*J_L - 2|<=2S<= 2*J_L+2 === odd 1,3,5,7...;
  //2L = 2*S-1, 2*S + 1;
  //s2 and s3 are two times of hel2, hel3
  //  int J = 2*spin;
  int ib(0);
  TComplex c(0);
  int s2(J), s3(2);//2xspin of L; jpsi
  int JB(1);
  int m1 = lambda2-lambda3;
  EvtCGCoefSingle c1(s2,s3);
  for(int S = abs(J-2); S<=J+2; S+=2) {
    for(int L = S - 1; L<= S + 1; L+=2) {
      TComplex M(((RooAbsReal&)ires[ib*2]).getVal(),((RooAbsReal&)ires[ib*2+1]).getVal());
      if(fabs(M.Rho2()<1e-10)) { ib++; continue;}
      double fkwTmp = (L+1.0)/(S+1.0);
      EvtCGCoefSingle c2(L,S);
      TComplex tmp=sqrt(fkwTmp)
	*c1.coef(S,m1,s2,s3,lambda2,-lambda3)
	*c2.coef(JB,m1,L,S,0,m1)*M;
      //std::cout << "Test CG spin L S m1 " << J << " " << L << " " << S << " " << m1<< " " << c1.coef(S,m1,s2,s3,lambda2,-lambda3)*c2.coef(JB,m1,L,S,0,m1) << std::endl;
      c += tmp;
      ib++;
    }
  }
  return c;
}
*/

//here all quantum numbers are 2 x
TComplex RooDalitzAmplitude::PartWaveCoff(RooArgList ires, int J, int lambda2, int lambda3) const
{
  //|2*J_L - 2|<=2S<= 2*J_L+2 === odd 1,3,5,7...;
  //2L = 2*S-1, 2*S + 1;
  //s2 and s3 are two times of hel2, hel3
  //  int J = 2*spin;
  int ib(0);
  TComplex c(0);
  int s2(J), s3(2);//2xspin of L; jpsi
  int JB(1);
  int m1 = lambda2-lambda3;
//  EvtCGCoefSingle c1(s2,s3);
  for(int S = abs(J-2); S<=J+2; S+=2) {
    for(int L = S - 1; L<= S + 1; L+=2) {
      TComplex M(((RooAbsReal&)ires[ib*2]).getVal(),((RooAbsReal&)ires[ib*2+1]).getVal());
      if((M.Rho2()<1e-10)) { ib++; continue;}
      double fkwTmp = (L+1.0)/(JB+1.0);
//      EvtCGCoefSingle c2(L,S);
    //  EvtCGCoefSingle c1(s2,s3);
  //   std::cout << "begin " << S << " " << L << std::endl;
     double ccg(1.);
     switch(s2) {
      case 1: {
         ccg = CG1.coef(S,m1,s2,s3,lambda2,-lambda3);
         break;
      }
      case 3: {
         ccg = CG3.coef(S,m1,s2,s3,lambda2,-lambda3);
         break;
      }
      case 5: {
         ccg = CG5.coef(S,m1,s2,s3,lambda2,-lambda3);
         break;
      }
      case 7: {
         ccg = CG7.coef(S,m1,s2,s3,lambda2,-lambda3);
         break;
      }
      case 9: {
         ccg = CG9.coef(S,m1,s2,s3,lambda2,-lambda3);
         break;
      }
      default: std::cout << "CG wrong" << std::endl;
     }
      TComplex tmp=sqrt(fkwTmp)
        *ccg
	//*c1.coef(S,m1,s2,s3,lambda2,-lambda3)
//	*c2.coef(JB,m1,L,S,0,m1)*M;
        *C2[(S-1)/2][(L-S+1)/2]*M;
//        std::cout << "end" << std::endl;
      if(m1<0&&L>S) tmp   = -tmp;
      //std::cout << "Test CG spin L S m1 " << J << " " << L << " " << S << " " << m1<< " " << c1.coef(S,m1,s2,s3,lambda2,-lambda3)*c2.coef(JB,m1,L,S,0,m1) << std::endl;
      c += tmp;
      ib++;
    }
  }
  return c;
}


//here all quantum numbers are 2 x
TComplex RooDalitzAmplitude::PartWaveCoffZ(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const
{
  TComplex HB(0,0);
  int SB = J;//2xZ spin
  for(int LB = SB - 1; LB<= SB + 1; LB+=2) {
    TComplex tmp = TComplex(1.0,0)*C2[(SB-1)/2][(LB-SB+1)/2]*sqrt((LB+1.0)/2.0);
    if(LB>SB) {
      TComplex M(((RooAbsReal&)ires[0]).getVal(),((RooAbsReal&)ires[1]).getVal());
      if((M.Rho2()<1e-10)) {tmp = 0.0; continue;  }
      tmp = tmp * M;
      if(lambdaZ<0) tmp  = -tmp;
    }
    HB += tmp;
  }

  
  //|2*J_L - 2|<=2S<= 2*J_L+2 === odd 1,3,5,7...;
  //2L = 2*S-1, 2*S + 1;
  //s2 and s3 are two times of hel2, hel3
  //  int J = 2*spin;

  int parity = (int)((RooAbsReal&)ires[ires.getSize()-1]).getVal();
   
  int ib(1);
  TComplex c(0);
  int m1 = lambdaPsi-lambdap;
  
  double ccg1(1.0);
  for(int S = 1; S <=3 ; S+=2) {
    for(int L = abs(J -S); L<= J + S; L+=2) {
      //(-1)*(-1)^LR = P_Lz
      if((pow(-1,(int)(L/2)+1)*parity)<0) continue;
      // std::cout << "S L " << S << " " << L << std::endl;
      if(S<abs(m1)) {ib++; continue; } 
      ccg1 = CG21.coef(S,m1,2,1,lambdaPsi,-lambdap);
      //  EvtCGCoefSingle c1(s2,s3);
      //std::cout << "ib " << ib << std::endl;
      if(ib>=4) std::cout << "why Z parity" << std::endl;
      TComplex M(((RooAbsReal&)ires[ib*2]).getVal(),((RooAbsReal&)ires[ib*2+1]).getVal());
      //std::cout << "M " << M << std::endl;
      if((M.Rho2()<1e-10)) { ib++; continue;}
      double fkwTmp = (L+1.0)/(J+1.0); //S should be JB;
    
      //      EvtCGCoefSingle c2(L,S);
      //  EvtCGCoefSingle c1(s2,s3);
      //   std::cout << "begin " << S << " " << L << std::endl;
      double ccg(1.);
      if(J==1) {
        ccg = C2[(S-1)/2][(L-S+1)/2];
        if(m1<0&&L>S) ccg   = -ccg;
      } else if(J==3) {
        if(S==1) {
          if(L==2) {
	    ccg = CG21.coef(J,m1,L,S,0,m1);
          }else if(L==4) {
	    ccg = CG41.coef(J,m1,L,S,0,m1);
          } else { 
	    std::cout << "why CG J==3 S==1 L" << std::endl; 
	    ccg = 0.0;
          } 
	}else if(S==3) {
	  switch(L) {
	  case 0: {
	    ccg = CG03.coef(J,m1,L,S,0,m1);
	    break;
	  }
	  case 2: {
	    ccg = CG23.coef(J,m1,L,S,0,m1);
	    break;
	  }
	  case 4: {
	    ccg = CG43.coef(J,m1,L,S,0,m1);
	    break;
	  }
	  case 6: {
	    ccg = CG63.coef(J,m1,L,S,0,m1);
	    break;
	  }
	    
	  default: std::cout << "CG wrong" << std::endl;
	  }          
	} else {
	  std::cout << " why CG J==3 S?" << std::endl;
	  ccg = 0.0;
	}   
      } else {
	EvtCGCoefSingle c2(L,S);
	ccg = c2.coef(J,m1,L,S,0,m1);
      }
      
      TComplex tmp=sqrt(fkwTmp)*
        ccg
	//*c1.coef(S,m1,s2,s3,lambda2,-lambda3)
	//	*c2.coef(JB,m1,L,S,0,m1)*M;
        *ccg1*M;
      //        std::cout << "end" << std::endl;
      //      if(m1<0&&L>S) tmp   = -tmp;
      //std::cout << "Test CG spin L S m1 " << J << " " << L << " " << S << " " << m1<< " " << c1.coef(S,m1,s2,s3,lambda2,-lambda3)*c2.coef(JB,m1,L,S,0,m1) << std::endl;
      c += tmp;
      ib++;
    }
  }
  return c*HB;
}

Double_t RooDalitzAmplitude::BTerm(Double_t Spin, Double_t mpp, Double_t mr) const
{
  Double_t c(0);
  
  //  double pi=TMath::Pi();
  // double deg2rad = pi/180.;
  
  Double_t J = Spin;
  int LB = (int)(J-1.5);
  if(LB<0) LB = 0;

  double pB = getp(m_lb, m_jpsi, mpp);
  //for NR
  if(mr<-500.) return pow(pB/m_lb, LB); 
  double pB0 = pB;
  if(mr>1e-10&&mr+m_jpsi<m_lb) pB0 = getp(m_lb, m_jpsi, mr);
  if(mr+m_jpsi>m_lb) {
    double mmin = m_k+m_p;
    double mmax = m_lb-m_jpsi;
    double mreff = mmin+0.5*(mmax-mmin)*(1.0+tanh((mr-(mmin+mmax)/2.)/(mmax-mmin)));
    pB0 = getp(m_lb, m_jpsi, mreff);
  }    
  //  double phi00 = ((RooAbsReal&)ires[ihel*2+1]).getVal()*deg2rad;
  c = F_BW(_FFB,LB,pB,pB0) * pow(pB/m_lb, LB);
  // if(h3<0) //lamda_3 <0 /\->pK strong decay???
  //
  
  return c;
  
}

Double_t RooDalitzAmplitude::BTermZ(Double_t Spin, Double_t mpp, Double_t mr) const
{
  Double_t c(0);
  
  //  double pi=TMath::Pi();
  // double deg2rad = pi/180.;
  
  Double_t J = Spin;
  int LB = (int)(J-0.5);
  if(LB<0) LB = 0;

  double pB = getp(m_lb, m_k, mpp);
  double pB0 = pB;
  if(mr>1e-10&&mr+m_k<m_lb) pB0 = getp(m_lb, m_k, mr);
  
  //  double phi00 = ((RooAbsReal&)ires[ihel*2+1]).getVal()*deg2rad;
  c = F_BW(_FFB,LB,pB,pB0) * pow(pB/m_lb, LB);
  // if(h3<0) //lamda_3 <0 /\->pK strong decay???
  //
  
  return c;
  
}



////////////////////////////////////////////////
//   Breit Wigner Resonance
////////////////////////////////////////////////
void RooDalitzAmplitude::breit_wigner(double m, double gamma, double e2, double &r_ampl, double &i_ampl) const
{
  double de2 = m*m-e2;
  double gamma_m = gamma*m;
  double d = (de2*de2+gamma_m*gamma_m);
  r_ampl = de2/d;
  i_ampl = gamma_m/d;
}
/////////////////////////////////////////////
//Blatt-Weisskopf form factors
/////////////////////////////////////////////
Double_t RooDalitzAmplitude::F_BW(double r, int L, double p, double p0) const
{
  double z = pow(r*p,2);
  double z0 = pow(r*p0,2);
  if(L==0) return 1.0;
  if(L==1) return sqrt((1.+z0)/(1.+z));
  if(L==2) return sqrt((z0*z0+3*z0+9.)/(z*z+3*z+9.));
  if(L==3) return sqrt((z0*z0*z0+6*z0*z0+45*z0+225)/(z*z*z+6*z*z+45*z+225));
  if(L==4) return sqrt((pow(z0,4)+10*pow(z0,3)+135*z0*z0+1575*z0+11025)
                         /(pow(z,4)+10*pow(z,3)+135*z*z+1575*z+11025));
  if(L==5) return sqrt((pow(z0,5)+15*pow(z0,4)+315*pow(z0,3)+6300*pow(z0,2)+99225*z0+893025)
                    /(pow(z,5)+15*pow(z,4)+315*pow(z,3)+6300*pow(z,2)+99225*z+893025));
  
  return 1.0;
}//////////////////////////////////////////////////
// Breit Wigner Amplitude
/////////////////////////////////////////////////
bool RooDalitzAmplitude::BW_AMP(double m_r, double gamma_r, double mpp, int LR,
                             double &ampl_r, double &ampl_i) const
{
  ampl_r = 0;
  ampl_i = 0;
  double m2pp = mpp*mpp;
//  if(J>2) return false;
 // if(abs(helz)>1) return false;
 // if(J==0&&abs(helz)!=0) return true;
  //  int LB = 1;
  //int LR = (J-0.5);
  // if(J==1) {
  //  LB = 0; //changed by LM
  //} else if(J==2) {
  //  LB = 1; //changed by LM
  //}
  //double pB = getpB(mpp);
  double pR = getp(mpp, m_p, m_k);
  //For NR
  if(m_r<-500) {
    ampl_r = pow(pR,LR);
    ampl_i = 0;
    return true;
  }
  double pR0=pR;
  if(m_r>m_p+m_k) {
    pR0 = getp(m_r, m_p, m_k);//sqrt(m_r*m_r-4*m2_pi)/2.;
  }   else {
    double mmin = m_k+m_p;
    double mmax = m_lb-m_jpsi;
    double mreff = mmin+0.5*(mmax-mmin)*(1.0+tanh((m_r-(mmin+mmax)/2.)/(mmax-mmin)));
    pR0 = getp(mreff, m_p, m_k);
  }
  //double FB = F_BW(_FFB,LB,pB,pB0);
  double FR = F_BW(_FFR,LR,pR,pR0);
//  cout << "_FFR " << _FFR << endl;

  double bw_r(0),bw_i(0);
  double gamma = gamma_r;
  //if(with_dep!=0) gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
  if(m_r>m_p+m_k)  {gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR; }
  else if(m_r<1.43&&m_r>0) {
  /*
    //where LR = 0
    double msig = 1.192642;
    double mpi0 = 0.1349766;
    double pRSigPi = getp(mpp, msig, mpi0);
    double rhosigpi = 2.0*pRSigPi/mpp;
    double rhokp = 2.0*pR/mpp;
    gamma = gamma_r * (rhosigpi+rhokp)*9.0645/2.;
//    std::cout << "gamma_r " << gamma_r << " " << gamma << std::endl; 
*/
    double msig = 1.18937;//1.192642;
    double mpi0 = 0.13957018;//0.1349766;
    double pRSigPi = getp(mpp, msig, mpi0);
//    double rhosigpi = 2.0*pRSigPi/mpp;
//    double rhokp = 2.0*pR/mpp;
    //mine
//    gamma = gamma_r * (rhosigpi+rhokp)*m_r/2./getp(m_r,msig,mpi0);//9.0645/2.;

    //wehre LR = 0;
    gamma = 0.0;
    pR0 = getp(m_r,msig,mpi0);
    FR = 1.0;//F_BW(_FFR,LR,pR,pR0);
    gamma += gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
    FR = 1.0;//F_BW(_FFR,LR,pRSigPi,pR0);
    gamma += 0.0505*pow((pRSigPi/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
  }

  breit_wigner(m_r, gamma, m2pp, bw_r, bw_i);
  
  //charged 4/17 mpp->mr
//  double factor = FR*pow(pR/mpp,LR);
  double factor = FR*pow(pR/m_r,LR);  
  ampl_r = factor*bw_r;
  ampl_i = factor*bw_i;
  return true;
}


//Flatte
bool RooDalitzAmplitude::BW_AMP(double m_r, double gamma_r, double mpp, int LR,
                             double &ampl_r, double &ampl_i, double g21) const
{
  ampl_r = 0;
  ampl_i = 0;
  double m2pp = mpp*mpp;
//  if(J>2) return false;
 // if(abs(helz)>1) return false;
 // if(J==0&&abs(helz)!=0) return true;
  //  int LB = 1;
  //int LR = (J-0.5);
  // if(J==1) {
  //  LB = 0; //changed by LM
  //} else if(J==2) {
  //  LB = 1; //changed by LM
  //}
  //double pB = getpB(mpp);
  double pR = getp(mpp, m_p, m_k);
  //For NR

  double pR0=pR;
  if(m_r>m_p+m_k) pR0 = getp(m_r, m_p, m_k);//sqrt(m_r*m_r-4*m2_pi)/2.;
  
  //double FB = F_BW(_FFB,LB,pB,pB0);
  //take FR = 1.0;
  double FR = 1.0;//F_BW(_FFR,LR,pR,pR0);
//  cout << "_FFR " << _FFR << endl;

  double bw_r(0),bw_i(0);
  double gamma = gamma_r;
  //if(with_dep!=0) gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
  gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
  double mN = 0.939565379;//1.192642;
  double mEta = 0.547862;//0.1349766;
  double pRNEta = getp(mpp, mN, mEta);
  
  double gammaNEta = pow((pRNEta/pR0),2*LR+1)*(m_r/mpp)*g21*gamma_r;
  double de2 = m_r*m_r - m2pp;
  double gamma_m = gamma * m_r;
  if(mpp<mN+mEta) {
     de2 += gammaNEta * m_r;
  } else {
     gamma_m += gammaNEta * m_r;
  }
    //wehre LR = 0;
  double d = (de2*de2+gamma_m*gamma_m);
  bw_r = de2/d;
  bw_i = gamma_m/d;
  
  double factor = FR*pow(pR/m_r,LR);  
  ampl_r = factor*bw_r;
  ampl_i = factor*bw_i;
  return true;
}



bool RooDalitzAmplitude::BW_AMPZ(double m_r, double gamma_r, double mpp, int LR,
                             double &ampl_r, double &ampl_i) const
{
  ampl_r = 0;
  ampl_i = 0;
  double m2pp = mpp*mpp;
//  if(J>2) return false;
 // if(abs(helz)>1) return false;
 // if(J==0&&abs(helz)!=0) return true;
  //  int LB = 1;
  //int LR = (J-0.5);
  // if(J==1) {
  //  LB = 0; //changed by LM
  //} else if(J==2) {
  //  LB = 1; //changed by LM
  //}
  //double pB = getpB(mpp);
  double pR = getp(mpp, m_p, m_jpsi);
  double pR0=pR;
  if(m_r>m_p+m_jpsi) pR0 = getp(m_r, m_p, m_jpsi);//sqrt(m_r*m_r-4*m2_pi)/2.;
  
  //double FB = F_BW(_FFB,LB,pB,pB0);
  double FR = F_BW(_FFR,LR,pR,pR0);
//  cout << "_FFR " << _FFR << endl;

  double bw_r(0),bw_i(0);
  double gamma = gamma_r;
  //if(with_dep!=0) gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
  if(m_r>m_p+m_jpsi)  gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
  breit_wigner(m_r, gamma, m2pp, bw_r, bw_i);
//charged mpp->mr
//  double factor = FR*pow(pR/mpp,LR);
  double factor = FR*pow(pR/m_r,LR);  
  ampl_r = factor*bw_r;
  ampl_i = factor*bw_i;
  return true;
}

Double_t RooDalitzAmplitude::getp(double M, double m1, double m2) const
{
  double M2 = M*M;
//  if(M<m1+m2) std::cout << "why M<m1+m2" << std::endl;
  //return abs
  return sqrt(fabs((M2-pow(m1+m2,2))*(M2-pow(m1-m2,2))))/2./M;
}

void RooDalitzAmplitude::filldlz(Jpsihh_dlz &dlz, Double_t xmkp, Double_t xcostheta,
                                 Double_t xcostheta1, Double_t xcostheta2,
                                 Double_t xphi1, Double_t xphi2, 
				 Double_t xcosthetaB, Double_t xcosthetaZ, Double_t xcosthetaPsi,
				 Double_t xphiZ, Double_t xphiPsi, Double_t xphiMu, 
				 Double_t xcosthetap, Double_t xalphaMu,
				 Double_t xmjpsip,
				 Double_t sw) const
{
  dlz.mkp = xmkp; 
  dlz.mjpsip = xmjpsip;
  dlz.theta = acos(xcostheta);
  dlz.theta1 = acos(xcostheta1);
  dlz.theta2 = acos(xcostheta2);
  dlz.phi1 = xphi1;
  dlz.phi2 = xphi2;

  dlz.thetaB = acos(xcosthetaB);
  dlz.thetaZ = acos(xcosthetaZ);
  dlz.thetaPsi = acos(xcosthetaPsi);
  dlz.phiZ = xphiZ;
  dlz.phiPsi = xphiPsi;
  dlz.phiMu = xphiMu;
  dlz.thetap = acos(xcosthetap);
  dlz.alphaMu = xalphaMu;

//  dlz.phi = xphi;

  dlz.w = sw;
  
  int nres = NR+NZ;
  for(int ir=0; ir<nres; ++ir) {
    dlz.defed[ir] = false;
  }/*
    for(int i=0;i<=1; ++i) {
      for(int j=0; j<=1; ++j) {
	for(int k=0; k<=1; ++k) {
	  for(int m=0; m<6; ++m) {
	    dlz.ARe[ir][i][j][k][m] = 0.0;
	    dlz.AIm[ir][i][j][k][m] = 0.0;
	  }
	}
	}
    }
  }*/

}

//_____________________________________________________________________________
RooAbsReal*  RooDalitzAmplitude::createSUM(RooAbsData& data, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, 
                                             const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) 
{
  // Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset
  // is binned, a binned likelihood is constructed. 
  //
  // The following named arguments are supported
  //
  // ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables
  // Extended(Bool_t flag)           -- Add extended likelihood term, off by default
  // Range(const char* name)         -- Fit only data inside range with given name
  // Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named "fit" is created on the fly on all observables.
  //                                    Multiple comma separated range names can be specified.
  // SumCoefRange(const char* name)  -- Set the range in which to interpret the coefficients of RooAddPdf components  
  // NumCPU(int num, int strat)      -- Parallelize NLL calculation on num CPUs
  //
  //                                    Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks 
  //                                    Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with 
  //                                                 a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy
  //                                    Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process
  //                                                 and distribute components over processes. This approach can be benificial if normalization calculation time
  //                                                 dominates the total computation time of a component (since the normalization calculation must be performed
  //                                                 in each process in strategies 0 and 1. However beware that if the RooSimultaneous components do not share many
  //                                                 parameters this strategy is inefficient: as most minuit-induced likelihood calculations involve changing
  //                                                 a single parameter, only 1 of the N processes will be active most of the time if RooSimultaneous components
  //                                                 do not share many parameters
  //                                    Strategy 3 = RooFit::Hybrid --> Follow strategy 0 for all RooSimultaneous components, except those with less than
  //                                                 30 dataset entries, for which strategy 2 is followed.
  //
  // Optimize(Bool_t flag)           -- Activate constant term optimization (on by default)
  // SplitRange(Bool_t flag)         -- Use separate fit ranges in a simultaneous fit. Actual range name for each
  //                                    subsample is assumed to by rangeName_{indexState} where indexState
  //                                    is the state of the master index category of the simultaneous fit
  // Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters
  // ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood
  // GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.
  //                                        If none are specified the constrained parameters are used
  // GlobalObservablesTag(const char* tagName) -- Define the set of normalization observables to be used for the constraint terms by a string attribute
  //                                              associated with pdf observables that match the given tagName 
  // Verbose(Bool_t flag)           -- Constrols RooFit informational messages in likelihood construction
  // CloneData(Bool flag)           -- Use clone of dataset in SUM (default is true)
  // Offset(Bool_t)                  -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This
  //                                    can improve numeric stability in simultaneously fits with components with large likelihood values
  // 
  // 
  
  RooLinkedList l ;
  l.Add((TObject*)&arg1) ;  l.Add((TObject*)&arg2) ;  
  l.Add((TObject*)&arg3) ;  l.Add((TObject*)&arg4) ;
  l.Add((TObject*)&arg5) ;  l.Add((TObject*)&arg6) ;  
  l.Add((TObject*)&arg7) ;  l.Add((TObject*)&arg8) ;
  return createSUM(data,l) ;
}




//_____________________________________________________________________________
RooAbsReal*  RooDalitzAmplitude::createSUM(RooAbsData& data, const RooLinkedList& cmdList) 
{
  // Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset
  // is binned, a binned likelihood is constructed. 
  //
  // See RooAbsPdf::createSUM(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4, 
  //                                    RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8) 
  //
  // for documentation of options


  // Select the pdf-specific commands 
  RooCmdConfig pc(Form("RooAbsPdf::createSUM(%s)",GetName())) ;

  pc.defineString("rangeName","RangeWithName",0,"",kTRUE) ;
  pc.defineString("addCoefRange","SumCoefRange",0,"") ;
  pc.defineString("globstag","GlobalObservablesTag",0,"") ;
  pc.defineDouble("rangeLo","Range",0,-999.) ;
  pc.defineDouble("rangeHi","Range",1,-999.) ;
  pc.defineInt("splitRange","SplitRange",0,0) ;
  pc.defineInt("ext","Extended",0,2) ;
  pc.defineInt("numcpu","NumCPU",0,1) ;
  pc.defineInt("interleave","NumCPU",1,0) ;
  pc.defineInt("verbose","Verbose",0,0) ;
  pc.defineInt("optConst","Optimize",0,0) ;
  pc.defineInt("cloneData","CloneData",2,0) ;
  pc.defineSet("projDepSet","ProjectedObservables",0,0) ;
  pc.defineSet("cPars","Constrain",0,0) ;
  pc.defineSet("glObs","GlobalObservables",0,0) ;
  pc.defineInt("constrAll","Constrained",0,0) ;
  pc.defineInt("doOffset","OffsetLikelihood",0,0) ;
  pc.defineSet("extCons","ExternalConstraints",0,0) ;
  pc.defineMutex("Range","RangeWithName") ;
  pc.defineMutex("Constrain","Constrained") ;
  pc.defineMutex("GlobalObservables","GlobalObservablesTag") ;
    
  // Process and check varargs 
  pc.process(cmdList) ;
  if (!pc.ok(kTRUE)) {
    return 0 ;
  }

  // Decode command line arguments
  const char* rangeName = pc.getString("rangeName",0,kTRUE) ;
  const char* addCoefRangeName = pc.getString("addCoefRange",0,kTRUE) ;
  const char* globsTag = pc.getString("globstag",0,kTRUE) ;
  Int_t ext      = pc.getInt("ext") ;
  Int_t numcpu   = pc.getInt("numcpu") ;
  RooFit::MPSplit interl = (RooFit::MPSplit) pc.getInt("interleave") ;

  Int_t splitr   = pc.getInt("splitRange") ;
  Bool_t verbose = pc.getInt("verbose") ;
  Int_t optConst = pc.getInt("optConst") ;
  Int_t cloneData = pc.getInt("cloneData") ;
  Int_t doOffset = pc.getInt("doOffset") ;
  
  // If no explicit cloneData command is specified, cloneData is set to true if optimization is activated
  if (cloneData==2) {
    cloneData = optConst ;
  }


  RooArgSet* cPars = pc.getSet("cPars") ;
  RooArgSet* glObs = pc.getSet("glObs") ;
  if (pc.hasProcessed("GlobalObservablesTag")) {
    if (glObs) delete glObs ;
    RooArgSet* allVars = getVariables() ;
    glObs = (RooArgSet*) allVars->selectByAttrib(globsTag,kTRUE) ;
//    coutI(Minimization) << "User-defined specification of global observables definition with tag named '" <<  globsTag << "'" << endl ;
    delete allVars ;
  } else if (!pc.hasProcessed("GlobalObservables")) {

    // Neither GlobalObservables nor GlobalObservablesTag has been processed - try if a default tag is defined in the head node
    // Check if head not specifies default global observable tag
    const char* defGlobObsTag = getStringAttribute("DefaultGlobalObservablesTag") ;
    if (defGlobObsTag) {
      coutI(Minimization) << "p.d.f. provides built-in specification of global observables definition with tag named '" <<  defGlobObsTag << "'" << std::endl ;
      if (glObs) delete glObs ;
      RooArgSet* allVars = getVariables() ;
      glObs = (RooArgSet*) allVars->selectByAttrib(defGlobObsTag,kTRUE) ;
    }
  }
  
    
  Bool_t doStripDisconnected=kFALSE ;

  // If no explicit list of parameters to be constrained is specified apply default algorithm
  // All terms of RooProdPdfs that do not contain observables and share a parameters with one or more
  // terms that do contain observables are added as constraints.
  if (!cPars) {    
    cPars = getParameters(data,kFALSE) ;
    doStripDisconnected=kTRUE ;
  }
  const RooArgSet* extCons = pc.getSet("extCons") ;

  // Process automatic extended option
  if (ext==2) {
    ext = ((extendMode()==CanBeExtended || extendMode()==MustBeExtended)) ? 1 : 0 ;
    if (ext) {
      coutI(Minimization) << "p.d.f. provides expected number of events, including extended term in likelihood." << std::endl ;
    }
  }

  if (pc.hasProcessed("Range")) {
    Double_t rangeLo = pc.getDouble("rangeLo") ;
    Double_t rangeHi = pc.getDouble("rangeHi") ;
   
    // Create range with name 'fit' with above limits on all observables
    RooArgSet* obs = getObservables(&data) ;
    TIterator* iter = obs->createIterator() ;
    RooAbsArg* arg ;
    while((arg=(RooAbsArg*)iter->Next())) {
      RooRealVar* rrv =  dynamic_cast<RooRealVar*>(arg) ;
      if (rrv) rrv->setRange("fit",rangeLo,rangeHi) ;
    }
    // Set range name to be fitted to "fit"
    rangeName = "fit" ;
  }

  RooArgSet projDeps ;
  RooArgSet* tmp = pc.getSet("projDepSet") ;  
  if (tmp) {
    projDeps.add(*tmp) ;
  }

  // Construct SUM
  RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::CollectErrors) ;
  RooAbsReal* nll ;
  std::string baseName = Form("sum_%s_%s",GetName(),data.GetName()) ;
  if (!rangeName || strchr(rangeName,',')==0) {
    // Simple case: default range, or single restricted range
    //cout<<"FK: Data test 1: "<<data.sumEntries()<<std::std::endl;

    nll = new RooSUMVar(baseName.c_str(),"sum(likelihood)",*this,data,projDeps,ext,rangeName,addCoefRangeName,numcpu,interl,verbose,splitr,cloneData) ;

  } else {
    // Composite case: multiple ranges
    RooArgList nllList ;
    const size_t bufSize = strlen(rangeName)+1;
    char* buf = new char[bufSize] ;
    strlcpy(buf,rangeName,bufSize) ;
    char* token = strtok(buf,",") ;
    while(token) {
      RooAbsReal* nllComp = new RooSUMVar(Form("%s_%s",baseName.c_str(),token),"-log(likelihood)",*this,data,projDeps,ext,token,addCoefRangeName,numcpu,interl,verbose,splitr,cloneData) ;
      nllList.add(*nllComp) ;
      token = strtok(0,",") ;
    }
    delete[] buf ;
    nll = new RooAddition(baseName.c_str(),"sum(likelihood)",nllList,kTRUE) ;
  }
  RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::PrintErrors) ;
  
  // Collect internal and external constraint specifications
  RooArgSet allConstraints ;
  if (cPars && cPars->getSize()>0) {
    RooArgSet* constraints = getAllConstraints(*data.get(),*cPars,doStripDisconnected) ;
    allConstraints.add(*constraints) ;
    delete constraints ;
    
  }
  if (extCons) {
    allConstraints.add(*extCons) ;
  }

/*  // Include constraints, if any, in likelihood
  RooAbsReal* nllCons(0) ;
  if (allConstraints.getSize()>0 && cPars) {   

    coutI(Minimization) << " Including the following contraint terms in minimization: " << allConstraints << std::endl ;
    if (glObs) {
      coutI(Minimization) << "The following global observables have been defined: " << *glObs << std::endl ;
    }
    nllCons = new RooConstraintSum(Form("%s_constr",baseName.c_str()),"nllCons",allConstraints,glObs ? *glObs : *cPars) ;
    nllCons->setOperMode(ADirty) ;
    RooAbsReal* orignll = nll ;

    nll = new RooAddition(Form("%s_with_constr",baseName.c_str()),"nllWithCons",RooArgSet(*nll,*nllCons)) ;
    nll->addOwnedComponents(RooArgSet(*orignll,*nllCons)) ;
  }

  */
  if (optConst) {
    nll->constOptimizeTestStatistic(RooAbsArg::Activate,optConst>1) ;
  }

  if (doStripDisconnected) {
    delete cPars ;
  }

  if (doOffset) {
    nll->enableOffsetting(kTRUE) ;
  }

  return nll ;
}





/*
Double_t RooDalitzAmplitude::getpB(double mpp) const
{
  return sqrt((m2_bs-(m_jpsi+mpp)*(m_jpsi+mpp))*(m2_bs-(m_jpsi-mpp)*(m_jpsi-mpp)))/2./m_bs;
}

Double_t RooDalitzAmplitude::getpR(double mpp) const
{
  return sqrt(mpp*mpp-4*m2_pi)/2.;
}
*/


/***********************************************************************************************************************************************************
							Efficiencies/CFIT
**********************************************************************************************************************************************************/


void RooDalitzAmplitude::eff_init(int nBinX, int nBinY, TString inTreeLoc, bool isBkgInit)
{
  int npoint;
  if(!isBkgInit){
    std::cout<<"Initializing signal efficiency"<<std::endl;
    mc_nBinY = nBinY;
    mc_nBinX = nBinX;
    npoint = mc_npoint;
  }
  else{
    std::cout<<"Initializing bkg efficiency"<<std::endl;
    bkg_nBinY = nBinY;  
    bkg_nBinX = nBinX;
    npoint = bkg_npoint;
  }

  mKp_min =  m_k + m_p;
  mKp_max = m_lb - m_jpsi;


  //std::cout<<"mkp min: "<<mKp_min<<", max: "<<mKp_max<<std::endl;
  std::vector<double>* init_cosLb;
  std::vector<double>* init_cosL;
  std::vector<double>* init_cosJpsi;
  std::vector<double>* init_phiMu;
  std::vector<double>* init_phiK;

  double wBinX, cos_wBinY, phi_wBinY;
  if(!isBkgInit){
    wBinX = mc_wBinX =  ( mKp_max - mKp_min )/nBinX;
    cos_wBinY = mc_cos_wBinY =  2.0/nBinY;
    phi_wBinY = mc_phi_wBinY =  2.0*TMath::Pi()/nBinY;

    init_cosLb = &mceff_cosLb;
    init_cosL = &mceff_cosL;
    init_cosJpsi = &mceff_cosJpsi;
    init_phiMu = &mceff_phiMu;
    init_phiK = &mceff_phiK;

  }else{
    wBinX = bkg_wBinX =  ( mKp_max - mKp_min )/nBinX;
    cos_wBinY = bkg_cos_wBinY =  2.0/nBinY;
    phi_wBinY = bkg_phi_wBinY =  2.0*TMath::Pi()/nBinY;

    init_cosLb = &bkgeff_cosLb;
    init_cosL = &bkgeff_cosL;
    init_cosJpsi = &bkgeff_cosJpsi;
    init_phiMu = &bkgeff_phiMu;
    init_phiK = &bkgeff_phiK;
  }
  

  std::cout<<"Mass Bins: "<<nBinX<<std::endl;
  std::cout<<"Angle Bins: "<<nBinY<<std::endl;
  std::cout<<"n points: "<<npoint<<std::endl;
  std::cout<<"M_Res Bin Width: "<<wBinX<<std::endl;
  std::cout<<"Cos Bin width: "<<cos_wBinY<<std::endl;
  std::cout<<"Phi Bin width: "<<phi_wBinY<<std::endl;

  if( init_cosLb->size() )init_cosLb->clear();
  init_cosLb->reserve(nBinX*nBinY);

  if( init_cosL->size() )init_cosL->clear();
  init_cosL->reserve(nBinX*nBinY);

  if( init_cosJpsi->size() )init_cosJpsi->clear();
  init_cosJpsi->reserve(nBinX*nBinY);

  if( init_phiMu->size() )init_phiMu->clear();
  init_phiMu->reserve(nBinX*nBinY);

  if( init_phiK->size() )init_phiK->clear();
  init_phiK->reserve(nBinX*nBinY);


  for( int iBX=0;iBX<nBinX;iBX++ ){
    for( int iBY=0; iBY<nBinY; iBY++ ){
      init_cosLb->push_back(0.0);
      init_cosL->push_back(0.0);
      init_cosJpsi->push_back(0.0);
      init_phiMu->push_back(0.0);
      init_phiK->push_back(0.0);
    }
  }

  double nsum(0.0);

    
  TChain* smcdata = new TChain("h1");
  smcdata->Add(inTreeLoc);
  
  
  /*
  TChain* i_smcdata = new TChain("MyTuple");
  i_smcdata->Add(inTreeLoc);
   
  TTree* smcdata = new TChain("MyTuple");  
  if(isBkgInit){
    smcdata=i_smcdata->CopyTree("mass<5.62");
    //    smcdata=i_smcdata->CopyTree("mass>5.55 && mass<5.69");
    //smcdata=i_smcdata->CopyTree("mass<5.62 && mass>5.55");
  }
  else{
    smcdata=i_smcdata;
  }
*/  

   
  double MCM_Kp, MCcosTheta_Lb, MCcosTheta_L, MCcosTheta_Jpsi, MCphiMu, MCphiK;
  double MCM_Jpsip;
  double MCnsig_sw;


  smcdata->SetBranchAddress("mkp", &MCM_Kp);
  smcdata->SetBranchAddress("mjpsip", &MCM_Jpsip);
  smcdata->SetBranchAddress("cosTheta_Lb", &MCcosTheta_Lb);
  smcdata->SetBranchAddress("cosTheta_L", &MCcosTheta_L);
  smcdata->SetBranchAddress("cosTheta_Jpsi", &MCcosTheta_Jpsi);
  smcdata->SetBranchAddress("phiMu", &MCphiMu);
  smcdata->SetBranchAddress("phiK", &MCphiK);
  smcdata->SetBranchAddress("sw", &MCnsig_sw);

  int smcnum = smcdata->GetEntries();

  std::cout<<"Number of entries in MC: "<<smcnum<<std::endl;


  for(int i=0;i<smcnum;i++){
    smcdata->GetEntry(i);
        
    double q = 0.5*sqrt( std::max(pow(MCM_Kp*MCM_Kp - m_k*m_k - m_p*m_p,2) - 4*pow(m_k*m_p,2), 0.0001))/MCM_Kp;
    double p = 0.5*sqrt( std::max(pow(m_lb*m_lb - m_jpsi*m_jpsi - MCM_Kp*MCM_Kp,2) - 4*pow(m_jpsi*MCM_Kp,2), 0.0001))/m_lb;
    
    //if(isBkgInit)p=q=1;

    int iBinX = ( MCM_Kp - mKp_min )/wBinX;
    if( iBinX<0 ){  iBinX=0; }
    if( iBinX>= nBinX ){ iBinX=nBinX-1;}
    
    double normsw = MCnsig_sw/(p*q);
    
    nsum += normsw;
    int jBinY_cosL = ( MCcosTheta_L +1.0 )/cos_wBinY;
    if( jBinY_cosL< 0 ){ jBinY_cosL=0; }
    if( jBinY_cosL>= nBinY ){ jBinY_cosL=nBinY-1; }
    (*init_cosL)[iBinX*nBinY+jBinY_cosL]  += normsw;

    int jBinY_cosLb = ( MCcosTheta_Lb +1.0 )/cos_wBinY;
    if( jBinY_cosLb< 0 ){ jBinY_cosLb=0; }
    if( jBinY_cosLb>= nBinY ){ jBinY_cosLb=nBinY-1; }
    (*init_cosLb)[iBinX*nBinY+jBinY_cosLb]  += normsw;
            
    int jBinY_cosJpsi = ( MCcosTheta_Jpsi +1.0 )/cos_wBinY;
    if( jBinY_cosJpsi< 0 ){ jBinY_cosJpsi=0; }
    if( jBinY_cosJpsi>= nBinY ){ jBinY_cosJpsi=nBinY-1; }
    (*init_cosJpsi)[iBinX*nBinY+jBinY_cosJpsi]  += normsw;
      
    int jBinY_phiMu = ( MCphiMu + TMath::Pi() )/phi_wBinY;
    if( jBinY_phiMu< 0 ){ jBinY_phiMu=0; }
    if( jBinY_phiMu>= nBinY ){ jBinY_phiMu=nBinY-1; }
    (*init_phiMu)[iBinX*nBinY+jBinY_phiMu]  += normsw;
      
    int jBinY_phiK = ( MCphiK + TMath::Pi() )/phi_wBinY;
    if( jBinY_phiK< 0 ){ jBinY_phiK=0; }
    if( jBinY_phiK>= nBinY ){ jBinY_phiK=nBinY-1; }
    (*init_phiK)[iBinX*nBinY+jBinY_phiK]  += normsw;
  }
  
  delete smcdata;
  
  //std::cout<<"post smc"<<std::endl;
  double sumcolumn(0.0);
  // normalize
  for( int iBX=0;iBX<nBinX;iBX++ ){
    
    sumcolumn = 0.0;
    for( int iBY=0; iBY<nBinY; iBY++ ){
      (*init_cosL)[iBX*nBinY+iBY] /= (nsum*wBinX*cos_wBinY);
      sumcolumn += (*init_cosJpsi)[iBX*nBinY+iBY];      
    }//end loop over y bins
    if( sumcolumn>0.0 ){
      for( int iBY=0; iBY<nBinY; iBY++ ){
        (*init_cosLb)[iBX*nBinY+iBY] /= (sumcolumn*cos_wBinY);
        (*init_cosJpsi)[iBX*nBinY+iBY] /= (sumcolumn*cos_wBinY);
        (*init_phiMu)[iBX*nBinY+iBY] /= (sumcolumn*phi_wBinY);
        (*init_phiK)[iBX*nBinY+iBY] /= (sumcolumn*phi_wBinY);
        
      }
    }
    
  }///end loop over x bins
  
  // efficiency in first and last mass bin are not determined well because of kinematic boundary
  // replaces them by neighbours??
  /*
  for( int iBY=0; iBY<nBinY; iBY++ ){
    (*init_cosL)[iBY] = (*init_cosL)[nBinY+iBY];
    (*init_cosL)[(nBinX-1)*nBinY+iBY] = (*init_cosL)[(nBinX-2)*nBinY+iBY];
  }
  */


  // put efficiencies in histograms to smooth them
  //might not want to do this!!
#if 0
  TH2D * effhist_cosL = new TH2D("effhist_cosL","effhist_cosL",nBinX,mKp_min, mKp_max,nBinY,-1.0,1.0);
  TH2D * effhist_cosLb = new TH2D("effhist_cosLb","effhist_cosLb",nBinX,mKp_min, mKp_max,nBinY,-1.0,1.0);
  TH2D * effhist_cosJpsi = new TH2D("effhist_cosJpsi","effhist_cosJpsi",nBinX,mKp_min, mKp_max,nBinY,-1.0,1.0);
  TH2D * effhist_phiMu = new TH2D("effhist_phiMu","effhist_phiMu",nBinX,mKp_min, mKp_max,nBinY,-TMath::Pi(),TMath::Pi());
  TH2D * effhist_phiK = new TH2D("effhist_phiK","effhist_phiK",nBinX,mKp_min, mKp_max,nBinY,-TMath::Pi(),TMath::Pi());
  
  for( int iBX=0;iBX<nBinX;iBX++ ){
    
    
    for( int iBY=0; iBY<nBinY; iBY++ ){
      //std::cout<<(*init_cosL)[iBX*nBinY+iBY]<<std::endl;
      effhist_cosL->Fill( mKp_min+(iBX+0.5)*wBinX, 
			  -1.0+(iBY+0.5)*cos_wBinY,  
			  (*init_cosL)[iBX*nBinY+iBY] );
      
      effhist_cosLb->Fill( mKp_min+(iBX+0.5)*wBinX, 
			   -1.0+(iBY+0.5)*cos_wBinY,  
			   (*init_cosLb)[iBX*nBinY+iBY] );
      
      effhist_cosJpsi->Fill( mKp_min+(iBX+0.5)*wBinX, 
			     -1.0+(iBY+0.5)*cos_wBinY,  
			     (*init_cosJpsi)[iBX*nBinY+iBY] );
      
      effhist_phiMu->Fill( mKp_min+(iBX+0.5)*wBinX, 
			   -TMath::Pi()+(iBY+0.5)*phi_wBinY,  
			   (*init_phiMu)[iBX*nBinY+iBY] );
      
      effhist_phiK->Fill( mKp_min+(iBX+0.5)*wBinX, 
			  -TMath::Pi()+(iBY+0.5)*phi_wBinY,  
			  (*init_phiK)[iBX*nBinY+iBY] );
      
    }
  }
  
  
  if(isBkgInit==false){
    
    std::cout<<"Smoothing"<<std::endl;
    effhist_cosL->Smooth(1,"k5b");  // others are "k5a" (looser 5x5) or k3a
    effhist_cosLb->Smooth(1,"k5b");  // others are "k5a" (looser 5x5) or k3a
    effhist_cosJpsi->Smooth(1,"k5b");  // others are "k5a" (looser 5x5) or k3a
    effhist_phiMu->Smooth(1,"k5b");  // others are "k5a" (looser 5x5) or k3a
    effhist_phiK->Smooth(1,"k5b");  // others are "k5a" (looser 5x5) or k3a
  }

  
  for( int iBX=0;iBX<nBinX;iBX++ ){
    
    for( int iBY=0; iBY<nBinY; iBY++ ){
      
      (*init_cosL)[iBX*nBinY+iBY] = effhist_cosL->GetBinContent( effhist_cosL->GetBin(iBX+1,iBY+1) );
      (*init_cosLb)[iBX*nBinY+iBY] = effhist_cosLb->GetBinContent( effhist_cosL->GetBin(iBX+1,iBY+1) );
      (*init_cosJpsi)[iBX*nBinY+iBY] = effhist_cosJpsi->GetBinContent( effhist_cosL->GetBin(iBX+1,iBY+1) );
      (*init_phiMu)[iBX*nBinY+iBY] = effhist_phiMu->GetBinContent( effhist_cosL->GetBin(iBX+1,iBY+1) );
      (*init_phiK)[iBX*nBinY+iBY] = effhist_phiK->GetBinContent( effhist_cosL->GetBin(iBX+1,iBY+1) );
      
    }
  }
  
  delete effhist_cosL;
  delete effhist_cosLb;
  delete effhist_cosJpsi;
  delete effhist_phiMu;
  delete effhist_phiK;

  
  // renormalize 
  // integrate over phase-space, calculate average efficiency
  
  double scale_cosL(1.0),scale_cosLb(1.0),scale_cosJpsi(1.0);
  double scale_phiMu(1.0), scale_phiK(1.0);
  double phsum_mL(0.0);
  double phsum_cosL(0.0),phsum_cosLb(0.0),phsum_cosJpsi(0.0);
  double phsum_phiMu(0.0),phsum_phiK(0.0);
  
  
  // integrate Dalitz plot 
  TString pref = "";
  if(isBkgInit)pref = "Bkg";
  
    for(int i_Kp=0;i_Kp<nBinX;i_Kp++){
      double mL = mKp_min + (i_Kp+0.5)*wBinX;
      
      double q=0.5*sqrt(std::max( pow( mL*mL - m_k*m_k - m_p*m_p,2) - 4*pow(m_p*m_k,2), 0.0000001))/mL;
      double p=0.5*sqrt( std::max( pow( m_lb*m_lb - m_jpsi*m_jpsi - mL*mL,2) - 4*pow(m_jpsi*mL,2),0.0000001) )/m_lb;             
      double weight(p*q);
      if( weight <=0.0 )continue;	          
      
      for(int i_cosL=0;i_cosL<nBinY;i_cosL++){
	double cosL = -1.0 + (i_cosL+0.5)*cos_wBinY;    
	double eff_cosL( mceff( mL, cosL, pref+"cosTheta_L", nBinY, npoint ) ); 
        
	for(int i_cosLb=0;i_cosLb<nBinY;i_cosLb++){
	  double cosLb = -1.0 + (i_cosLb+0.5)*cos_wBinY;
	  double eff_cosLb=eff_cosL * mceff( mL, cosLb, pref+"cosTheta_Lb", nBinY, npoint );
	  
	  for(int i_cosJpsi=0;i_cosJpsi<nBinY;i_cosJpsi++){
	    double cosJpsi = -1.0 + (i_cosJpsi+0.5)*cos_wBinY;
	    double eff_cosJpsi=eff_cosLb * mceff( mL, cosJpsi, pref+"cosTheta_Jpsi", nBinY, npoint );
	    
	    for(int i_phiMu=0;i_phiMu<nBinY;i_phiMu++){
	      double phi_Mu = -TMath::Pi() + (i_phiMu+0.5)*phi_wBinY;
	      double eff_phiMu = eff_cosJpsi * mceff( mL, phi_Mu, pref+"phiMu", nBinY, npoint );
	      
	      for(int i_phiK=0;i_phiK<nBinY;i_phiK++){
		double phi_K = -TMath::Pi() + (i_phiK+0.5)*phi_wBinY;
		double eff_phiK = eff_phiMu * mceff( mL, phi_K, pref+"phiK", nBinY, npoint );
		
		phsum_mL += weight;
		phsum_cosL += weight * eff_cosL;
		phsum_cosLb += weight * eff_cosLb;
		phsum_cosJpsi += weight * eff_cosJpsi;
		phsum_phiMu += weight * eff_phiMu;
		phsum_phiK += weight * eff_phiK;
		
	      }
	    }
	  }
	}
      }
    }
    

    if( phsum_mL > 0.0 ){
      scale_cosL = phsum_cosL/phsum_mL;
      scale_cosLb = phsum_cosLb/phsum_mL;
      scale_cosJpsi = phsum_cosJpsi/phsum_mL;
      scale_phiMu = phsum_phiMu/phsum_mL;
      scale_phiK = phsum_phiK/phsum_mL;
    }

      
    for( int iX=0;iX<nBinX;iX++ ){
      for( int iY=0; iY<nBinY; iY++ ){          
	(*init_cosL)[iX*nBinY+iY] /= scale_cosL;
	(*init_cosLb)[iX*nBinY+iY] /= scale_cosLb/scale_cosL;
	(*init_cosJpsi)[iX*nBinY+iY] /= scale_cosJpsi/scale_cosLb;
	(*init_phiMu)[iX*nBinY+iY] /= scale_phiMu/scale_cosJpsi;
	(*init_phiK)[iX*nBinY+iY] /= scale_phiK/scale_phiMu;
      }
    }
    
    double avecosL, avecosLb, avecosJpsi, avephiMu, avephiK;

    avecosL = avecosLb = avecosJpsi = avephiMu = avephiK = 0;
    
    for(int it = 0; it<nBinX*nBinY; it++){
      avecosL+= (*init_cosL)[it]/(nBinX*nBinY);
      avecosLb+= (*init_cosLb)[it]/(nBinX*nBinY);
      avecosJpsi+= (*init_cosJpsi)[it]/(nBinX*nBinY);
      avephiMu+= (*init_phiMu)[it]/(nBinX*nBinY);
      avephiK+= (*init_phiK)[it]/(nBinX*nBinY);
    }
    
    std::cout<<"cos L average: "<<avecosL;
    std::cout<<"cos Lb average: "<<avecosLb;
    std::cout<<"cos Jpsi average: "<<avecosJpsi;
    std::cout<<"phi Mu average: "<<avephiMu;
    std::cout<<"phi K average: "<<avephiK<<std::endl;;

 /* 
  

  if(isBkgInit && SumBkg == 0.0 ){
    
    double sumW(0.0);
    
    TChain* Bsmcdata = new TChain("MyTuple");  
    
    Bsmcdata->Add(MCDATA);


    double BMCM_Kp, BMCcosTheta_Lb, BMCcosTheta_L, BMCcosTheta_Jpsi, BMCphiMu, BMCphiK;
    double BMCnsig_sw;


    Bsmcdata->SetBranchAddress("mkp", &BMCM_Kp);
    Bsmcdata->SetBranchAddress("cosTheta_Lb", &BMCcosTheta_Lb);
    Bsmcdata->SetBranchAddress("cosTheta_L", &BMCcosTheta_L);
    Bsmcdata->SetBranchAddress("cosTheta_Jpsi", &BMCcosTheta_Jpsi);
    Bsmcdata->SetBranchAddress("phiMu", &BMCphiMu);
    Bsmcdata->SetBranchAddress("phiK", &BMCphiK);
    Bsmcdata->SetBranchAddress("nsig_sw", &BMCnsig_sw);

    int Bsmcnum = Bsmcdata->GetEntries();
    for(int i=0;i<Bsmcnum;i++){
      Bsmcdata->GetEntry(i);
      double sweight = BMCnsig_sw;
      
      double sigeff_prod = mceff( BMCM_Kp, BMCcosTheta_L, "cosTheta_L", mc_nBinY, mc_npoint ) *
	mceff(  BMCM_Kp, BMCcosTheta_Lb, "cosTheta_Lb", mc_nBinY, mc_npoint )*
	mceff(  BMCM_Kp, BMCcosTheta_Jpsi, "cosTheta_Jpsi", mc_nBinY, mc_npoint )*
	mceff(  BMCM_Kp, BMCphiMu, "phiMu", mc_nBinY, mc_npoint )*
	mceff(  BMCM_Kp, BMCphiK, "phiK", mc_nBinY, mc_npoint ); 
   
      if( sigeff_prod ==0){
	SumBkg+= 0;
      } else{
	
	SumBkg +=  sweight * mceff( BMCM_Kp, BMCcosTheta_L, "BkgcosTheta_L", bkg_nBinY, bkg_npoint ) *
	  mceff(  BMCM_Kp, BMCcosTheta_Lb, "BkgcosTheta_Lb", bkg_nBinY, bkg_npoint )*
	  mceff(  BMCM_Kp, BMCcosTheta_Jpsi, "BkgcosTheta_Jpsi", bkg_nBinY, bkg_npoint )*
	  mceff(  BMCM_Kp, BMCphiMu, "BkgphiMu", bkg_nBinY, bkg_npoint )*
	  mceff(  BMCM_Kp, BMCphiK, "BkgphiK", bkg_nBinY, bkg_npoint )
	  / sigeff_prod ; 
      }
      
      sumW += sweight;
      
    }
	
    std::cout<<SumBkg<<" "<<sumW<<std::endl;

    SumBkg /= sumW;

    std::cout<<"SumBkg being set to: "<<SumBkg<<std::endl;
    delete Bsmcdata;
  }

*/
#endif
    std::cout<<"Exiting init"<<std::endl;

}
 
double RooDalitzAmplitude::mceff(double mL, double effVar, TString name, int nBinY) const
{

  double ymin;
  double wBinY;  
  double nBinX;
  double mKp_wBinX;

  if(name(0,3)=="cos"){
     ymin = -1;
     wBinY = mc_cos_wBinY; //all cos should be the same
     nBinX = mc_nBinX;
     mKp_wBinX = mc_wBinX;
  }else if(name(0,3)=="phi"){
     ymin = -TMath::Pi();
     wBinY = mc_phi_wBinY;
     nBinX = mc_nBinX;
     mKp_wBinX = mc_wBinX;
  }else if(name(0,6)=="Bkgcos"){
     ymin = -1;
     wBinY = bkg_cos_wBinY;    
     nBinX = bkg_nBinX;
     mKp_wBinX = bkg_wBinX;
  }else if(name(0,6)=="Bkgphi"){
     ymin = -TMath::Pi();
     wBinY = bkg_phi_wBinY;
     nBinX = bkg_nBinX;
     mKp_wBinX = bkg_wBinX;
  }else{
     std::cout<<"Efficiency called for unmatched variable"<<std::endl;
     abort();
  }


  int iBinX = ( mL - mKp_min )/mKp_wBinX;
  if( iBinX<0 )return 0.0;
  if( iBinX>= nBinX )return 0.0;

  double eff=0.0;

    int jBinY = ( effVar - ymin )/wBinY;
    if( jBinY< 0 ){ jBinY=0; }
    if( jBinY>= nBinY ){ jBinY=nBinY-1; }
    //streamline the below once things are working
    if(name == "cosTheta_Lb"){    eff = mceff_cosLb[iBinX*nBinY+jBinY];}
    else if(name == "cosTheta_L"){ eff = mceff_cosL[iBinX*nBinY+jBinY]  ;}
    else if(name == "cosTheta_Jpsi"){ eff = mceff_cosJpsi[iBinX*nBinY+jBinY]  ;}
    else if(name == "phiMu"){ eff = mceff_phiMu[iBinX*nBinY+jBinY]  ;}
    else if(name == "phiK"){ eff = mceff_phiK[iBinX*nBinY+jBinY];}
    else if(name == "BkgcosTheta_Lb"){    eff = bkgeff_cosLb[iBinX*nBinY+jBinY];}
    else if(name == "BkgcosTheta_L"){    eff = bkgeff_cosL[iBinX*nBinY+jBinY];}
    else if(name == "BkgcosTheta_Jpsi"){    eff = bkgeff_cosJpsi[iBinX*nBinY+jBinY];}
    else if(name == "BkgphiMu"){ eff = bkgeff_phiMu[iBinX*nBinY+jBinY]  ;}
    else if(name == "BkgphiK"){ eff = bkgeff_phiK[iBinX*nBinY+jBinY]  ;}
    else{
      std::cout<<"Efficiency called for unmatched variable"<<std::endl;
      abort();
    }


  if( eff<0.0 )eff=0.0;
  return eff;

}

 
double RooDalitzAmplitude::mceff(double mL, double effVar, TString name, int nBinY, int _npoint) const
{

  if( _npoint <2 )return mceff(mL,effVar,name,nBinY);


  double ymin;
  double wBinY;  
  double nBinX;
  double mKp_wBinX;
  if(name(0,3)=="cos"){
     ymin = -1;
     wBinY = mc_cos_wBinY; //all cos should be the same
     nBinX = mc_nBinX;
     mKp_wBinX = mc_wBinX;
  }else if(name(0,3)=="phi"){
     ymin = -TMath::Pi();
     wBinY = mc_phi_wBinY;
     nBinX = mc_nBinX;
     mKp_wBinX = mc_wBinX;
  }else if(name(0,6)=="Bkgcos"){
     ymin = -1;
     wBinY = bkg_cos_wBinY;    
     nBinX = bkg_nBinX;
     mKp_wBinX = bkg_wBinX;
  }else if(name(0,6)=="Bkgphi"){
     ymin = -TMath::Pi();
     wBinY = bkg_phi_wBinY;
     nBinX = bkg_nBinX;
     mKp_wBinX = bkg_wBinX;
  }else{
     std::cout<<"Efficiency called for unmatched variable"<<std::endl;
     abort();
  }

  double eff=0.0;


  if( _npoint==2 ){  // bi-linear

    double p_eff[2][2];

    int iBinX = ( mL - mKp_min )/mKp_wBinX-0.5;
    if( iBinX<0 )iBinX = 0;
    if( iBinX>=(nBinX-1) )iBinX =  nBinX-2;
    double x = (mL - (mKp_min + (iBinX+0.5)*mKp_wBinX))/mKp_wBinX;
    if(x<0.0)x=0.0;
    if(x>1.0)x=1.0;


    int jBinY = ( effVar - ymin )/wBinY-0.5;
    if( jBinY< 0 ){ jBinY=0; }
    if( jBinY>= (nBinY-1) ){ jBinY=nBinY-2; }
    double y = (effVar - (ymin + (jBinY+0.5)*wBinY))/wBinY;
    if(y<0.0)y=0.0;
    if(y>1.0)y=1.0;

    for( int itx=0; itx<2; itx++ ){
      int ix = iBinX +itx;
      if( ix<0 )ix=0;
      if( ix>=nBinX )ix=nBinX-1;

      for( int ity=0; ity<2; ity++ ){
	int jy = jBinY +ity;
	if( jy<0 )jy=0;
	if( jy>=nBinY )jy=nBinY-1;


	//streamline the below once things are working
	if(name == "cosTheta_Lb"){    p_eff[itx][ity] = mceff_cosLb[ix*nBinY+jy];}
	else if(name == "cosTheta_L"){ p_eff[itx][ity] = mceff_cosL[ix*nBinY+jy];}
	else if(name == "cosTheta_Jpsi"){ p_eff[itx][ity] = mceff_cosJpsi[ix*nBinY+jy];}
	else if(name == "phiMu"){ p_eff[itx][ity] = mceff_phiMu[ix*nBinY+jy];}
	else if(name == "phiK"){  p_eff[itx][ity] = mceff_phiK[ix*nBinY+jy];}
	else if(name == "BkgcosTheta_Lb"){ p_eff[itx][ity] = bkgeff_cosLb[ix*nBinY+jy];}
	else if(name == "BkgcosTheta_L"){ p_eff[itx][ity] = bkgeff_cosL[ix*nBinY+jy];}
	else if(name == "BkgcosTheta_Jpsi"){ p_eff[itx][ity] = bkgeff_cosJpsi[ix*nBinY+jy];}
	else if(name == "BkgphiMu"){ p_eff[itx][ity] = bkgeff_phiMu[ix*nBinY+jy];}
	else if(name == "BkgphiK"){  p_eff[itx][ity] = bkgeff_phiK[ix*nBinY+jy];}
	else{
	  std::cout<<"Efficiency called for unmatched variable"<<std::endl;
	  abort();
	}
      }
    }
    eff = bilinearInterpolate( p_eff, x,y );
      
  } else { // bi-cubic
 
    double p_eff[4][4];

    int iBinX = ( mL - mKp_min )/mKp_wBinX-0.5;
    if( iBinX<0 )iBinX = 0;
    if( iBinX>=(nBinX-1) )iBinX =  nBinX-2;
    double x = (mL - (mKp_min + (iBinX+0.5)*mKp_wBinX))/mKp_wBinX;
    if(x<0.0)x=0.0;
    if(x>1.0)x=1.0;


    int jBinY = ( effVar - ymin )/wBinY-0.5;
    if( jBinY< 0 ){ jBinY=0; }
    if( jBinY>= (nBinY-1) ){ jBinY=nBinY-2; }
    double y = (effVar - (ymin + (jBinY+0.5)*wBinY))/wBinY;
    if(y<0.0)y=0.0;
    if(y>1.0)y=1.0;


    for( int itx=0; itx<4; itx++ ){
      int ix = iBinX +itx -1;
      if( ix<0 )ix=0;
      if( ix>=nBinX )ix=nBinX-1;

      for( int ity=0; ity<4; ity++ ){
	int jy = jBinY+ity -1;
	if( jy<0 )jy=0;
	if( jy>=nBinY )jy=nBinY-1;

	//streamline the below once things are working 
	if(name == "cosTheta_Lb"){    p_eff[itx][ity] = mceff_cosLb[ix*nBinY+jy];}
	else if(name == "cosTheta_L"){ p_eff[itx][ity] = mceff_cosL[ix*nBinY+jy];}
	else if(name == "cosTheta_Jpsi"){ p_eff[itx][ity] = mceff_cosJpsi[ix*nBinY+jy];}
	else if(name == "phiMu"){ p_eff[itx][ity] = mceff_phiMu[ix*nBinY+jy];}
	else if(name == "phiK"){  p_eff[itx][ity] = mceff_phiK[ix*nBinY+jy];}
	else if(name == "BkgcosTheta_Lb"){ p_eff[itx][ity] = bkgeff_cosLb[ix*nBinY+jy];}
	else if(name == "BkgcosTheta_L"){ p_eff[itx][ity] = bkgeff_cosL[ix*nBinY+jy];}
	else if(name == "BkgcosTheta_Jpsi"){ p_eff[itx][ity] = bkgeff_cosJpsi[ix*nBinY+jy];}
	else if(name == "BkgphiMu"){ p_eff[itx][ity] = bkgeff_phiMu[ix*nBinY+jy];}
	else if(name == "BkgphiK"){  p_eff[itx][ity] = bkgeff_phiK[ix*nBinY+jy];}
	else{
	  std::cout<<"Efficiency called for unmatched variable"<<std::endl;
	  abort();
	}
      }
    }
    eff = bicubicInterpolate( p_eff, x,y );

  }


  if( eff<0.0 )eff=0.0;
  return eff;
}


CEvent RooDalitzAmplitude::GenEvent(){


  CEvent reEvent;

  Double_t m0_Mu = 0.105658;
  Double_t m0_L_min = m_k+m_p;
  Double_t m0_L_max = m_lb-m_jpsi;
  

  TLorentzVector p4_Lb_Lb, p4_L_Lb, p4_Jpsi_Lb;
  TLorentzVector p4_L_L, p4_K_L, p4_p_L;
  TLorentzVector p4_Jpsi_Jpsi, p4_MuCalc_Jpsi, p4_MuOther_Jpsi, p4_Z_Lb;

  double cosTh_Lb = -1+2*m_random.Rndm();
  double cosTh_L = -1+2*m_random.Rndm();
  double cosTh_Jpsi = -1+2*m_random.Rndm();     
  double phi_Mu = -TMath::Pi()+2*TMath::Pi()*m_random.Rndm();
  double phi_K = -TMath::Pi()+2*TMath::Pi()*m_random.Rndm();
  double diff =  m0_L_max-m0_L_min;
  double M_Kp = m0_L_min + diff*m_random.Rndm();

  double q = 0.5*sqrt( pow(M_Kp*M_Kp - m_k*m_k - m_p*m_p,2) - 4*pow(m_p*m_k,2))/M_Kp;
  double p = 0.5*sqrt( (pow(m_lb*m_lb - m_jpsi*m_jpsi - M_Kp*M_Kp,2) - 4*pow(M_Kp*m_jpsi,2)))/m_lb;
  
  double phsp = q*p;
  
  //Lb rest frame
  double Th_Lb = acos( cosTh_Lb);
  p4_Lb_Lb.SetPxPyPzE(0,0, 0,  m_lb);
  p4_L_Lb.SetPxPyPzE(p*sin(Th_Lb),0, p*cos( Th_Lb), sqrt((M_Kp*M_Kp + p*p)) );
  p4_Jpsi_Lb.SetPxPyPzE(-p*sin(Th_Lb),0,-p*cos(Th_Lb), sqrt((m_jpsi*m_jpsi + p*p)) );
  
  //L rest frame
  double Th_L = acos( cosTh_L);
  p4_L_L.SetPxPyPzE( 0,0,0,M_Kp);
  p4_K_L.SetPxPyPzE( q*sin( Th_L)*cos(phi_K), q*sin( Th_L)*sin(phi_K), q*cos( Th_L), sqrt((m_k*m_k + q*q)) );
  p4_p_L.SetPxPyPzE( -q*sin( Th_L)*cos(phi_K), -q*sin( Th_L)*sin(phi_K), -q*cos( Th_L), sqrt((m_p*m_p + q*q)) );
  
  TLorentzVector temp_p4_L_Lb = p4_L_Lb;
  temp_p4_L_Lb.RotateY( -Th_Lb);
  TVector3 boostToL = temp_p4_L_Lb.BoostVector();
  p4_K_L.Boost( boostToL );
  p4_p_L.Boost( boostToL );
  
  

  p4_K_L.RotateY(Th_Lb);
  p4_p_L.RotateY(Th_Lb);
  
  //Jpsi rest frame
  double q_Jpsi = 0.5*sqrt( pow(m_jpsi*m_jpsi - 2*m0_Mu*m0_Mu,2) - 4*pow(m0_Mu*m0_Mu,2))/m_jpsi;
  double Th_Jpsi = acos( cosTh_Jpsi);
  p4_Jpsi_Jpsi.SetPxPyPzE( 0,0,0,m_jpsi);
  p4_MuCalc_Jpsi.SetPxPyPzE( q_Jpsi*sin( Th_Jpsi)*cos(phi_Mu), q_Jpsi*sin( Th_Jpsi)*sin(phi_Mu), q_Jpsi*cos( Th_Jpsi), sqrt((m0_Mu*m0_Mu + q_Jpsi*q_Jpsi
																		   )) );
    p4_MuOther_Jpsi.SetPxPyPzE( -q_Jpsi*sin( Th_Jpsi)*cos(phi_Mu), -q_Jpsi*sin( Th_Jpsi)*sin(phi_Mu), -q_Jpsi*cos( Th_Jpsi), sqrt((m0_Mu*m0_Mu + q_Jpsi*q_Jpsi)) );

    //get right jpsi boost
    TLorentzVector temp_p4_Jpsi_Lb = p4_Jpsi_Lb;
    temp_p4_Jpsi_Lb.RotateY( -Th_Lb - TMath::Pi());
    TVector3 boostToJpsi = temp_p4_Jpsi_Lb.BoostVector();


    p4_MuCalc_Jpsi.SetPx( -p4_MuCalc_Jpsi.Px() );
    p4_MuOther_Jpsi.SetPx( -p4_MuOther_Jpsi.Px() );            
    p4_MuCalc_Jpsi.SetPy( -p4_MuCalc_Jpsi.Py() );
    p4_MuOther_Jpsi.SetPy( -p4_MuOther_Jpsi.Py() );
    

    p4_MuCalc_Jpsi.Boost( boostToJpsi );
    p4_MuOther_Jpsi.Boost( boostToJpsi );

  
    p4_MuCalc_Jpsi.RotateY(Th_Lb + TMath::Pi());
    p4_MuOther_Jpsi.RotateY(Th_Lb + TMath::Pi());
    
    TLorentzVector testJpsi = p4_MuCalc_Jpsi+p4_MuOther_Jpsi;


    p4_Z_Lb = p4_Jpsi_Lb+p4_p_L;


    TLorentzVector dummy_p4_Lb_LAB;
    dummy_p4_Lb_LAB.SetPxPyPzE(0,0,m_lb*10.0, sqrt(101.)*m_lb*m_lb);
    TVector3 dumbBoost = dummy_p4_Lb_LAB.BoostVector();
    p4_MuCalc_Jpsi.Boost( dumbBoost);
    p4_Jpsi_Lb.Boost( dumbBoost);
    p4_K_L.Boost( dumbBoost);
    p4_p_L.Boost( dumbBoost);
    p4_L_Lb.Boost( dumbBoost);
    p4_Z_Lb.Boost( dumbBoost);
    p4_Lb_Lb.Boost( dumbBoost);



    m_anglecal.CalcAll(p4_MuCalc_Jpsi, p4_Jpsi_Lb, p4_K_L, p4_p_L, p4_L_Lb, p4_Z_Lb, p4_Lb_Lb);


    double M_Jpsip =p4_Z_Lb.M();
    TLorentzVector p4_JpsiK =  p4_Jpsi_Lb+p4_K_L;
    double M_JpsiK = p4_JpsiK.M();


    reEvent.mkp = M_Kp;
    reEvent.mjpsip= M_Jpsip;
    reEvent.mjpsik= M_JpsiK;
    reEvent.cosTh_Lb= cosTh_Lb;
    reEvent.cosTh_L= cosTh_L;
    reEvent.cosTh_Jpsi= cosTh_Jpsi;
    reEvent.phi_Mu=  phi_Mu;
    reEvent.phi_K= phi_K;

    std::cout << "begin " << std::endl;
    std::cout << "cosTh_Lb " << cosTh_Lb << " " << m_anglecal.cosTheta_Lb << std::endl;
    std::cout << "cosTh_L " << cosTh_L << " " << m_anglecal.cosTheta_L << std::endl;    
    std::cout << "cosTh_Jpsi " << cosTh_Jpsi << " " << m_anglecal.cosTheta_Jpsi << std::endl;    
    std::cout << "phi_Mu " << phi_Mu << " " << m_anglecal.phiMu << std::endl;    
    std::cout << "phi_K " << phi_K << " " << m_anglecal.phiK << std::endl;    

    reEvent.Z_cosTh_Lb= m_anglecal.Z_cosTheta_Lb ;
    reEvent.Z_cosTh_Z= m_anglecal.Z_cosTheta_Z;
    reEvent.Z_cosTh_Jpsi= m_anglecal.Z_cosTheta_Jpsi;
    reEvent.Z_phi_Z = m_anglecal.Z_phiZ;
    reEvent.Z_phi_Jpsi = m_anglecal.Z_phiJpsi;
    reEvent.Z_phi_Mu = m_anglecal.Z_phiMu;
    reEvent.cosTh_p = m_anglecal.cosTheta_p;
    reEvent.alphaMu = m_anglecal.alpha_Mu;
    reEvent.phsp = phsp;
    return reEvent;
}

void RooDalitzAmplitude::CreateToyDataSet(int numEvents, int dType, double maxWeight, TString fname)
{

  //[mass,mkp,mjpsip,mjpsik,cosTheta_L,cosTheta_Jpsi,cosTheta_Lb,Z_cosTheta_Lb,Z_cosTheta_Z,Z_cosTheta_Jpsi,cosTheta_p,phiK,phiMu,Z_phiZ,Z_phiJpsi,Z_phiMu,alpha_Mu,ID,nsig_sw,L_nsig,nbkg_sw,L_nbkg] = 58260 entries

#if 0
  RooRealVar mkp("mkp","mkp",1.4,2.6,"GeV") ; 
  RooRealVar mjpsip("mjpsip","mjpsip",0,10000) ; 
  RooRealVar mjpsik("mjpsik","mjpsik",0,10000) ; 
  RooRealVar cosTheta_Lb("cosTheta_Lb","cosTheta_Lb",-1,1) ; 
  RooRealVar cosTheta_L("cosTheta_L","cosTheta_L",-1,1);
  RooRealVar cosTheta_Jpsi("cosTheta_Jpsi","cosTheta_Jpsi",-1,1);
  RooRealVar phiK("phiK","phiK",-TMath::Pi(), TMath::Pi());
  RooRealVar phiMu("phiMu","phiMu",-TMath::Pi(), TMath::Pi());  
  RooRealVar Z_cosTheta_Lb("Z_cosTheta_Lb","Z_cosTheta_Lb",-1,1);
  RooRealVar Z_cosTheta_Z("Z_cosTheta_Z","Z_cosTheta_Z",-1,1);
  RooRealVar Z_cosTheta_Jpsi("Z_cosTheta_Jpsi","Z_cosTheta_Jpsi",-1,1);
  RooRealVar Z_phiZ("Z_phiZ","Z_phiZ",-TMath::Pi(), TMath::Pi());  
  RooRealVar Z_phiJpsi("Z_phiJpsi","Z_phiJpsi",-TMath::Pi(), TMath::Pi());  
  RooRealVar Z_phiMu("Z_phiMu","Z_phiMu",-TMath::Pi(), TMath::Pi());  
  RooRealVar cosTheta_p("cosTheta_p","cosTheta_p",-1,1);  
  RooRealVar alpha_Mu("alpha_Mu","alpha_Mu",-TMath::Pi(), TMath::Pi());  


  RooRealVar Theta_Lb("Theta_Lb","Theta_Lb",-TMath::Pi(),TMath::Pi()) ; 
  RooRealVar Theta_L("Theta_L","Theta_L",-TMath::Pi(),TMath::Pi());
  RooRealVar Theta_Jpsi("Theta_Jpsi","Theta_Jpsi",-TMath::Pi(),TMath::Pi());
  RooRealVar Z_Theta_Lb("Z_Theta_Lb","Z_Theta_Lb",-TMath::Pi(), TMath::Pi());
  RooRealVar Z_Theta_Z("Z_Theta_Z","Z_Theta_Z",-TMath::Pi(), TMath::Pi());
  RooRealVar Z_Theta_Jpsi("Z_Theta_Jpsi","Z_Theta_Jpsi",-TMath::Pi(), TMath::Pi());
  RooRealVar Theta_p("Theta_p","Theta_p",-TMath::Pi(), TMath::Pi());  
  RooRealVar nsig_sw("nsig_sw","nsig_sw",0);
  RooRealVar EN("EN","EN",0, 100000);  

  RooArgSet *var_set = new RooArgSet(mkp, mjpsip);
  var_set->add(cosTheta_L);
  var_set->add(cosTheta_Jpsi);
  var_set->add(cosTheta_Lb);
  var_set->add(phiK);
  var_set->add(phiMu);
  var_set->add(Z_cosTheta_Lb);
  var_set->add(Z_cosTheta_Z);
  var_set->add(Z_cosTheta_Jpsi);
  var_set->add(Z_phiZ);
  var_set->add(Z_phiJpsi);
  var_set->add(Z_phiMu);
  var_set->add(cosTheta_p);
  var_set->add(alpha_Mu);

  var_set->add(Theta_L);
  var_set->add(Theta_Jpsi);
  var_set->add(Theta_Lb);
  var_set->add(Z_Theta_Lb);
  var_set->add(Z_Theta_Z);
  var_set->add(Z_Theta_Jpsi);
  var_set->add(Theta_p);
  var_set->add(EN);
  var_set->add(nsig_sw);


  RooDataSet*  Gen_set=new RooDataSet("MC_set","MC_set",*var_set,nsig_sw.GetName());
  Gen_set->Print();
#endif

  //  TString fname = "ToySet_"+TString::Format("%i",toyNum)+".root";
   TFile F(fname, "recreate");
   TTree* myT = new TTree("MyTuple", "MyTuple");

   
   double M_Kp, M_Jpsip, M_JpsiK, nsw, cosTh_Lb, cosTh_L, cosTh_Jpsi, phi_Mu, phi_K;
   double Z_cosTh_Lb, Z_cosTh_Z, Z_cosTh_Jpsi, Z_phi_Jpsi, Z_phi_Z, Z_phi_Mu;
   double cosTh_p, alphaMu; 
   double Th_Lb, Th_L, Th_Jpsi, Z_Th_Lb, Z_Th_Z, Z_Th_Jpsi, Th_p, EN;
   double w_phsp=1; double w_eff = 1; double w_amp = 1;
   myT -> Branch("mkp", &M_Kp, "mkp/D");
   myT -> Branch("mjpsip", &M_Jpsip, "mjpsip/D");
   myT -> Branch("mjpsik", &M_JpsiK, "mjpsik/D");
   myT -> Branch("nsig_sw", &nsw, "nsig_sw/D");
   myT -> Branch("w_amp", &w_amp, "w_amp/D");
   myT -> Branch("w_eff", &w_eff, "w_eff/D");
   myT -> Branch("w_phsp", &w_phsp, "w_phsp/D");
   myT -> Branch("cosTheta_Lb", &cosTh_Lb, "cosTheta_Lb/D");
   myT -> Branch("cosTheta_L", &cosTh_L, "cosTheta_L/D");
   myT -> Branch("cosTheta_Jpsi", &cosTh_Jpsi, "cosTheta_Jpsi/D");
   myT -> Branch("phiMu", &phi_Mu, "phiMu/D");
   myT -> Branch("phiK", &phi_K, "phiK/D");
   myT -> Branch("Z_cosTheta_Lb", &Z_cosTh_Lb, "Z_cosTheta_Lb/D");
   myT -> Branch("Z_cosTheta_Z", &Z_cosTh_Z, "Z_cosTheta_Z/D");
   myT -> Branch("Z_cosTheta_Jpsi", &Z_cosTh_Jpsi, "Z_cosTheta_Jpsi/D");
   myT -> Branch("Z_phiJpsi", &Z_phi_Jpsi, "Z_phiJpsi/D");
   myT -> Branch("Z_phiZ", &Z_phi_Z, "Z_phiZ/D");
   myT -> Branch("Z_phiMu", &Z_phi_Mu, "Z_phiMu/D");
   myT -> Branch("cosTheta_p", &cosTh_p, "cosTheta_p/D");
   myT -> Branch("alpha_Mu", &alphaMu, "alpha_Mu/D");

   myT -> Branch("EN", &EN, "EN/D");


  CalCoupling();
  double totalEvents = 0;
  while(totalEvents<numEvents){
    CEvent i_event = GenEvent();

    M_Kp = i_event.mkp;
    M_Jpsip = i_event.mjpsip;
    M_JpsiK = i_event.mjpsik;
    cosTh_Lb = i_event.cosTh_Lb;
    cosTh_L = i_event.cosTh_L;
    cosTh_Jpsi = i_event.cosTh_Jpsi;
    phi_K = i_event.phi_K;
    phi_Mu = i_event.phi_Mu;
    Z_cosTh_Lb = i_event.Z_cosTh_Lb;
    Z_cosTh_Z = i_event.Z_cosTh_Z;
    Z_cosTh_Jpsi = i_event.Z_cosTh_Jpsi;
    Z_phi_Z = i_event.Z_phi_Z;
    Z_phi_Jpsi = i_event.Z_phi_Jpsi;
    Z_phi_Mu = i_event.Z_phi_Mu;
    cosTh_p = i_event.cosTh_p;
    alphaMu = i_event.alphaMu;

    double isAnti = m_random.Rndm();
    if(isAnti<0.5){
      alphaMu*=-1;
      Z_phi_Z*=-1;
      Z_phi_Jpsi*=-1;
      Z_phi_Mu*=-1;
      phi_K*=-1;
      phi_Mu*=-1;
    }
    
    nsw = 1.;//
    w_phsp = i_event.phsp;
    double i_weight = i_event.phsp;
//    CalCoupling();
      
     //what to give
    if(dType==0){
      //"real" data
      Jpsihh_dlz xdlz;// = new Jpsihh_dlz();
       filldlz(xdlz, M_Kp, cosTh_Lb, cosTh_L, cosTh_Jpsi, phi_K, phi_Mu,
	    Z_cosTh_Lb,Z_cosTh_Z,Z_cosTh_Jpsi,Z_phi_Z,Z_phi_Jpsi,Z_phi_Mu,cosTh_p,alphaMu,
	    M_Jpsip, i_weight);      
      w_amp= GetAmp2s(xdlz, 1); 

      i_weight*=w_amp;

      w_eff=mceff( M_Kp, cosTh_L, "cosTheta_L", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, cosTh_Lb, "cosTheta_Lb", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, cosTh_Jpsi, "cosTheta_Jpsi", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, phi_Mu, "phiMu", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, phi_K, "phiK", mc_nBinY, mc_npoint );
      i_weight*=w_eff;
    }else if(dType==1){
      //MC data
      w_eff=mceff( M_Kp, cosTh_L, "cosTheta_L", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, cosTh_Lb, "cosTheta_Lb", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, cosTh_Jpsi, "cosTheta_Jpsi", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, phi_Mu, "phiMu", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, phi_K, "phiK", mc_nBinY, mc_npoint );
      i_weight*=w_eff;
    }else if(dType==10){
      //MC data 
      w_eff=mceff( M_Kp, cosTh_L, "cosTheta_L", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, cosTh_Lb, "cosTheta_Lb", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, cosTh_Jpsi, "cosTheta_Jpsi", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, phi_Mu, "phiMu", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, phi_K, "phiK", mc_nBinY, mc_npoint );
      i_weight*=w_eff/w_phsp;
      nsw = w_phsp;
      if(M_Kp>2.0)  {
        i_weight = i_weight/3.;
        nsw *= 3.;
      }
    } else{//is bkg
	w_eff=mceff( M_Kp, cosTh_L, "BkgcosTheta_L", bkg_nBinY, bkg_npoint ) *
	  mceff( M_Kp, cosTh_Lb, "BkgcosTheta_Lb", bkg_nBinY, bkg_npoint ) *
	  mceff( M_Kp, cosTh_Jpsi, "BkgcosTheta_Jpsi", bkg_nBinY, bkg_npoint ) *
	  mceff( M_Kp, phi_Mu, "BkgphiMu", bkg_nBinY, bkg_npoint ) *
	  mceff( M_Kp, phi_K, "BkgphiK", bkg_nBinY, bkg_npoint );
	i_weight*=w_eff;
    }

    //double ranNum = m_random.Uniform(0,1);
    double ranNum = m_random.Rndm();
    if(ranNum< i_weight/maxWeight){
      //totalEvents+=1;
      if(TMath::Nint(totalEvents)%5000==0)std::cout<<totalEvents<<" accepted so far"<<std::endl;

#if 0
      mkp.setVal( M_Kp);  mjpsip.setVal( M_Kp);  mjpsik.setVal( M_JpsiK);
      cosTheta_Lb.setVal( cosTh_Lb);  cosTheta_L.setVal( cosTh_L);  cosTheta_Jpsi.setVal( cosTh_Jpsi);
      phiMu.setVal( phi_Mu);  phiK.setVal( phi_K);

      Z_cosTheta_Lb.setVal( Z_cosTh_Lb );  Z_cosTheta_Z.setVal( Z_cosTh_Z);  Z_cosTheta_Jpsi.setVal( Z_cosTh_Jpsi);
      Z_phiZ.setVal( Z_phi_Z);  Z_phiJpsi.setVal(Z_phi_Jpsi);  Z_phiMu.setVal( Z_phi_Mu);
      cosTheta_p.setVal( cosTh_p);  alpha_Mu.setVal( alphaMu);
    
      Theta_Lb.setVal( acos(cosTh_Lb) ); Theta_L.setVal( acos(cosTh_L) ); Theta_Jpsi.setVal( acos(cosTh_Jpsi) );
      Z_Theta_Lb.setVal( acos(Z_cosTh_Lb) ); Z_Theta_Z.setVal( acos(Z_cosTh_Z)  ); Z_Theta_Jpsi.setVal( acos(Z_cosTh_Jpsi)  );
      Theta_p.setVal( acos(cosTh_p)  );
      EN.setVal(totalEvents );
      Gen_set->add(*var_set);//can add weight      
#endif

      totalEvents+=1;

      EN = totalEvents;
//      nsw=1;//i_weight;
      myT->Fill();
    }

  }//end while loop

  F.Write();
  F.Close();

#if 0
  Gen_set->Print();
  //delete myT;
  return Gen_set;
#endif
}

double RooDalitzAmplitude::GetMaxWeight(int dType)
{


   double M_Kp, M_Jpsip, M_JpsiK, nsw, cosTh_Lb, cosTh_L, cosTh_Jpsi, phi_Mu, phi_K;
   double Z_cosTh_Lb, Z_cosTh_Z, Z_cosTh_Jpsi, Z_phi_Jpsi, Z_phi_Z, Z_phi_Mu;
   double cosTh_p, alphaMu; 


  double curMax = 0; double i_i=0;
  double w_amp, w_eff;
  CalCoupling();
  for(int i = 0; i<10000000; i++){
    CEvent i_event = GenEvent();


    M_Kp = i_event.mkp;
    M_Jpsip = i_event.mjpsip;
    M_JpsiK = i_event.mjpsik;
    cosTh_Lb = i_event.cosTh_Lb;
    cosTh_L = i_event.cosTh_L;
    cosTh_Jpsi = i_event.cosTh_Jpsi;
    phi_K = i_event.phi_K;
    phi_Mu = i_event.phi_Mu;
    Z_cosTh_Lb = i_event.Z_cosTh_Lb;
    Z_cosTh_Z = i_event.Z_cosTh_Z;
    Z_cosTh_Jpsi = i_event.Z_cosTh_Jpsi;
    Z_phi_Z = i_event.Z_phi_Z;
    Z_phi_Jpsi = i_event.Z_phi_Jpsi;
    Z_phi_Mu = i_event.Z_phi_Mu;
    cosTh_p = i_event.cosTh_p;
    alphaMu = i_event.alphaMu;


    double isAnti = m_random.Rndm();
    if(isAnti<0.5){
      alphaMu*=-1;
      Z_phi_Z*=-1;
      Z_phi_Jpsi*=-1;
      Z_phi_Mu*=-1;
      phi_K*=-1;
      phi_Mu*=-1;
    }


    double i_weight = i_event.phsp;
    if(dType==0){
      //"real" data

      Jpsihh_dlz xdlz;// = new Jpsihh_dlz();
       filldlz(xdlz, M_Kp, cosTh_Lb, cosTh_L, cosTh_Jpsi, phi_K, phi_Mu,
	    Z_cosTh_Lb,Z_cosTh_Z,Z_cosTh_Jpsi,Z_phi_Z,Z_phi_Jpsi,Z_phi_Mu,cosTh_p,alphaMu,
	    M_Jpsip, i_weight);      
      w_amp= GetAmp2s(xdlz, 1); 

      i_weight*=w_amp;

      w_eff=mceff( M_Kp, cosTh_L, "cosTheta_L", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, cosTh_Lb, "cosTheta_Lb", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, cosTh_Jpsi, "cosTheta_Jpsi", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, phi_Mu, "phiMu", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, phi_K, "phiK", mc_nBinY, mc_npoint );
      i_weight*=w_eff;
    }else if(dType==1){
      //MC data
      w_eff=mceff( M_Kp, cosTh_L, "cosTheta_L", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, cosTh_Lb, "cosTheta_Lb", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, cosTh_Jpsi, "cosTheta_Jpsi", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, phi_Mu, "phiMu", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, phi_K, "phiK", mc_nBinY, mc_npoint );
      i_weight*=w_eff;
    }else if(dType==10){
      //MC data 
      w_eff=mceff( M_Kp, cosTh_L, "cosTheta_L", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, cosTh_Lb, "cosTheta_Lb", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, cosTh_Jpsi, "cosTheta_Jpsi", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, phi_Mu, "phiMu", mc_nBinY, mc_npoint ) *
	mceff( M_Kp, phi_K, "phiK", mc_nBinY, mc_npoint );
      i_weight*=w_eff/i_event.phsp;
      if(M_Kp>2.0)  {
        i_weight = i_weight/3.;
      }
    }   else{//is bkg
	w_eff=mceff( M_Kp, cosTh_L, "BkgcosTheta_L", bkg_nBinY, bkg_npoint ) *
	  mceff( M_Kp, cosTh_Lb, "BkgcosTheta_Lb", bkg_nBinY, bkg_npoint ) *
	  mceff( M_Kp, cosTh_Jpsi, "BkgcosTheta_Jpsi", bkg_nBinY, bkg_npoint ) *
	  mceff( M_Kp, phi_Mu, "BkgphiMu", bkg_nBinY, bkg_npoint ) *
	  mceff( M_Kp, phi_K, "BkgphiK", bkg_nBinY, bkg_npoint );
	i_weight*=w_eff;
    }

    if(i_weight>curMax){
      curMax=i_weight;
      i_i=i;
    }
  }

  std::cout<<curMax<<", was found at: "<<i_i<<std::endl;
  return curMax;
}

double RooDalitzAmplitude::GetEff(double M_Kp, double cosTh_Lb, double cosTh_L, double cosTh_Jpsi, double phi_Mu, double phi_K)
{
      return mceff( M_Kp, cosTh_L, "cosTheta_L", mc_nBinY, mc_npoint ) *
      mceff( M_Kp, cosTh_Lb, "cosTheta_Lb", mc_nBinY, mc_npoint ) *
        mceff( M_Kp, cosTh_Jpsi, "cosTheta_Jpsi", mc_nBinY, mc_npoint ) *
        mceff( M_Kp, phi_Mu, "phiMu", mc_nBinY, mc_npoint ) *
        mceff( M_Kp, phi_K, "phiK", mc_nBinY, mc_npoint );      
}
