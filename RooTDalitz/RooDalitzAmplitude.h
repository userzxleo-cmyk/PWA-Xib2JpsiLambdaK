/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

#ifndef ROODALITZAMPLITUDE
#define ROODALITZAMPLITUDE
#include "RooAbsCategory.h"
#include "RooAbsPdf.h"
#include "RooAbsReal.h"
#include "RooCategoryProxy.h"
#include "RooDataSet.h"
#include "RooListProxy.h"
#include "RooRealProxy.h"
#include "RooTDalitz/EvtCGCoefSingle.hh"
#include "RooTDalitz/NDefine.h"
#include "TChain.h"
#include "TComplex.h"
#include "TList.h"
#include "TSpline.h"
#include "TString.h"
#include "cnumTools.h"
#include <memory>
#ifdef GPU
#include "RooTDalitz/MultDevice.h"
#include "RooTDalitz/cu_Jpsihh_dlz.h"
#include "RooTDalitz/kernel_calEva.h"
#endif
/* define data struct for an event, including varibles used for PWA calcuations,
and these intermediate varaibles are not changed
*/

struct Jpsihh_dlz {
    float mpk;
    float mjpsip;
    float mjpsik;
    float w;
    Float_t ARe[2][2][6];
    Float_t AIm[2][2][6];
    Float_t DL[5][2][6]; // For dfunc of L*(JL_lL,lp)J=1/2...9/2;

    Float_t AZRe[2][2][12];
    Float_t AZIm[2][2][12];
    Float_t DZ[4][2][12];

    Float_t AXRe[2][2][12];
    Float_t AXIm[2][2][12];
    Float_t DX[4][2][12];
};

struct Amp_dlz {
    Float_t w;
    // bool defedZ[1];
    Float_t ARe[Constant::number_of_Lz][2][2][2][6];
    Float_t AIm[Constant::number_of_Lz][2][2][2][6];
    Float_t AZRe[Constant::number_of_Pc][2][2][2][12];
    Float_t AZIm[Constant::number_of_Pc][2][2][2][12];
};

class RooDalitzAmplitude : public RooAbsPdf {
  public:
    RooDalitzAmplitude()
        : CG1(1, 2), CG3(3, 2), CG5(5, 2), CG7(7, 2), CG9(9, 2), CG21(2, 1), CG41(4, 1), CG03(0, 3),
          CG23(2, 3), CG43(4, 3), CG63(6, 3), CG02(0, 2), CG22(2, 2), CG42(4, 2) {};
    // CG21(2,1)CG41(4,1),  CG03(0,3),  CG23(2,3),  CG43(4,3),  CG63(6,3),  CG02(0,2), CG22(2,2),
    // CG42(4,2), _widthUpperLimit(1000.), _widthLowerLimit(0.5), _CalFWHM_nbin(500),
    // _CalFWHM_range(2.5){} ;

    RooDalitzAmplitude(const char *name,
                       const char *title,
                       RooArgList &values,
                       TList *resList,
                       TList *resListZ,
                       TList *resListX,
                       RooArgList *ratioList,
                       RooAbsReal &FFR_var,
                       RooAbsReal &FFB_var,
                       const TString mcdata,
                       RooDataSet &data,
                       RooAbsReal &widthUpperLimit_var,
                       RooAbsReal &widthLowerLimit_var,
                       RooAbsReal &CalFWHM_nbin_var,
                       RooAbsReal &CalFWHM_range_var,
                       bool fortoystudy = false);
    RooDalitzAmplitude(const RooDalitzAmplitude &other, const char *name = 0);
    virtual TObject *clone(const char *newname) const {
        return new RooDalitzAmplitude(*this, newname);
    }
    virtual ~RooDalitzAmplitude() {
        std::cout << "begin destruction " << std::endl;
        if (PDLZ) {
            std::cout << "begin PDLZ 1 " << std::endl;
            std::vector<Jpsihh_dlz *>::iterator it;
            for (it = PDLZ->begin(); it != PDLZ->end(); ++it) {
                delete *it;
                // PDLZ->erase(it);
            }
            //      delete &PDLZ;
            PDLZ->clear();
            std::cout << "cleared PDLZ " << std::endl;
        }
        //    delete _resList;
        //    delete _resListZ;
        _fx.resize(0);
        _sw.resize(0);
        _paraList.resize(0);
        _vamp.resize(0);
        _paraSpline.resize(0);
        // free(_resParCache);
        std::cout << "step 3 " << std::endl;
        //    std::cout << "capacity " << PDLZ.capacity() << " " << pdlz.capacity() << std::endl;
        //    PDLZ.resize(0);
        //    pdlz.resize(0);
        //    delete[] _resParCache;
#ifdef GPU
        cu_Free_pp(d_float_pp, d_float_pp1, d_float_pp2, d_float_pp3, d_float_pp4);
        d_float_pp.resize(0); //
        d_float_pp1.resize(0);
        d_float_pp2.resize(0);
        d_float_pp3.resize(0);
        d_float_pp4.resize(0);
        std::cout << "step 4 " << std::endl;
#endif
    }

    Int_t
    getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName = 0) const;
    Double_t analyticalIntegral(Int_t code, const char *rangeName = 0) const;

    Int_t getGenerator(const RooArgSet &directVars,
                       RooArgSet &generateVars,
                       Bool_t staticInitOK = kTRUE) const;
    void initGenerator(Int_t){}; // optional pre-generation initialization
    void generateEvent(Int_t code);
    void CalAmp2s() const;
    void storeAmp2s(const TString path) const;
    void writeAmp2sToFile(const TString path) const;
    void storeResonanceWeights(const TString dataPath, const TString mcPath) const;
    TComplex MEangPart(float, int, float, int, float, float, float, float) const;
    TComplex MEangZPart(float, int, float, int, float, float, float, float, float, float) const;
    TComplex
    MEangXPart(float, int, float, int, float, float, float, float, float, float, float) const;
    //  Float_t GetAmp2s(Jpsihh_dlz&) const;
    Double_t GetAmp2s(Jpsihh_dlz &, Amp_dlz *tnew = NULL, bool method1 = false) const;
    Double_t GetAmp2sSMR(Jpsihh_dlz &,
                         Amp_dlz *tnew = NULL,
                         bool method1 = false,
                         bool finebinning = false) const;
    Double_t GetAmp2sSMR_badbinning(Jpsihh_dlz &, Amp_dlz *tnew = NULL, bool method1 = false) const;
    Double_t GetAmp2sForInt(Jpsihh_dlz &, int, int group = 0) const;
    Double_t GetAmp2sForInt_SMR(Jpsihh_dlz &,
                                int,
                                int group = 0,
                                Amp_dlz *tnew = NULL,
                                bool method1 = false,
                                bool finebinning = false) const;
    Float_t KMLineshape(float mjpsip, int S2, int parity, int ikmcount) const;
    Float_t KMLineshapesmear(float mjpsip, int S2, int parity, int ikmcount) const;
    Float_t KMLineshapesmear1(float mjpsip, int S2, int parity, int ikmcount) const;
    Float_t CalFWHM(float m0 = 4457., int nbin = 500, float range = 2.5) const;
    //  TComplex CalAmp(int ir, int i, int j, int k, int m, Jpsihh_dlz &dlz) const  ;
    //  TComplex CalAmpZ(int ir, int i, int j, int k, int m, Jpsihh_dlz &dlz) const  ;
    //	void updateCache() const;
    void setup_paraList() const;
    void cu_init_data(float *&h_paraList, double *&h_fx, int i_End) const;
    void getInt(double *vint, bool small = false, float ylo = 0, float yhi = 5) const;
    TMatrixD getIFandFF() const;
    TComplex HelicityCoff(RooArgList &ires, Int_t ihel) const;
    TComplex PartWaveCoff(RooArgList &ires, Int_t, Int_t, Int_t) const;
    TComplex PartWaveCoffZ(RooArgList &ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const;
    TComplex PartWaveCoffX(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const;
    TComplex HeliWaveCoff(TComplex *, Int_t, Int_t, Int_t) const;
    Float_t BTerm(Float_t Spin, Float_t mpp, Float_t mr) const;
    Float_t BTermZ(Float_t Spin, Float_t mpp, Float_t mr) const;
    Float_t BTermX(Float_t Spin, Float_t mpp, Float_t mr) const;
    void breit_wigner(float m, float gamma, float e2, float &r_ampl, float &i_ampl) const;
    Float_t F_BW(float r, int L, float p, float p0) const;
    void spline(double mpp, float &r_ampl, float &i_ampl) const;
    void MakeSpline(RooArgList ires) const;
    void MakeSplineZ(RooArgList ires) const;
    bool BW_AMP(float m_r, float gamma_r, float mpp, int LR, float &ampl_r, float &ampl_i) const;
    bool BW_AMP(
        float m_r, float gamma_r, float mpp, int LR, float &ampl_r, float &ampl_i, float br1) const;
    bool Revised_KMAMP(float mpp,
                       int nr,
                       int irst,
                       int ired,
                       float &ampl_r,
                       float &ampl_i,
                       bool isPcChain = 0) const;
    float KMatrixTerm(float m_r, float gamma_r, float mpp, int LR, float &fsc) const;
    bool KMatrix(
        float, int, int, std::vector<float> &, std::vector<float> &, std::vector<TComplex> &) const;
    bool GetCusp_AMP(float m_r, float gamma_r, float mpp, float &ampl_r, float &ampl_i) const;
    bool BW_AMPZ(float m_r, float gamma_r, float mpp, int LR, float &ampl_r, float &ampl_i) const;
    bool BW_AMPX(float m_r, float gamma_r, float mpp, int LR, float &ampl_r, float &ampl_i) const;
    bool
    BW_AMPZSMR(float m_r, float gamma_r, float mpp, int LR, float &ampl_r, float &ampl_i) const;
    //  float getZScale(int S2, int parity, float m0, float g0) const;
    //  float getZScaleSMR(int S2, int parity, float m0, float g0) const;
    Float_t getp(float, float, float) const;
    TComplex getrho(float, float, float, int L = 0) const;
    TComplex getrho_complexMass(float, TComplex, TComplex, int L = 0) const;
    Float_t F_BW2(float r, int L, float p2, float p20) const;
    TComplex F_BW2_complexMass(float r, int L, TComplex p2, TComplex p20) const;
    Float_t getFBW2(float M2, float m1, float m2, int L) const;
    TComplex getFBW2_complexMass(float M2, TComplex m1, TComplex m2, int L) const;
    void filldlz(Jpsihh_dlz &dlz,
                 Double_t xmpk,
                 Double_t,
                 Double_t xcostheta1,
                 Double_t xcostheta2,
                 Double_t xphi1,
                 Double_t xphi2,
                 Double_t,
                 Double_t,
                 Double_t,
                 Double_t,
                 Double_t,
                 Double_t,
                 Double_t,
                 Double_t,
                 Double_t xjpsip,
                 Double_t xcosthetaB_X,
                 Double_t xcosthetaX_X,
                 Double_t xcosthetaPsi_X, // Zcs
                 Double_t xphiX_X,
                 Double_t xphiPsi_X,
                 Double_t xphiMu_X, // Zcs
                 Double_t xcosthetap_X,
                 Double_t xalphaMu_X,
                 Double_t xmjpsik, // Zcs
                 Double_t w = -1001.) const;
    Bool_t kine_limits(float mpp) const;
    Bool_t kine_limitsZ(float mpp) const;
    Bool_t kine_limitsX(float mpp) const;
    void genToy(const TString,
                const char *,
                bool verbose = true,
                bool smear = true,
                bool allvar = false,
                bool fortoystudy = false) const;
    void genToyNoACC(const char *) const;
    Double_t IntegralMethod1() const;
    Double_t IntegralMethod2(bool storePerEventAmp2 = false) const;
    void CalCoupling() const;
    void SetupCoupling(const std::vector<int> &Lz_indices,
                       const std::vector<int> &Pc_indices,
                       const std::vector<int> &Zcs_indices) const;
    void ConvCoupling() const;
    // bool checkchange() const;
    void ModelIndependentWave(float *ampxxx, float ms, float &Rea, float &Ima) const;
    void ModelIndependentWave3(float *ampxxx, float ms, float &Rea, float &Ima) const;
    // void CalWave(float mpk, int index, float &sum_re, float &sum_im) const;
    cnum get_b(cnum alpha, cnum p23) const;
    cnum get_c(cnum alpha, cnum p23, float m_r, float gamma) const;
    cnum this_func(float alpha1, float p23_real, float m_r, float gamma) const;
    void get_cusp_ampli(float m_r, float gamma, float p23, float &r_ampl, float &i_ampl) const;

    virtual RooAbsReal *createSUM(RooAbsData &data, const RooLinkedList &cmdList);
    virtual RooAbsReal *createSUM(RooAbsData &data,
                                  const RooCmdArg &arg1 = RooCmdArg::none(),
                                  const RooCmdArg &arg2 = RooCmdArg::none(),
                                  const RooCmdArg &arg3 = RooCmdArg::none(),
                                  const RooCmdArg &arg4 = RooCmdArg::none(),
                                  const RooCmdArg &arg5 = RooCmdArg::none(),
                                  const RooCmdArg &arg6 = RooCmdArg::none(),
                                  const RooCmdArg &arg7 = RooCmdArg::none(),
                                  const RooCmdArg &arg8 = RooCmdArg::none());

    void storeLineshape(const TString path) const;
    //  Float_t getp(float );

  protected:
    RooListProxy _values;
    TList *_resList;
    TList *_resListZ;
    TList *_resListX;
    RooListProxy resParams;
    bool _isPP;
    bool _isCach;
    int _Nmc;
    int _Nda;
    int _Nda_SMR1;
    int _Nda_SMR_finebinning;
    mutable EvtCGCoefSingle CG1;
    mutable EvtCGCoefSingle CG3;
    mutable EvtCGCoefSingle CG5;
    mutable EvtCGCoefSingle CG7;
    mutable EvtCGCoefSingle CG9;
    mutable EvtCGCoefSingle CG21;
    mutable EvtCGCoefSingle CG41;
    mutable EvtCGCoefSingle CG03;
    mutable EvtCGCoefSingle CG23;
    mutable EvtCGCoefSingle CG43;
    mutable EvtCGCoefSingle CG63;
    mutable EvtCGCoefSingle CG02;
    mutable EvtCGCoefSingle CG22;
    mutable EvtCGCoefSingle CG42;
    mutable TComplex AA[2][2][2][Constant::number_of_Lz][Constant::number_of_Lz][6][6];
    mutable TComplex AAZ[2][2][2][Constant::number_of_Pc][Constant::number_of_Pc][12][12];
    mutable TComplex ABZ[2][2][2][Constant::number_of_Pc][Constant::number_of_Lz][12][6];
    mutable TComplex amp[Constant::number_of_Lz][2][6];
    mutable TComplex ampZ[Constant::number_of_Pc][2][12];
    mutable TComplex ampX[std::max(Constant::number_of_Zcs, 1u)][2][12];
    RooRealProxy _FFR;
    RooRealProxy _FFB;
    RooRealProxy _widthUpperLimit;
    RooRealProxy _widthLowerLimit;
    RooRealProxy _CalFWHM_nbin;
    RooRealProxy _CalFWHM_range;

    Float_t *_resParCache;
    //  mutable std::vector<Jpsihh_dlz> pdlz;
    //  mutable std::vector<Jpsihh_dlz> PDLZ;

    // std::vector<Jpsihh_dlz> *pdlz;
    // std::vector<Jpsihh_dlz> *PDLZ;

    // for data
    std::shared_ptr<std::vector<Jpsihh_dlz *>> PDLZ;
    // const TString MCDATA;
    // TChain* smcdata;
    mutable std::vector<double> _fx;      // pdf value
    mutable std::vector<double> _sw;      // sweight of data
    mutable std::vector<float> _paraList; // param list
    mutable std::vector<float> _vamp;     // coupling
    mutable std::vector<float> _paraSpline;
    mutable std::vector<float> _galpha[4];
    mutable std::vector<float> _fscat[4];
    mutable std::vector<float> _bprod[4]; // Linear term for production vector in K-matrix
    mutable std::vector<float>
        _selfscatter[4]; // Self-scattering term for production vector in K-matrix
    mutable TSpline3 _sa3;
    mutable TSpline3 _sp3;
    Double_t evaluate() const;
    // zhihong
    mutable double _mynll;
    // #ifdef WidthLimit
    mutable double _mypnalty;
    mutable bool _kmchanged;
    mutable std::vector<double> _perEventAmp2;
    // #endif
    int NR;
    int NZ;
    int NX;

    double sumW;
    double sumW_data;
    float m_lb;
    float m_K;
    float m_p;
    float m_jpsi;
    float m_chic1;
    // divide to three part.
    std::vector<float *> h_float_pp;
    std::vector<float *> d_float_pp;
    std::vector<float *> h_float_pp1;
    std::vector<float *> d_float_pp1;
    std::vector<float *> h_float_pp2;
    std::vector<float *> d_float_pp2;
    std::vector<float *> h_float_pp3;
    std::vector<float *> d_float_pp3;
    std::vector<float *> h_float_pp4;
    std::vector<float *> d_float_pp4;

    std::vector<float *> d_float_sw;

  private:
    void writeMCWeightsToFile(const TString mcPath) const;
    void writeDataWeightsToFile(const TString dataPath) const;
    template <bool FORCE_ALL>
    void ConfigureCouplings(const std::vector<int> Lz_indices = {},
                            const std::vector<int> Pc_indices = {},
                            const std::vector<int> Zcs_indices = {}) const;
    // ClassDef(RooDalitzAmplitude,1) // Your description goes here...
};

static __inline__ void invert4x4(const float *src, float *dst) {
    float det;

    /* Compute adjoint: */

    dst[0] = +src[5] * src[10] * src[15] - src[5] * src[11] * src[14] - src[9] * src[6] * src[15] +
             src[9] * src[7] * src[14] + src[13] * src[6] * src[11] - src[13] * src[7] * src[10];

    dst[1] = -src[1] * src[10] * src[15] + src[1] * src[11] * src[14] + src[9] * src[2] * src[15] -
             src[9] * src[3] * src[14] - src[13] * src[2] * src[11] + src[13] * src[3] * src[10];

    dst[2] = +src[1] * src[6] * src[15] - src[1] * src[7] * src[14] - src[5] * src[2] * src[15] +
             src[5] * src[3] * src[14] + src[13] * src[2] * src[7] - src[13] * src[3] * src[6];

    dst[3] = -src[1] * src[6] * src[11] + src[1] * src[7] * src[10] + src[5] * src[2] * src[11] -
             src[5] * src[3] * src[10] - src[9] * src[2] * src[7] + src[9] * src[3] * src[6];

    dst[4] = -src[4] * src[10] * src[15] + src[4] * src[11] * src[14] + src[8] * src[6] * src[15] -
             src[8] * src[7] * src[14] - src[12] * src[6] * src[11] + src[12] * src[7] * src[10];

    dst[5] = +src[0] * src[10] * src[15] - src[0] * src[11] * src[14] - src[8] * src[2] * src[15] +
             src[8] * src[3] * src[14] + src[12] * src[2] * src[11] - src[12] * src[3] * src[10];

    dst[6] = -src[0] * src[6] * src[15] + src[0] * src[7] * src[14] + src[4] * src[2] * src[15] -
             src[4] * src[3] * src[14] - src[12] * src[2] * src[7] + src[12] * src[3] * src[6];

    dst[7] = +src[0] * src[6] * src[11] - src[0] * src[7] * src[10] - src[4] * src[2] * src[11] +
             src[4] * src[3] * src[10] + src[8] * src[2] * src[7] - src[8] * src[3] * src[6];

    dst[8] = +src[4] * src[9] * src[15] - src[4] * src[11] * src[13] - src[8] * src[5] * src[15] +
             src[8] * src[7] * src[13] + src[12] * src[5] * src[11] - src[12] * src[7] * src[9];

    dst[9] = -src[0] * src[9] * src[15] + src[0] * src[11] * src[13] + src[8] * src[1] * src[15] -
             src[8] * src[3] * src[13] - src[12] * src[1] * src[11] + src[12] * src[3] * src[9];

    dst[10] = +src[0] * src[5] * src[15] - src[0] * src[7] * src[13] - src[4] * src[1] * src[15] +
              src[4] * src[3] * src[13] + src[12] * src[1] * src[7] - src[12] * src[3] * src[5];

    dst[11] = -src[0] * src[5] * src[11] + src[0] * src[7] * src[9] + src[4] * src[1] * src[11] -
              src[4] * src[3] * src[9] - src[8] * src[1] * src[7] + src[8] * src[3] * src[5];

    dst[12] = -src[4] * src[9] * src[14] + src[4] * src[10] * src[13] + src[8] * src[5] * src[14] -
              src[8] * src[6] * src[13] - src[12] * src[5] * src[10] + src[12] * src[6] * src[9];

    dst[13] = +src[0] * src[9] * src[14] - src[0] * src[10] * src[13] - src[8] * src[1] * src[14] +
              src[8] * src[2] * src[13] + src[12] * src[1] * src[10] - src[12] * src[2] * src[9];

    dst[14] = -src[0] * src[5] * src[14] + src[0] * src[6] * src[13] + src[4] * src[1] * src[14] -
              src[4] * src[2] * src[13] - src[12] * src[1] * src[6] + src[12] * src[2] * src[5];

    dst[15] = +src[0] * src[5] * src[10] - src[0] * src[6] * src[9] - src[4] * src[1] * src[10] +
              src[4] * src[2] * src[9] + src[8] * src[1] * src[6] - src[8] * src[2] * src[5];

    /* Compute determinant: */

    det = +src[0] * dst[0] + src[1] * dst[4] + src[2] * dst[8] + src[3] * dst[12];

    /* Multiply adjoint with reciprocal of determinant: */

    det = 1.0f / det;

    dst[0] *= det;
    dst[1] *= det;
    dst[2] *= det;
    dst[3] *= det;
    dst[4] *= det;
    dst[5] *= det;
    dst[6] *= det;
    dst[7] *= det;
    dst[8] *= det;
    dst[9] *= det;
    dst[10] *= det;
    dst[11] *= det;
    dst[12] *= det;
    dst[13] *= det;
    dst[14] *= det;
    dst[15] *= det;
}

#endif
