/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
  * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/

#ifndef ROODALITZAMPLITUDE
#define ROODALITZAMPLITUDE

#define MYRN 14
#define MYZN 3

#include "TRandom3.h"
#include "RooAbsPdf.h"
#include "RooRealProxy.h"
#include "RooListProxy.h"
#include "RooCategoryProxy.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include "TList.h"
#include "TComplex.h"
#include "TString.h"
#include "TChain.h"
#include "RooDataSet.h"
#include "RooTDalitz/EvtCGCoefSingle.hh"
#include "RooTDalitz/AngleCal.h"
#include <memory>

class Jpsihh_dlz {
public:
  double mppi;
  double mjpsip;
  double theta;
  double theta1;
  double theta2;
//  double phi;
  double phi1;
  double phi2;
  double phiZ;
  double phiMu;
  double phiPsi;
  double alphaMu;
  double thetaB;
  double thetaPsi;
  double thetaZ;
  double thetap;
  double w;
  bool defed[MYRN+MYZN];
  //bool defedZ[1];
  Float_t ARe[MYRN][2][2][2][6];
  Float_t AIm[MYRN][2][2][2][6];
  Float_t AZRe[MYZN][2][2][2][12];
  Float_t AZIm[MYZN][2][2][2][12];
  Jpsihh_dlz() {}
//  virtual ~Jpsihh_dlz() {}

private:
//   ClassDef(Jpsihh_dlz, 1);
};


class CEvent {
public:
  double mppi;
  double mjpsip;
  double mjpsipi;
  double cosTh_Lb;
  double cosTh_L;
  double cosTh_Jpsi;
  double phi_Mu;
  double phi_K;

  double Z_cosTh_Lb;
  double Z_cosTh_Z;
  double Z_cosTh_Jpsi;
  double Z_phi_Mu;
  double Z_phi_Z;
  double Z_phi_Jpsi;
  double alphaMu;
  double cosTh_p;
  double phsp;
  double w;
  CEvent() {}
private:

};


 
class RooDalitzAmplitude : public RooAbsPdf {
public:
  RooDalitzAmplitude():  CG1(1,2),  CG3(3,2),  CG5(5,2),  CG7(7,2),  CG9(9,2),
  CG21(2,1),  CG41(4,1),  CG03(0,3),  CG23(2,3),  CG43(4,3),  CG63(6,3), m_random(0) {} ; 
  RooDalitzAmplitude(const char *name, const char *title,
		     RooArgList& values, TList*, TList*, const TString MCdata, RooDataSet&, bool isPP=true, bool isCach=true);
  RooDalitzAmplitude(const RooDalitzAmplitude& other, const char* name=0) ;
  virtual TObject* clone(const char* newname) const { return new RooDalitzAmplitude(*this,newname); }
  virtual ~RooDalitzAmplitude() { 
//    if(PDLZ) {
//      PDLZ->clear();
//      delete PDLZ;
//      std::cout << "cleared PDLZ" << std::endl;
//    }//PDLZ->clear();
/*    while(!pdlz.empty()) {
        delete &(pdlz.back());
        pdlz.pop_back();
    }
*/
//    if(pdlz) {
//      pdlz->clear();
//      delete pdlz;//
//      std::cout << "cleared pdlz " << std::endl;
//    }
//    delete _resList;
//    delete _resListZ;
//    std::cout << "capacity " << PDLZ.capacity() << " " << pdlz.capacity() << std::endl;
//    PDLZ.resize(0);
//    pdlz.resize(0);
//    delete _resParCache;
//   delete PDLZ;
//    delete pdlz;
//    delete AA;
//    delete AAZ;
//    delete ABZ;
//    free(AA);
//    free(AAZ);
//    free(ABZ);
//    free(amp);
//    free(ampZ);
  }

  Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=0) const ;
  Double_t analyticalIntegral(Int_t code, const char* rangeName=0) const ;

  Int_t getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t staticInitOK=kTRUE) const;
  void initGenerator(Int_t code) {} ; // optional pre-generation initialization
  void generateEvent(Int_t code);

  TComplex MEang(double, double, int, double, double, int, Jpsihh_dlz&) const;
  TComplex MEangZ(double, double, int, double, double, int, double, Jpsihh_dlz&) const;
  Double_t GetAmp2s(Jpsihh_dlz&, int print=0) const;
  Double_t GetAmp2sForInt(Jpsihh_dlz&, int, int group=0) const;
  void updateCache() const;  
  void getInt(double *vint, double ylo=0, double yhi=5) const;
  TMatrixD getIFandFF() const;  
  TComplex HelicityCoff(RooArgList ires, Int_t ihel) const;
  TComplex PartWaveCoff(RooArgList ires, Int_t, Int_t, Int_t) const;
  TComplex PartWaveCoffZ(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const;
  Double_t BTerm(Double_t Spin, Double_t mpp, Double_t mr) const;
  Double_t BTermZ(Double_t Spin, Double_t mpp, Double_t mr) const;
  void breit_wigner(double m, double gamma, double e2, double &r_ampl, double &i_ampl) const;
  Double_t F_BW(double r, int L, double p, double p0) const;
  bool BW_AMP(double m_r, double gamma_r, double mpp, int LR,
	      double &ampl_r, double &ampl_i) const;
  bool BW_AMP(double m_r, double gamma_r, double mpp, int LR,
	      double &ampl_r, double &ampl_i,double ) const;
	      
  bool BW_AMPZ(double m_r, double gamma_r, double mpp, int LR,
	      double &ampl_r, double &ampl_i) const;
  Double_t getp(double, double, double ) const;
  void filldlz(Jpsihh_dlz &dlz, Double_t xmppi, Double_t ,
	       Double_t xcostheta1, Double_t xcostheta2,
	       Double_t xphi1, Double_t xphi2, 
	       Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t,
	       Double_t xjpsip = 0.0, Double_t w = 1.0) const;
  Bool_t kine_limits(double mpp) const;
  Bool_t kine_limitsZ(double mpp) const;  
  void genToy(const char*, bool verbose = false) const;
  void genToyNoACC(const char*) const;  
  void ResetDef(int ir) const;
  Double_t IntegralMethod1() const;
  void CalCoupling() const;
  bool checkchange() const;

  virtual RooAbsReal* createSUM(RooAbsData& data, const RooLinkedList& cmdList) ;
  virtual RooAbsReal* createSUM(RooAbsData& data, const RooCmdArg& arg1=RooCmdArg::none(),  const RooCmdArg& arg2=RooCmdArg::none(),  
				const RooCmdArg& arg3=RooCmdArg::none(),  const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),  
				const RooCmdArg& arg6=RooCmdArg::none(),  const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) ;

  double GetMaxWeight(int dType);
  double GetEff(double M_ppi, double cosTh_Lb, double cosTh_L, double cosTh_Jpsi, double phi_Mu, double phi_K);
  void CreateToyDataSet(int numEvents, int dType, double maxWeight, TString fname);
  CEvent GenEvent();
  void eff_init(int nBinX, int nBinY, TString inTreeLoc, bool isBkgInit);

  double mceff(double mL, double effVar, TString name, int nBinY) const;
  double mceff(double mL, double effVar, TString name, int nBinY, int _npoint) const;  
  //  Double_t getp(double );

  double cubicInterpolate (double p[4], double x) const 
  {
    return p[1] + 0.5 * x*(p[2] - p[0] + x*(2.0*p[0] - 5.0*p[1] + 4.0*p[2] - p[3] + x*(3.0*(p[1] - p[2]) + p[3] - p[0])));    
  }

  double bicubicInterpolate (double p[4][4], double x, double y) const 
  {
    double arr[4];
    arr[0] = cubicInterpolate(p[0], y);
    arr[1] = cubicInterpolate(p[1], y);
    arr[2] = cubicInterpolate(p[2], y);
    arr[3] = cubicInterpolate(p[3], y);
    return cubicInterpolate(arr, x);    
  }

  double bilinearInterpolate (double p[2][2], double x, double y) const 
  {
    return p[0][0]*(1.0-x)*(1.0-y) + p[1][0]*x*(1.0-y) + p[0][1]*(1.0-x)*y + p[1][1]*x*y; 
  }

  

protected:

  RooListProxy _values ;
  TList *_resList;
  TList *_resListZ;
  RooListProxy resParams;
  bool _isPP;  
  bool _isCach;
  
  mutable EvtCGCoefSingle CG1;
  mutable EvtCGCoefSingle CG3;
  mutable EvtCGCoefSingle CG5;
  mutable EvtCGCoefSingle CG7;
  mutable EvtCGCoefSingle CG9;
  mutable EvtCGCoefSingle CG21;
  mutable EvtCGCoefSingle CG41;
  mutable EvtCGCoefSingle CG03;
  mutable EvtCGCoefSingle CG23;
  mutable EvtCGCoefSingle CG43;
  mutable EvtCGCoefSingle CG63;
  mutable TComplex AA[2][2][2][MYRN][MYRN][6][6];
  mutable TComplex AAZ[2][2][2][MYZN][MYZN][12][12];
  mutable TComplex ABZ[2][2][2][MYZN][MYRN][12][6];  
//  mutable TComplex amp[MYRN][2][2][2][6];
//  mutable TComplex ampZ[MYZN][2][2][2][12];
  
  Double_t* _resParCache;
//  mutable std::vector<Jpsihh_dlz> pdlz;
//  mutable std::vector<Jpsihh_dlz> PDLZ;  

  //std::vector<Jpsihh_dlz> *pdlz;
  //std::vector<Jpsihh_dlz> *PDLZ;    
  std::shared_ptr<std::vector<Jpsihh_dlz> > pdlz;
  std::shared_ptr<std::vector<Jpsihh_dlz> > PDLZ;  
  //const TString MCDATA;
  //TChain* smcdata;
 TRandom3 m_random;
 AngleCal m_anglecal;
   
  //For efficiencies/CFit
//  bool eff_by_binning;
  double mppi_min, mppi_max;
//  double mJpsip_min, mJpsip_max;
  //mc, signal 
  double mc_nBinY, mc_cos_wBinY, mc_phi_wBinY, mc_nBinX, mc_wBinX;
  double mc_npoint;
  std::vector<double> mceff_cosL;
  std::vector<double> mceff_cosLb;
  std::vector<double> mceff_cosJpsi;
  std::vector<double> mceff_phiMu;
  std::vector<double> mceff_phiK;

  //sidebands, bkg
  double bkg_nBinY, bkg_cos_wBinY, bkg_phi_wBinY, bkg_nBinX, bkg_wBinX;
  double bkg_npoint;
  std::vector<double> bkgeff_cosL;
  std::vector<double> bkgeff_cosLb;
  std::vector<double> bkgeff_cosJpsi;
  std::vector<double> bkgeff_phiMu;
  std::vector<double> bkgeff_phiK;



  Double_t evaluate() const ;
  Int_t NR;
  Int_t NZ;  
  double sumW;
  double m_lb;
  double m_pi;
  double m_p;
  double m_jpsi;

private:

  // ClassDef(RooDalitzAmplitude,1) // Your description goes here...
};
 
#endif
